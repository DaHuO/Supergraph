def get self t = str return t self getword 		32 33
def read self reader self n self r self p self s = reader get int for _ in range 4 		48 49
def split args inputfn = args input_file ret = inputname = inputfn - 3 if inputfn endswith .in else inputfn testsdir = inputname + _split if not os path isdir testsdir os mkdir testsdir handle = open inputfn rt reader = reader handle tests = reader get int for i in range 1 tests + 1 testfn = os path join testsdir %.5d.pickle % i if not os path exists testfn or args clean_pickles test = test i test read reader testhandle = open testfn wb pickle dump test testhandle testhandle close ret append testfn handle close return ret 		147 166
def __init__ self handle self handle = handle self buf = 		20 22
def solve self handle handle write case #%d: % self case n p r s = self n self p self r self s c = 2 ** n w = sorted r r p p s s wc = w 0 for w in w if n % 2 == 0 t = c // 3 if wc != t t t + 1 handle write impossible\n return else t = c // 3 if wc != t t + 1 t + 1 handle write impossible\n return row = self makerow w n row = self fix row handle write join row + \n 		108 132
def __init__ self case self case = case 		45 46
def win self l r if l == p and r == r return p if l == p and r == s return s if l == r and r == p return p if l == r and r == s return r if l == s and r == p return s if l == s and r == r return r 		51 57
def fix self row l = len row if l == 1 return row h = l // 2 a = self fix row h b = self fix row h if a > b a b = b a return a + b 		99 106
def master args prog inputfn = args input_file testfns = split args semaphore = mp boundedsemaphore args jobs if args clean_results for testfn in testfns testname = testfn - 7 testoutfn = testname + .out if os path exists testoutfn os unlink testoutfn processes = mp process target = runsolvemode args = semaphore prog inputfn testfn for testfn in testfns if not args keep_order random shuffle processes for proc in processes proc start for proc in processes proc join merge inputfn testfns 		193 206
def main parser = argparse argumentparser description = solve some gcj task. parser add_argument input_file metavar = input_file parser add_argument --test-case parser add_argument -p --clean-pickles action = store_true parser add_argument -r --clean-results action = store_true parser add_argument -j --jobs type = int default = 5 parser add_argument -o --keep-order action = store_true args = parser parse_args if args test_case == none master args sys argv 0 else slave args 		209 220
def ok self return bool self handle 		24 25
def getword self while self handle and not self buf self buf = self handle readline strip if not self handle and not self buf return p = re search self endofword self buf start word = self buf p self buf = self buf p lstrip return word 		35 41
def slave args testfn = args test_case testname = testfn - 7 testtmpfn = testname + .tmp test = pickle load open testfn rb testtmphandle = open testtmpfn wt test solve testtmphandle testtmphandle close testoutfn = testname + .out os rename testtmpfn testoutfn 		135 144
def getline self if self buf return self buf if self handle return self handle readline - 1 return 		27 30
def runsolvemode semaphore prog inputfn testfn testname = testfn - 7 semaphore acquire testoutfn = testname + .out if not os path exists testoutfn print solving ``%s\'\'... % testname sp call prog inputfn --test-case testfn else print ``%s\'\' already solved... % testname semaphore release 		169 178
def ok self a if len a <= 1 return true b = for i in range len a // 2 l r = a 2 * i a 2 * i + 1 if l == r return false b append self win l r return self ok b 		59 66
def merge inputfn testfns inputname = inputfn - 3 if inputfn endswith .in else inputfn outputfn = inputname + .out handle = open outputfn wt for testfn in testfns testname = testfn - 7 testoutfn = testname + .out assert os path exists testoutfn for line in open testoutfn rt handle write line handle close 		181 190
def makerow self w n if n == 0 return w 2 1 wc = w 0 for w in w if n % 2 == 0 t = len w // 3 h = t + 1 // 2 ww = h - 1 self win w 0 1 w 1 1 h self win w 0 1 w 2 1 h self win w 1 1 w 2 1 nr = self makerow ww n - 1 else t = len w // 3 h = t // 2 ww = h self win w 0 1 w 1 1 h self win w 0 1 w 2 1 h + 1 self win w 1 1 w 2 1 nr = self makerow ww n - 1 ret = for a in nr if a == self win w 0 1 w 1 1 ret += w 0 1 w 1 1 if a == self win w 0 1 w 2 1 ret += w 0 1 w 2 1 if a == self win w 1 1 w 2 1 ret += w 1 1 w 2 1 return ret 		68 97
