def parse input_file output_file with open input_file as f t = int f readline split 0 out = open output_file w solu = solu 12 for i in range t n r p s = map int f readline split sol = solu solve n r p s line = case # + str i + 1 + : + str sol print line out write line + \n return 		5 16
def solve self n r p s dists = get_dist n if r p s not in dists return impossible surviving = dists index p r s ret = self res n surviving return join map trans ret 		105 111
def __init__ self n self n = n self res = dict self res 1 = 0 01 1 12 2 02 self popu 		82 90
def trans d if int d == 0 return p if int d == 1 return r if int d == 2 return s 		19 25
def check perm if len perm == 1 return true if not perm raise valueerror winners = firsts = range 0 len perm 2 seconds = range 1 len perm 2 for f s in zip firsts seconds if perm f == perm s return false summ = perm f + perm s if summ == 3 winners append 1 elif summ == 2 winners append 2 elif summ == 1 winners append 0 else raise valueerror return check winners 		37 58
def get_dist n ret = for final in range 3 counts = 0 0 0 counts final += 1 rounds = n while rounds != 0 newcounts = 0 0 0 newcounts 0 += counts 0 newcounts 0 += counts 2 newcounts 1 += counts 0 newcounts 1 += counts 1 newcounts 2 += counts 1 newcounts 2 += counts 2 rounds -= 1 counts = newcounts ret append counts return ret 		60 77
def small_solve n r p s all_perm = itertools permutations 0 * p + 1 * r + 2 * s for perm in all_perm if check perm return join map trans perm return impossible 		29 34
def popu self for n in range 2 self n + 1 nsol = 0 none 1 none 2 none for surviving in range 3 first_dig = int self res 1 surviving 0 second_dig = int self res 1 surviving 1 first_sol = self res n - 1 first_dig second_sol = self res n - 1 second_dig nsol surviving = min first_sol + second_sol second_sol + first_sol self res n = nsol 		92 102
