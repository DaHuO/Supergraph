def log_it arguments = true output = true def decorating_function user_function def wrapper * args ** kwargs if arguments print time ctime \' + user_function __qualname__ + \' arguments args= args kwargs= kwargs result = user_function * args ** kwargs if output print time ctime : function \' + user_function __qualname__ + \' outputs result return result return update_wrapper wrapper user_function return decorating_function 		57 68
def __enter__ self self __input_file = open self __input_filename r self __parsed_file = open self __parsed_filename w self __output_file = open self __output_filename w 		132 136
def decorating_function user_function def wrapper * args ** kwargs if arguments print time ctime \' + user_function __qualname__ + \' arguments args= args kwargs= kwargs result = user_function * args ** kwargs if output print time ctime : function \' + user_function __qualname__ + \' outputs result return result return update_wrapper wrapper user_function 		58 67
def count_it inner_func global _call_func_counters assert type _call_func_counters == dict assert inner_func __qualname__ not in _call_func_counters _call_func_counters inner_func __qualname__ = 0 wraps inner_func def wrapper * args ** kwargs global _call_func_counters _call_func_counters inner_func __qualname__ += 1 return inner_func * args ** kwargs return wrapper 		72 83
def alphabetically_first_solution l jump = 1 while jump < len l for s in range 0 len l 2 * jump t1 = l s s + jump t2 = l s + jump s + 2 * jump if t2 < t1 l s + jump s + 2 * jump = t1 l s s + jump = t2 jump *= 2 assert jump == len l return join l 		271 282
def write self s self __output_file write s 		155 157
wraps inner_func def wrapper * args ** kwargs global _call_func_counters _call_func_counters inner_func __qualname__ += 1 return inner_func * args ** kwargs 		78 82
def find_solution n r p s a = try_winner rock n r p s print a if a is not none a = alphabetically_first_solution a else a = z b = try_winner paper n r p s print b if b is not none b = alphabetically_first_solution b else b = z c = try_winner scissors n r p s print c if c is not none c = alphabetically_first_solution c else c = z print if a == b == c == z return impossible return min a b c 		228 250
wraps inner_func def wrapper * args ** kwargs print --> start function \' + inner_func __qualname__ + \' : time ctime start_time = time time res = inner_func * args ** kwargs end_time = time time print --> end  function \' + inner_func __qualname__ + \' : time ctime print --> elapsed time \' + inner_func __qualname__ + \' : end_time - start_time print return res 		43 52
def try_winner winner n r p s l = winner for _round in range n l2 = for i in l if i == rock l2 extend rock scissors elif i == paper l2 extend paper rock else assert i == scissors l2 extend scissors paper l = l2 if l count rock == r and l count paper == p and l count scissors == s return l return none 		253 268
time_it wraps inner_func def wrapper * args ** kwargs filename = pre-process_ + inner_func __qualname__ + .pickle if filename not in os listdir print --> pre process started for function \' + inner_func __qualname__ + \' .... pre_process_data = inner_func print --> pre process ended for function \' + inner_func __qualname__ + \' print --> pickling started for function \' + inner_func __qualname__ + \' .... with open filename wb as f_pp pickle dump pre_process_data f_pp pickle highest_protocol print --> pickling ended for function \' + inner_func __qualname__ + \' print --> unpickling pre-processed data of function \' + inner_func __qualname__ + \' ... with open filename rb as f_pp data = pickle load f_pp print --> unpickling ended print return data 		94 111
def pre_process_it inner_func import inspect import pickle a = inspect signature inner_func if len a aparmeters raise valueerror a pre process function must not have arguments time_it wraps inner_func def wrapper * args ** kwargs filename = pre-process_ + inner_func __qualname__ + .pickle if filename not in os listdir print --> pre process started for function \' + inner_func __qualname__ + \' .... pre_process_data = inner_func print --> pre process ended for function \' + inner_func __qualname__ + \' print --> pickling started for function \' + inner_func __qualname__ + \' .... with open filename wb as f_pp pickle dump pre_process_data f_pp pickle highest_protocol print --> pickling ended for function \' + inner_func __qualname__ + \' print --> unpickling pre-processed data of function \' + inner_func __qualname__ + \' ... with open filename rb as f_pp data = pickle load f_pp print --> unpickling ended print return data return wrapper 		87 113
time_it def main_run print directory : os getcwd file_names = x for x in os listdir l1 = os stat x st_mtime x for x in file_names if x endswith .in if not l1 raise valueerror no input file found chosen_prefix = sorted l1 - 1 1 - 3 input_filename = chosen_prefix + .in print chosen input : input_filename parsed_filename = chosen_prefix + .parsed.txt l2 = x split . 0 for x in file_names if x endswith .out and x startswith chosen_prefix l2 = int x split -run - 1 for x in l2 output_file_index = 000 + str max 0 + l2 + 1 - 3 output_filename = chosen_prefix + -run + output_file_index + .out print chosen output : output_filename print io_wrapper = gcjiowrapper input_filename parsed_filename output_filename with io_wrapper solve_all_cases io_wrapper print print conclusion : print directory : os getcwd print chosen input : input_filename print chosen output : output_filename 		165 199
def memoize_it inner_func global __memoization_registry cache = __memoization_registry append cache wraps inner_func def wrapper * args ** kwargs if args not in cache cache args = inner_func * args ** kwargs return cache args return wrapper 		18 28
def __init__ self input_filename parsed_filename output_filename self __input_filename = input_filename self __parsed_filename = parsed_filename self __output_filename = output_filename self __index_test_case = 0 self __input_file = none self __parsed_file = none self __output_file = none 		123 130
def new_test_case self self __index_test_case += 1 self __parsed_file write \n## _bigonion test case: + str self __index_test_case + ##\n 		150 153
time_it def solve_all_cases io_wrapper t = int io_wrapper readline for test_case in range 1 t + 1 io_wrapper new_test_case assert io_wrapper get_test_case == test_case solve_one_case io_wrapper 		203 209
def readline self l = self __input_file readline self __parsed_file write l return l 		144 148
def time_it inner_func wraps inner_func def wrapper * args ** kwargs print --> start function \' + inner_func __qualname__ + \' : time ctime start_time = time time res = inner_func * args ** kwargs end_time = time time print --> end  function \' + inner_func __qualname__ + \' : time ctime print --> elapsed time \' + inner_func __qualname__ + \' : end_time - start_time print return res return wrapper 		42 53
def __exit__ self type_e value tb self __input_file close self __parsed_file close self __output_file close 		138 142
def solve_one_case io_wrapper n r p s = int x for x in io_wrapper readline split assert r + p + s == 2 ** n solution = find_solution n r p s io_wrapper write case # + str io_wrapper get_test_case + : + solution + \n 		220 225
def reset_memoization global __memoization_registry try for cache_d in __memoization_registry cache_d clear 		32 36
wraps inner_func def wrapper * args ** kwargs if args not in cache cache args = inner_func * args ** kwargs return cache args 		23 27
def wrapper * args ** kwargs if arguments print time ctime \' + user_function __qualname__ + \' arguments args= args kwargs= kwargs result = user_function * args ** kwargs if output print time ctime : function \' + user_function __qualname__ + \' outputs result return result 		59 66
def get_test_case self return self __index_test_case 		159 161
