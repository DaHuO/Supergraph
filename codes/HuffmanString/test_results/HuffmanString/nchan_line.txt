['}', 2805]
['return false;', 265]
['return NGX_OK;', 234]
['else {', 226]
['#endif', 178]
['return true;', 177]
['break;', 139]
['end', 135]
['*', 123]
['*/', 94]
['return NULL;', 90]
['"\\n"', 81]
['return NGX_ERROR;', 79]
['typedef struct {', 77]
['return;', 71]
['return REDIS_ERR;', 70]
['default:', 69]
['/*', 62]
['else', 51]
['NULL } ,', 50]
['NGX_HTTP_LOC_CONF_OFFSET,', 47]
['} else {', 45]
['};', 44]
['ctx->error = INVALID_TYPE_ERROR;', 41]
['"end\\n"', 40]
['#if FAKESHARD', 39]
['if (!cmp_read_object(ctx, &obj))', 38]
['cmp_object_t obj;', 38]
['return REDIS_OK;', 37]
['#else', 33]
['#include <nchan_module.h>', 32]
['freeReplyObject(reply);', 32]
['return 0;', 30]
['ctx->error = DATA_READING_ERROR;', 30]
['#include <assert.h>', 28]
['"  end\\n"', 28]
['switch (obj->type) {', 28]
['assert(0);', 26]
['do {                                                                             \\', 25]
['} while(0)', 24]
['{', 24]
['#define DEBUG_LEVEL NGX_LOG_DEBUG', 23]
['//#define DEBUG_LEVEL NGX_LOG_WARN', 23]
['return 1;', 23]
['case CMP_TYPE_POSITIVE_FIXNUM:', 23]
['case CMP_TYPE_UINT8:', 22]
['return rc;', 20]
['0,', 18]
['case CMP_TYPE_UINT16:', 17]
['NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,', 17]
['free(cmd);', 17]
['redisContext *c = &(ac->c);', 17]
['return NGX_CONF_ERROR;', 16]
['redisContext *c;', 16]
['ctx->error = DATA_WRITING_ERROR;', 15]
['case CMP_TYPE_NEGATIVE_FIXNUM:', 15]
['switch (obj.type) {', 15]
['group: "pubsub",', 15]
['return NGX_DECLINED;', 15]
['case CMP_TYPE_SINT8:', 14]
['NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,', 14]
['printf("Error: %s\\n", c->errstr);', 14]
['*     specific prior written permission.', 13]
['* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR', 13]
['* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"', 13]
['* All rights reserved.', 13]
['//', 13]
['ctx->error = LENGTH_WRITING_ERROR;', 13]
['* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE', 13]
['*     this list of conditions and the following disclaimer.', 13]
['* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)', 13]
['* Redistribution and use in source and binary forms, with or without', 13]
['*     notice, this list of conditions and the following disclaimer in the', 13]
['* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF', 13]
['*     to endorse or promote products derived from this software without', 13]
['*   * Neither the name of Redis nor the names of its contributors may be used', 13]
['void', 13]
['* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE', 13]
['*   * Redistributions of source code must retain the above copyright notice,', 13]
['* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS', 13]
['*     documentation and/or other materials provided with the distribution.', 13]
['* POSSIBILITY OF SUCH DAMAGE.', 13]
['redisFree(c);', 13]
['* modification, are permitted provided that the following conditions are met:', 13]
['* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE', 13]
['*   * Redistributions in binary form must reproduce the above copyright', 13]
['* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN', 13]
['* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE', 13]
[':loc_conf,', 12]
['case CMP_TYPE_UINT32:', 12]
['NULL,', 12]
['"    end\\n"', 12]
['return -1;', 12]
['return c;', 12]
['if (c == NULL)', 11]
['#if NCHAN_SUBSCRIBER_LEAK_DEBUG', 11]
['case CMP_TYPE_SINT16:', 11]
['} while (0)', 11]
['#include <stdlib.h>', 11]
['full_subscriber_t  *fsub = (full_subscriber_t  *)self;', 11]
['#if NCHAN_BENCHMARK', 11]
['#include <string.h>', 11]
['return NGX_CONF_OK;', 10]
['ngx_free(d);', 10]
['memstore_fakeprocess_pop();', 10]
['#if nginx_version >= 1008000', 10]
['#include <subscribers/common.h>', 10]
['int len;', 10]
['#if NCHAN_RBTREE_DBG', 9]
['shmtx_lock(shm);', 9]
['#if NCHAN_MSG_LEAK_DEBUG', 9]
['#include <stdio.h>', 9]
['shmtx_unlock(shm);', 9]
['redisContextCloseFd(c);', 9]
['*type = obj.as.ext.type;', 9]
['goto finalize;', 9]
['* Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>', 9]
['sdsfree(y);', 9]
['if(head == NULL) {', 9]
['str_shm_free(d->shm_chid);', 9]
['"end)(enable_debug)\\n"', 8]
['"local dbg = (function(on)\\n"', 8]
['ngx_conf_set_num_slot,', 8]
['if (ctx->write(ctx, &type, sizeof(int8_t)))', 8]
['local dbg = (function(on)', 8]
['sdsfree(x);', 8]
['"    else\\n"', 8]
['//     c = __connect_nonblock();', 8]
['}                                                                              \\', 8]
['"else\\n"', 8]
['}                                                                        \\', 8]
['end)(enable_debug)', 8]
['ctx->error = EXT_TYPE_WRITING_ERROR;', 8]
['return cmp_err(cmp);', 8]
['for(i = 0; i < n; i++) {', 8]
['v->not_found = 1;', 8]
['if (size <= 0xFFFF)', 8]
['}                                                                            \\', 8]
['ctx->error = EXT_TYPE_READING_ERROR;', 8]
['if (status != REDIS_OK) {', 8]
['* ============================================================================', 8]
['local enable_debug=true', 8]
['case CMP_TYPE_SINT32:', 8]
['"local enable_debug=true\\n"', 8]
['if(ctx) {', 8]
['//     redisFree(c);', 8]
['if (size == 0)', 7]
['ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);', 7]
['c = redisContextInit();', 7]
['redisReply *reply;', 7]
['buf->memory = 1;', 7]
['struct sdshdr *sh = (void*) (s-sizeof *sh);;', 7]
['#include <signal.h>', 7]
['nchan_request_ctx_t  *ctx = ngx_http_get_module_ctx(r, nchan_module);', 7]
['redisReaderFree(reader);', 7]
['if (ctx->write(ctx, data, size))', 7]
['if (r == NULL)', 7]
['\\', 7]
['case CMP_TYPE_UINT64:', 7]
['redisAeEvents *e = (redisAeEvents*)privdata;', 7]
['return sub;', 7]
['goto error;', 7]
['__redisAsyncDisconnect(ac);', 7]
['ngx_conf_set_sec_slot,', 7]
['if(next) {', 7]
['continue;', 7]
['verify_reaper_list(rp, NULL);', 7]
['reader = redisReaderCreate();', 7]
['cur++;', 7]
['case CMP_TYPE_BIN32:', 6]
['case CMP_TYPE_STR16:', 6]
['return head;', 6]
['group: "security",', 6]
['((void)loop);', 6]
['ctx->error = LENGTH_READING_ERROR;', 6]
['cur = next;', 6]
['nchan_request_ctx_t        *ctx = get_main_request_ctx(r);', 6]
['group: "storage",', 6]
['switch(status) {', 6]
['y = sdsdup(x);', 6]
['args: 1,', 6]
['sub->fn->dequeue(sub);', 6]
['r->header_only = 1;', 6]
['if(head->shared) {', 6]
['d->t = ngx_current_msec;', 6]
['goto fmt_valid;', 6]
['do {', 6]
['if(privdata != NULL) {', 6]
['if(msg) {', 6]
['NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3|NGX_CONF_TAKE4|NGX_CONF_TAKE5|NGX_CONF_TAKE6|NGX_CONF_TAKE7,', 6]
['ctx->error = INPUT_VALUE_TOO_LARGE_ERROR;', 6]
['ngx_conf_set_str_slot,', 6]
['redisReply *reply = r;', 6]
['return p;', 6]
['ngx_gettimeofday(&tv);', 6]
['case CMP_TYPE_BIN8:', 6]
['default: "(none)",', 6]
['return r;', 6]
['case CMP_TYPE_BIN16:', 6]
['case CMP_TYPE_STR32:', 6]
['#ifdef __cplusplus', 6]
['size_t len;', 6]
['signal(SIGPIPE, SIG_IGN);', 6]
['"  else\\n"', 6]
['rwl_unlock_mutex(lock);', 6]
['ret = redisReaderGetReply(reader,&reply);', 6]
['return ret;', 6]
['char *cmd;', 6]
['next = cur->next;', 6]
['case CMP_TYPE_FIXSTR:', 6]
['case CMP_TYPE_MAP32:', 5]
['subscriber_t         *sub;', 5]
['if (size <= FIXSTR_SIZE)', 5]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);', 5]
['if (!ctx->read(ctx, &obj->as.u32, sizeof(uint32_t))) {', 5]
['"}\\n"', 5]
['va_end(ap);', 5]
['exit(1);', 5]
['callback(NGX_HTTP_INTERNAL_SERVER_ERROR, NULL, privdata);', 5]
['bc.buf.flush = 1;', 5]
['char *b = (char *)&x;', 5]
[':ngx_conf_set_str_slot,', 5]
['swap = b[0];', 5]
['d = ngx_alloc(sizeof(*d), ngx_cycle->log);', 5]
['va_list ap;', 5]
['#include "longpoll-private.h"', 5]
['if (!is_bigendian()) {', 5]
['#if (DEBUG_SHM_ALLOC == 1)', 5]
['for (j = 0; j < argc; j++) {', 5]
['p++;', 5]
['redisLibeventEvents *e = (redisLibeventEvents*)privdata;', 5]
['if (!ctx->read(ctx, &obj->as.u16, sizeof(uint16_t))) {', 5]
['void memstore_fakeprocess_push(ngx_int_t slot);', 5]
['d->channel_id = channel_id;', 5]
['case CMP_TYPE_FIXEXT1:', 5]
['__redisReaderSetErrorOOM(r);', 5]
['if (c->err) {', 5]
['case CMP_TYPE_FIXEXT16:', 5]
['for(i=0; i < max; i++) {', 5]
['case CMP_TYPE_FIXARRAY:', 5]
['case CMP_TYPE_ARRAY16:', 5]
['case CMP_TYPE_SINT64:', 5]
['spoolcollector_addspool(data, spool);', 5]
['endif', 5]
['}                                                                    \\', 5]
['redisLibuvEvents* p = (redisLibuvEvents*)privdata;', 5]
['if(ctx->request_origin_header.len > 0) {', 5]
['case CMP_TYPE_MAP16:', 5]
['size = be32(size);', 5]
['return x;', 5]
['case CMP_TYPE_EXT16:', 5]
['buf->last_buf = 1;', 5]
['sub->dequeue_after_response = 0;', 5]
['if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {', 5]
['case CMP_TYPE_FIXMAP:', 5]
['case CMP_TYPE_EXT32:', 5]
['char *p;', 5]
['nchan_add_response_header(r, &NCHAN_HEADER_ALLOW_ORIGIN, &cf->allow_origin);', 5]
['redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);', 5]
['void memstore_fakeprocess_push_random(void);', 5]
['char swap = 0;', 5]
['* references must be substituted with the new pointer returned by the call. */', 5]
['subscribe_data_free(d);', 5]
['case CMP_TYPE_FIXEXT8:', 5]
['argv++; argc--;', 5]
['goto exit;', 5]
['__redisSetError(c,REDIS_ERR_OTHER,strerror(errno));', 5]
['case CMP_TYPE_FIXEXT4:', 5]
['if (reply == NULL) return;', 5]
['case CMP_TYPE_FIXEXT2:', 5]
['ngx_connection_t *connection = (ngx_connection_t *) privdata;', 5]
['case CMP_TYPE_EXT8:', 5]
['#if NCHAN_MSG_RESERVE_DEBUG', 5]
['case NGX_ERROR:', 5]
['case CMP_TYPE_ARRAY32:', 5]
['head = nchan_memstore_find_chanhead(d->shm_chid);', 5]
['cmp_err(&cmp);', 5]
['redisLibevEvents *e = (redisLibevEvents*)privdata;', 5]
['size = be16(size);', 5]
['case CMP_TYPE_STR8:', 5]
['internal_subscriber_t   *f = (internal_subscriber_t *)self;', 5]
['#include <hiredis.h>', 5]
['#include "fmacros.h"', 5]
['return DICT_OK;', 5]
['return ac;', 5]
['if (ctx->read(ctx, data, *size))', 4]
['DBG("%p output status to subscriber", sub);', 4]
[');', 4]
['return NGX_ABORT;', 4]
['}                                                                      \\', 4]
['case REDIS_REPLY_ERROR:', 4]
['#include "../async.h"', 4]
['NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,', 4]
['printf("Disconnected...\\n");', 4]
['uv_poll_start(&p->handle, p->events, redisLibuvPoll);', 4]
['if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {', 4]
['* Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>', 4]
['#if (NGX_HAVE_ATOMIC_OPS)', 4]
[':ngx_conf_set_sec_slot,', 4]
['rwl_lock_mutex(lock);', 4]
['for(i=0; i<max; i++){', 4]
['#include <async.h>', 4]
['ngx_memzero(buf, sizeof(*buf));', 4]
['redisReply *r, *parent;', 4]
['return NGX_AGAIN;', 4]
['p = r->buf+r->pos;', 4]
['// }', 4]
['#include "internal.h"', 4]
['int main (int argc, char **argv) {', 4]
['/* Nothing should be attached when something is already attached */', 4]
['redisReadTask *cur = &(r->rstack[r->ridx]);', 4]
['for (i = 0; i < num; i++) {', 4]
['sub->name = &sub_name;', 4]
['ngx_http_request_t            *sr;', 4]
['return s;', 4]
['nchan_request_ctx_t            *ctx = ngx_http_get_module_ctx(r, nchan_module);', 4]
['/* Let *c leak for now... */', 4]
['free(replies);', 4]
['if (task->parent) {', 4]
['void disconnectCallback(const redisAsyncContext *c, int status) {', 4]
['//TODO', 4]
['ngx_http_finalize_request(r, rc);', 4]
['aeEventLoop *loop = e->loop;', 4]
['printf("argv[%s]: %s\\n", (char*)privdata, reply->str);', 4]
['redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");', 4]
['struct sdshdr *sh;', 4]
['if (ctx->write(ctx, &size, sizeof(uint32_t)))', 4]
['*context = NULL;', 4]
['r->headers_out.content_length_n = 0;', 4]
['#include "hiredis.h"', 4]
['redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));', 4]
['ngx_conf_set_flag_slot,', 4]
['redisAsyncSetConnectCallback(c,connectCallback);', 4]
['return cmp_write_false(ctx);', 4]
['assert(parent->type == REDIS_REPLY_ARRAY);', 4]
['/* Disconnect after receiving the reply to GET */', 4]
['moveToNextTask(r);', 4]
['struct {', 4]
['/* Register functions to start/stop listening for events */', 4]
['if (obj == NULL) {', 4]
['void getCallback(redisAsyncContext *c, void *r, void *privdata) {', 4]
['#include "store-private.h"', 4]
['offsetof(nchan_loc_conf_t, max_messages),', 4]
['if(status_code == NGX_HTTP_NO_CONTENT || status_code == NGX_HTTP_NOT_MODIFIED) {', 4]
['#include "../hiredis.h"', 4]
['start_chanhead_spooler(head);', 4]
['c->flags |= REDIS_BLOCK;', 4]
['#if (NGX_THREADS)', 4]
['((void) privdata);', 4]
['return function(...)', 4]
['set_multimsg_msg(d, sd, msg, status);', 4]
['buf->pos = buf->start;', 4]
['case REDIS_REPLY_STRING:', 4]
['goto fmt_invalid;', 4]
['//output: subscriber_id, num_current_subscribers', 4]
['c = connect(config);', 4]
['max = sizeof(seed->actives)/sizeof(cur);', 4]
['*c = obj.as.u8;', 4]
['while(1) {', 4]
['if(cmp_to_str(&cmp, &chid)) {', 4]
['shdata->old_max_workers = shdata->max_workers;', 4]
['const char *source_addr) {', 4]
['swap = b[1];', 4]
['d->privdata = privdata;', 4]
['const void *data);', 4]
['ngx_free(fsub);', 4]
['int i;', 4]
['* After the call, the modified sds string is no longer valid and all the', 4]
['parent = task->parent->obj;', 4]
['unsigned int h;', 4]
['if(head==NULL) {', 4]
['"  else return function(...) return; end end\\n"', 4]
['fsub = (full_subscriber_t *)sub;', 4]
['if(head->sub_count == 0) {', 4]
['for(;;) {', 4]
['#include <errno.h>', 4]
['case MSG_EXPECTED:', 4]
['sh = (void*) (s-sizeof *sh);;', 4]
['"  \\n"', 4]
['sub = longpoll_subscriber_create(r, msg_id);', 4]
['int status;', 4]
['else return function(...) return; end end', 4]
['header = part->elts;', 4]
['#include <sys/types.h>', 4]
['if(memstore_slot() != owner) {', 4]
['assert(reply != NULL);', 4]
['bc.chain.buf = &bc.buf;', 4]
['bc.chain.next = NULL;', 4]
['t1 = usec();', 4]
['assert(msg->id.tagcount == 1);', 4]
['}                                                                               \\', 4]
['reset_timer(d);', 4]
['ngx_int_t               rc;', 4]
['reaper_reset_timer(rp);', 4]
['#include <store/redis/store.h>', 4]
['static ngx_int_t empty_callback(){', 4]
['*c = obj.as.s8;', 4]
['*ret_id = NULL;', 4]
['if(d == NULL) {', 4]
['len == 4+4+(3+2)+4+(3+2)+4+(3+2));', 4]
['#include "sds.h"', 4]
['struct ev_loop *loop = e->loop;', 4]
['if (size <= 0xFF)', 4]
['if(global_redis_enabled) {', 4]
['ngx_http_send_header(r);', 4]
['*size = obj.as.ext.size;', 4]
['return {404, nil}', 4]
['return &id;', 4]
['d->reserved = 0;', 4]
['while(he) {', 4]
['enum {', 4]
['id=randid', 4]
['bkt = hashv & (num_bkts-1);                                                    \\', 4]
['#error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !', 4]
["if (*_p != '\\0' && strchr(intfmts,*_p) != NULL) {", 4]
['void connectCallback(const redisAsyncContext *c, int status) {', 4]
['d->sub = sub;', 4]
['replies = malloc(sizeof(redisReply*)*num);', 4]
['msg->buf = buf;', 4]
['redisAsyncDisconnect(c);', 4]
['for (i = 0; i < num; i++) freeReplyObject(replies[i]);', 4]
['if (ctx->write(ctx, &size, sizeof(uint16_t)))', 4]
['#include "longpoll.h"', 4]
["if on then return function(...) redis.call('echo', table.concat({...})); end", 4]
['ensure_request_hold(fsub);', 4]
['t2 = usec();', 4]
['else goto forbidden;', 4]
['parent->element[task->idx] = r;', 4]
['buf->last_in_chain = 1;', 4]
['return nil', 4]
['full_subscriber_t    *fsub;', 4]
['ctx->prev_msg_id = fsub->sub.last_msgid;', 4]
['%s', 4]
['memstore_ready_chanhead_unless_stub(head);', 4]
['"\\0");', 4]
['if(prev) {', 4]
['chanhead_messages_gc(ch);', 4]
['__redisAsyncCopyError(ac);', 4]
['#include <util/nchan_output.h>', 4]
['nchan_store_channel_head_t    *head;', 4]
['return cmp_write_true(ctx);', 4]
['#include "shmem.h"', 4]
['#if (DISABLE_RWLOCK == 1)', 4]
['if(handler != NULL) {', 4]
['ctx->subscriber_type = sub->name;', 4]
['printf("Connected...\\n");', 4]
['va_start(ap,format);', 4]
['accept_header = &r->headers_in.accept->value;', 4]
['redisAsyncSetDisconnectCallback(c,disconnectCallback);', 4]
['while true do', 3]
['nchan_store_channel_head_t  *chead;', 3]
['nchan_loc_conf_t     *lcf = conf;', 3]
['args: 1..7,', 3]
['ngx_http_core_loc_conf_t       *clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);', 3]
['redisAsyncContext *context;', 3]
['if((d=ngx_alloc(sizeof(*d), ngx_cycle->log))==NULL) {', 3]
['i++;', 3]
['current = sdscatlen(current,p,1);', 3]
['if (obj->as.boolean)', 3]
['bc.buf.last = bc.buf.end;', 3]
['bc.buf.last_in_chain = 1;', 3]
['ngx_memzero(&bc.buf, sizeof(ngx_buf_t));', 3]
['case READY:', 3]
['value: "<string>",', 3]
['*i = obj.as.u32;', 3]
['#include "../store/memory/store-private.h"', 3]
['//ignore', 3]
['* Example:', 3]
['case NGX_HTTP_CLOSE: //delete', 3]
['return {418, "", "", "", "", subs_count}', 3]
['test_cond(strncmp(cmd,"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n",len) == 0 &&', 3]
['//init', 3]
['case \'"\':', 3]
['if(sub->reserved > 0) {', 3]
['return NGX_HTTP_INTERNAL_SERVER_ERROR;', 3]
['nchan_output_filter(fsub->sub.request, &bc.chain);', 3]
['b->memory = 1;', 3]
['if (part->next == NULL) {', 3]
['/* Set reply if this is the root object. */', 3]
['msg->dbg_prev = NULL;', 3]
['reader->fn = NULL;', 3]
['//}', 3]
['handle_chanhead_gc_queue(1);', 3]
['head->status = WAITING;', 3]
['fsub->data.finalize_request = 0;', 3]
['for(i=0; i < n; i++) {', 3]
['if(self->destroy_after_dequeue) {', 3]
['fsub->data.finalize_request=1;', 3]
['redisAsyncFree(ac);', 3]
['spool->msg_status = MSG_INVALID;', 3]
['sub->dbg_prev = NULL;', 3]
['#include <ctype.h>', 3]
['b->last_buf = 1;', 3]
['void                   *timeout_handler_data;', 3]
['static void empty_handler(void) {}', 3]
['*status = MSG_NOTFOUND;', 3]
['fsub->sub.last_msgid.tagcount = 1;', 3]
['ngx_str_t       *ch_id;', 3]
['case MSG_FOUND:', 3]
['spool_nextmsg(spool, &msg->id);', 3]
['_EL_ADD_WRITE(ac);', 3]
['"      else\\n"', 3]
['callback_pt                callback;', 3]
['part = part->next;', 3]
['if (h == NULL) {', 3]
['if (!wev->delayed) {', 3]
['fsub->data.cln->handler = empty_handler;', 3]
['return status;', 3]
['psr->data = psrd;', 3]
['ngx_int_t               owner;', 3]
['#!/usr/bin/ruby', 3]
['#undef uthash_free', 3]
['ngx_uint_t                       i;', 3]
['ERR("can\'t allocate memory for publisher auth subrequest");', 3]
['dequeue_maybe(self);', 3]
['case REDIS_REPLY_STATUS:', 3]
['ngx_int_t           rc;', 3]
['NCHAN_ZERO_MSGID,', 3]
['nchan_store_channel_head_t   *head;', 3]
['data.shm_chid = str_shm_copy(chid);', 3]
['case CMP_TYPE_DOUBLE:', 3]
['bc.buf.last_buf = 1;', 3]
['h = dictHashKey(ht, key) & ht->sizemask;', 3]
['extern "C" {', 3]
['test_blocking_connection(cfg);', 3]
['#include <unistd.h>', 3]
['//async-friendly functions with callbacks', 3]
['#include "../store/memory/shmem.h"', 3]
['void *reply = NULL;', 3]
['if((psr_stuff = ngx_palloc(r->pool, sizeof(*psr_stuff))) == NULL) {', 3]
['__redisAsyncFree(ac);', 3]
[':ngx_conf_set_flag_slot,', 3]
['update_subscriber_last_msg_id(self, msg);', 3]
['ngx_rbtree_node_t  *node;', 3]
['for(i=0; i<n; i++) {', 3]
['ngx_rbtree_node_t *cur;', 3]
['d->callback = callback;', 3]
['reply = redisCommand(c,"GET foo");', 3]
['prev->next = next;', 3]
['return buf;', 3]
['ngx_conf_log_error(NGX_LOG_ERR, cf, 0, "invalid %V value: %V", &cmd->name, val);', 3]
['if (ac->ev.data != NULL)', 3]
['e->context = ac;', 3]
['done=1;', 3]
['if (ac == NULL) {', 3]
['ac->ev.data = e;', 3]
['bc[0].chain.next = &bc[1].chain;', 3]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "Failed to allocate memory for some callback data");', 3]
['buf->start = buf->pos;', 3]
['value: "<number>",', 3]
['buf->start = start;', 3]
['assert(d);', 3]
['assert(head->sub_count >= head->internal_sub_count);', 3]
['const struct timeval *timeout,', 3]
['ngx_http_compile_complex_value_t    ccv;', 3]
['sdsfree(r->buf);', 3]
['#include <ngx_http.h>', 3]
['*cur++ = CR; *cur++ = LF;', 3]
['bc[0].buf.end = cur;', 3]
['notready++;', 3]
['static ngx_int_t sub_respond_status(ngx_int_t status, void *ptr, sub_data_t *d) {', 3]
['redisAsyncContext *ac;', 3]
['if (r->err)', 3]
['//disable abort handler', 3]
['//nextsub->ev should be zeroed;', 3]
['fsub->sub.dequeue_after_response = 1;', 3]
['ctx->msg_id = fsub->sub.last_msgid;', 3]
['if(ngx_ncpu > 1) {', 3]
['ngx_http_set_complex_value_slot,', 3]
['NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,', 3]
['#include "../store/memory/ipc.h"', 3]
['/* Create container for context and r/w events */', 3]
['internal_subscriber_set_dequeue_handler(sub, (callback_pt )sub_dequeue);', 3]
['bc[0].buf.last = cur;', 3]
['local id=ARGV[1]', 3]
['if(rp->ready(cur, force) == NGX_OK) {', 3]
['ERR("Unable to allocate");', 3]
['ngx_buf_t              *msg_buf = msg->buf;', 3]
['full_subscriber_t  *fsub = (full_subscriber_t *)sub;', 3]
['"local id=ARGV[1]\\n"', 3]
['void *privdata;', 3]
['sent=[]', 3]
['__redisPushCallback(&ac->replies,&cb);', 3]
['r->headers_out.status = NGX_HTTP_BAD_REQUEST;', 3]
['Redistribution and use in source and binary forms, with or without', 3]
['chunked_ensure_headers_sent(fsub);', 3]
['ret = redisReaderGetReply(reader,NULL);', 3]
['if (!ctx->read(ctx, &ext_type, sizeof(int8_t))) {', 3]
['void                   *dequeue_handler_data;', 3]
['//     redisDisconnect(c);', 3]
['aeStop(loop);', 3]
['DEBUG_MEMZERO(&data);', 3]
['ngx_http_finalize_request(r, 0);', 3]
['buf->last = buf->end;', 3]
['next = thing_next(rp, cur);', 3]
['if (!ctx->read(ctx, &obj->as.u8, sizeof(uint8_t))) {', 3]
['ngx_int_t                    owner = memstore_channel_owner(channel_id);', 3]
['else{', 3]
['ngx_buf_t                      *buf;', 3]
['if(prev) *thing_next_ptr(rp, prev) = next;', 3]
['update_subscriber_last_msg_id(sub, msg);', 3]
['subscriber_callback_pt  timeout_handler;', 3]
['for(i=1; i < cf->args->nelts; i++) {', 3]
['#include <nchan_types.h>', 3]
['fsub->data.shook_hands = 1;', 3]
['ngx_str_t                 *shm_chid;', 3]
['self->reserved++;', 3]
['nchan_loc_conf_t          *cf = ngx_http_get_module_loc_conf(r, nchan_module);', 3]
['# define _DEFAULT_SOURCE\t1', 3]
['sh->len = len;', 3]
['if (s == NULL) return NULL;', 3]
['if(rp->first == NULL) {', 3]
['if(!force) {', 3]
['#include "../store/memory/ipc-handlers.h"', 3]
['ngx_int_t memstore_slot();', 3]
['for(n = 1; n < NGX_RWLOCK_SPIN; n <<= 1) {', 3]
['ngx_uint_t            i;', 3]
['__redisSetError(c,REDIS_ERR_OTHER,buf);', 3]
['1, //destroy after dequeue', 3]
[':ngx_conf_set_num_slot,', 3]
['static void timeout_ev_handler(ngx_event_t *ev) {', 3]
['redisAsyncHandleWrite(e->context);', 3]
['}                                                              \\', 3]
['destroy_spool(spool);', 3]
['fsub->sub.dequeue_after_response=1;', 3]
['if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {', 3]
['max_notready = rp->max_notready_ratio * rp->count;', 3]
['fsub->data.shook_hands = 0;', 3]
['if(fsub->data.shook_hands == 0 && status_code >= 400 && status_code <600) {', 3]
['nchan_cleverly_output_headers_only_for_later_response(r);', 3]
['if(cf->pub.http) {', 3]
['c = r->connection;', 3]
['rdt.connected = 1;', 3]
['if((fsub = ngx_alloc(sizeof(*fsub), ngx_cycle->log)) == NULL) {', 3]
['subscriber_debug_add(&fsub->sub);', 3]
['#define uthash_malloc(sz) ngx_alloc(sz, ngx_cycle->log)', 3]
['nchan_request_ctx_t   *ctx = ngx_http_get_module_ctx(r, nchan_module);', 3]
['nchan_request_ctx_t        *ctx = ngx_http_get_module_ctx(r, nchan_module);', 3]
['NGX_HTTP_MAIN_CONF_OFFSET,', 3]
['reap_ready_thing(rp, cur, next);', 3]
['int j;', 3]
['es_ensure_headers_sent(fsub);', 3]
['nchan_respond_status(r, NGX_HTTP_FORBIDDEN, NULL, 0);', 3]
['static ngx_int_t sub_dequeue(ngx_int_t status, void *ptr, sub_data_t* d) {', 3]
['internal_subscriber_set_enqueue_handler(sub, (callback_pt )sub_enqueue);', 3]
['ngx_free(cur);', 3]
['fsub->sub.request->keepalive=0;', 3]
['case CMP_TYPE_FLOAT:', 3]
['fsub->data.cln->handler = (ngx_http_cleanup_pt )empty_handler;', 3]
['ht->used--;', 3]
['ngx_add_timer(wev, clcf->send_timeout);', 3]
['static ngx_int_t sub_enqueue(ngx_int_t timeout, void *ptr, sub_data_t *d) {', 3]
['DBG("%p output msg to subscriber", sub);', 3]
['d->msg_status = status;', 3]
['spool_collect_overflow_t  *overflow;', 3]
['obj->as.ext.type = ext_type;', 3]
['* After the call, the passed sds string is no longer valid and all the', 3]
['test_cond(ret == REDIS_ERR &&', 3]
['nchan_loc_conf_t               *cf = ngx_http_get_module_loc_conf(r, nchan_module);', 3]
['#define uthash_free(ptr,sz) ngx_free(ptr)', 3]
['spool->msg = NULL;', 3]
['ngx_int_t                       rc;', 3]
['s++;', 3]
['#if EV_MULTIPLICITY', 3]
['SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.', 3]
[':ngx_http_set_complex_value_slot,', 3]
['//     redisCommand(c,"PING");', 3]
['c->flags &= ~REDIS_BLOCK;', 3]
['ngx_event_t             timeout_ev;', 3]
['b->last_in_chain = 1;', 3]
['case NGX_HTTP_GONE: //delete', 3]
['DBG("not ready to reap %s %p", rp->name, cur);', 3]
['case MSG_NOTFOUND:', 3]
['unsigned                awaiting_destruction:1;', 3]
['switch(*p) {', 3]
['#include <limits.h>', 3]
['log_redis_reply(d->name, d->t);', 3]
['sub->enqueued = 1;', 3]
['0, //enqueued', 3]
['if(cur == NULL) {', 3]
['verify_reaper_list(rp, cur);', 3]
['msg->id.tagactive = 0;', 3]
['subscriber_callback_pt  dequeue_handler;', 3]
['internal_subscriber_set_respond_status_handler(sub, (callback_pt )sub_respond_status);', 3]
['cur=getmsg cur', 3]
['fsub->awaiting_destruction = 1;', 3]
['ngx_cpu_pause();', 3]
['char buf[128];', 3]
['DBG("%p create subscriber", sub);', 3]
['return nchan_setup_handler(cf, conf, &nchan_pubsub_handler);', 3]
['next->prev = prev;', 3]
['__redisSetError(c,REDIS_ERR_OOM,"Out of memory");', 3]
['if (head) {                                                                    \\', 3]
['break', 3]
['nchan_http_publisher_handler(r);', 3]
['#include "rbtree_util.h"', 3]
['return DICT_ERR;', 3]
['nchan_buf_and_chain_t  *bc;', 3]
['else return 0;', 3]
['full_subscriber_t      *fsub = (full_subscriber_t  *)sub;', 3]
['val = &((ngx_str_t *) cf->args->elts)[i];', 3]
['*s = obj.as.u16;', 3]
['#include "../spool.h"', 3]
['int8_t ext_type;', 3]
['sr->header_only = 1;', 3]
['if(finalize) {', 3]
['while(cur != NULL) {', 3]
['subscriber_t                 *sub;', 3]
['disconnect(c, 0);', 3]
['return len;', 3]
['proc = &ipc->process[i];', 3]
['#if (DEBUG_NGX_RWLOCK == 1)', 3]
['multipart_ensure_headers_sent(fsub);', 3]
['int                  max_notready, notready = 0;', 3]
['"    return {404, nil}\\n"', 3]
['bc.buf.memory = 1;', 3]
['for(i=0; i< NGX_MAX_PROCESSES; i++) {', 3]
['if (ctx->write(ctx, data, sz))', 3]
['if(rc == NGX_OK) {', 3]
['ngx_sched_yield();', 3]
['if(p == NULL) {', 3]
['goto err;', 3]
['cur=getmsg id, ""', 3]
['#include "net.h"', 3]
['n++;', 3]
['if(status_code >=400 && status_code <599) {', 3]
['ccv.cf = cf;', 3]
['All rights reserved.', 3]
['//http request sudden close cleanup', 3]
['if(sub->type == INTERNAL) {', 3]
['subscriber_t *sub = internal_subscriber_create(&sub_name, d);', 3]
['if(!fsub->data.shook_hands) {', 3]
['#include "uthash.h"', 3]
['ngx_uint_t i, n;', 3]
['internal_subscriber_set_respond_message_handler(sub, (callback_pt )sub_respond_message);', 3]
['d->callback(NGX_OK, NULL, d->privdata);', 3]
['rc = longpoll_enqueue(sub);', 3]
['full_subscriber_t        *fsub = (full_subscriber_t  *)sub;', 3]
['#include "ipc.h"', 3]
['clcf->chunked_transfer_encoding = 0;', 3]
['nchan_respond_status(sub->request, status_code, status_line, 1);', 3]
['self->reserved--;', 3]
['if (i >= part->nelts) {', 3]
['d->cb = callback;', 3]
['msg->id.tagcount = 1;', 3]
['return &fsub->sub;', 3]
['void                   *privdata;', 3]
["//don't care, ignore", 3]
['free(e);', 3]
['//add timeout timer', 3]
['&& CHECK_REPLY_STR(reply->element[1])', 3]
['free(r);', 3]
['nchan_thing_cache_t   *tc = (nchan_thing_cache_t *)tcv;', 3]
['ngx_http_post_subrequest_t    *psr = &psr_stuff->psr;', 3]
['ngx_str_t            *val;', 3]
['bc[0].chain.buf = &bc[0].buf;', 3]
['case REDIS_REPLY_ARRAY:', 3]
['void memstore_fakeprocess_pop();', 3]
['CHANNEL_HASH_FIND(channel_id, head);', 3]
['if(!cmp_read_str_size(cmp, &sz)) {', 3]
['c->flags |= REDIS_CONNECTED;', 3]
['i = 0;', 3]
['for(i = 0; i < MAX_FAKE_WORKERS; i++) {', 3]
['ngx_http_request_t             *r = fsub->sub.request;', 3]
['case REDIS_REPLY_INTEGER:', 3]
['if(next) *thing_prev_ptr(rp, next) = prev;', 3]
['redisAsyncHandleRead(e->context);', 3]
['sub->fn->reserve(sub);', 3]
['#undef uthash_malloc', 3]
['redisEchoCallback(c, r, privdata);', 3]
['nchan_buf_and_chain_t     bc;', 3]
['self->enqueued = 0;', 3]
['"    n=n+1\\n"', 2]
['return shm;', 2]
['(ngx_int_t (*)(void *, uint8_t)) nchan_memstore_store_msg_ready_to_reap,', 2]
['#include <ngx_channel.h>', 2]
['uint32_t str_size = 0;', 2]
['id->data = (u_char *)&id[1];', 2]
['return value;', 2]
['NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3|NGX_CONF_TAKE4|NGX_CONF_TAKE5,', 2]
['h[k]=v; k=nil', 2]
['typedef struct sub_data_s sub_data_t;', 2]
['if (p->events) {', 2]
['b[0] = b[3];', 2]
['if (newargv == NULL) goto err;', 2]
['if (r->fn && r->fn->createString)', 2]
['//update_subscriber_last_msg_id(d->sub, msg);', 2]
['oldkey=old_fmt:format(old)', 2]
['* This file implements in memory hash tables with insert/del/replace/find/', 2]
['proc->c=c;', 2]
['len = redisvFormatCommand(&cmd,format,ap);', 2]
['if k == nil then', 2]
['nchan_msg_t               *msg;', 2]
['channel_spooler_t      *spl = spool->spooler;', 2]
['return cmp_write_ext8_marker(ctx, obj->as.ext.type, obj->as.ext.size);', 2]
['ngx_memcpy(msgidbuf, msgid->data, msgid->len);', 2]
['"      break\\n"', 2]
['if (rc == NGX_ERROR) {', 2]
['"        redis.call(\'rpop\', list_key)\\n"', 2]
['curargv = newargv;', 2]
['//input: keys: [], values: [channel_id, subscriber_id, channel_empty_ttl, active_ttl, concurrency]', 2]
['touched = 1;', 2]
['return cmp_write_fixstr_marker(ctx, size);', 2]
['nchan_subscriber_directive,', 2]
['free(buf);', 2]
['modification, are permitted provided that the following conditions are met:', 2]
['static u_char        msgidbuf[100];', 2]
['if((id = ngx_palloc(r->pool, sizeof(*id) + sz)) == NULL) {', 2]
['test_cond(c->err == REDIS_ERR_IO);', 2]
['if (size <= FIXARRAY_SIZE)', 2]
['if (sz == 2)', 2]
['msgid.tag.fixed[0] = msgtag;', 2]
['else if(rdt.sub_ctx == ac) {', 2]
["cmd[pos++] = '\\r';", 2]
['head->internal_sub_count++;', 2]
['nchan_msg_t             msg;', 2]
['nchan_set_pub_channel_id,', 2]
['len == 4+4+(3+2)+4+(3+2)+4+(0+2));', 2]
["redis.call('echo', table.concat(arg))", 2]
['ch.last_published_msg_id.tagcount = 1;', 2]
['if ex==1 then', 2]
['pos = sprintf(cmd,"*%d\\r\\n",argc);', 2]
['head->spooler.fn->set_add_handler(&head->spooler, spooler_add_handler, head);', 2]
['if(ch->channel.messages > 0) {', 2]
['ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));', 2]
['r->headers_out.status=status_code;', 2]
['int blocking = (c->flags & REDIS_BLOCK);', 2]
['free(ht->table);', 2]
['static ngx_int_t nchan_store_init_worker(ngx_cycle_t *cycle) {', 2]
['data.callback = callback;', 2]
['callback(NGX_OK, NULL, privdata);', 2]
['uv_poll_stop(&p->handle);', 2]
['ngx_free(ch);', 2]
['free(curargv);', 2]
['subt->http_multipart=1;', 2]
['&nchan_store_exit_master,', 2]
['return cmp_write_nil(ctx);', 2]
['//other stuff', 2]
['hashv = 0;                                                                     \\', 2]
['subt->websocket=1;', 2]
['if(cmp_to_str(&cmp, &msg_redis_hash_key)) {', 2]
['static ngx_file_t       file_copy;', 2]
['* Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>', 2]
['sh->free = 0;', 2]
['if ((context != NULL) && (*context != NULL)) {', 2]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "shpool alloc addr %p size %ui label %s", p, size, label == NULL ? "none" : label);', 2]
['//     /* Shift to detect execution order */', 2]
['assert(NULL);', 2]
['DBG("not ready to reap %V, %i subs left", &ch->id, ch->sub_count);', 2]
["old=redis.call('lindex', list_key, -1)", 2]
['*i = obj.as.u16;', 2]
['nchan_llist_timed_t   *next;', 2]
['if(fail) {', 2]
['c->flags |= REDIS_DISCONNECTING;', 2]
['msg.time,', 2]
['if(sr->upstream) {', 2]
["subscriber_id='channel:next_subscriber_id:'..id, --integer", 2]
['--output: channel_hash {ttl, time_last_seen, subscribers, messages} or nil', 2]
['subscriber_debug_remove(sub);', 2]
['if (!(c->flags & REDIS_CONNECTED)) {', 2]
['freeReplyObject(redisCommand(c,"LPUSH mylist foo"));', 2]
['//shutdown', 2]
['redisReader *redisReaderCreate(void);', 2]
['b[2] = b[5];', 2]
['nchan_loc_conf_t      *cf = fsub->sub.cf;', 2]
['ngx_memzero(&bc[0].buf, sizeof(ngx_buf_t));', 2]
['else if(nchan_strmatch(val, WEBSOCKET_STRINGS_N, WEBSOCKET_STRINGS)) {', 2]
['if(!proc->active) continue;', 2]
['head->last_msgid.tagactive = 0;', 2]
['case NGX_HTTP_DELETE:', 2]
['ngx_memcpy(head->id.data, channel_id->data, channel_id->len);', 2]
['if(!cmp_read_uinteger(&cmp, &msgtag)) {', 2]
['len = redisFormatCommandArgv(&cmd,argc,argv,argvlen);', 2]
['(head)->hh.tbl->hho)) : NULL);                     \\', 2]
['nchan_store_subscribe_continued(d);', 2]
["//  'concurrency' can be 'FIFO', 'FILO', or 'broadcast'", 2]
['fcur++;', 2]
['ngx_list_part_t                 *part = &r->headers_in.headers.part;', 2]
['void redisFree(redisContext *c);', 2]
['va_end(_cpy);', 2]
['else { //anything else means forbidden', 2]
['s = be16(s);', 2]
['} else {                                                       \\', 2]
['ngx_str_t                   *shm_chid;', 2]
['n=n+1', 2]
['longpoll_subscriber_destroy(self);', 2]
['"if redis.call(\'EXISTS\', key_channel) ~= 0 then\\n"', 2]
['fsub->owner = memstore_slot();', 2]
['return cmp_write_pfix(ctx, obj->as.u8);', 2]
['arg = va_arg(ap,char*);', 2]
['@echo ""', 2]
['return', 2]
['len = argvlen ? argvlen[j] : strlen(argv[j]);', 2]
['if(r->headers_in.accept) {', 2]
['if(head->id.len >= 5 && ngx_strncmp(head->id.data, "meta/", 5) == 0) {', 2]
['msg->prev_id.tagcount = 1;', 2]
['group: "obsolete"', 2]
['end; else', 2]
['furnished to do so, subject to the following conditions:', 2]
['ngx_event_t                   timeout_ev;', 2]
['urnode->smallmsg.len = msglen;', 2]
['case NCHAN_MESSAGE_RECEIVED:', 2]
['local h = {}', 2]
['"--output: channel_hash {ttl, time_last_seen, subscribers, messages} or nil\\n"', 2]
['return cmp_write_bin8_marker(ctx, obj->as.bin_size);', 2]
['assert(d->shm_chid->data!=NULL);', 2]
['int flags;', 2]
['EOS', 2]
['static ngx_int_t nchan_store_init_module(ngx_cycle_t *cycle) {', 2]
['subscriber_pool_t         *spool;', 2]
['if(callback==NULL) {', 2]
['offsetof(nchan_loc_conf_t, subscriber_timeout),', 2]
['redis_nginx_open_context(rdt.connect_params->host, rdt.connect_params->port, rdt.connect_params->db, rdt.connect_params->password, &c);', 2]
['* nothing at all. */', 2]
['if (sz <= 0xFFFF)', 2]
['//message stuff', 2]
['sub->fn->enqueue(sub);', 2]
['time_t                          expires;', 2]
['ifeq ($(uname_S),SunOS)', 2]
['local oldestmsg=function(list_key, old_fmt)', 2]
['if(cur == last) {', 2]
['return &header[i].value;', 2]
["messages =    'channel:messages:'..id,", 2]
['id->len = sz;', 2]
['/* SDS (Simple Dynamic Strings), A C dynamic strings library.', 2]
['curarg = newarg;', 2]
['subscribe_data_t            *d;', 2]
['} store_redis_lua_scripts_t;', 2]
['if (sz == 4)', 2]
['"  messages =    \'channel:messages:\'..id,\\n"', 2]
['d->allocd = 1;', 2]
['dictEntry *he;', 2]
['Permission is hereby granted, free of charge, to any person obtaining a copy', 2]
['*size = str_size;', 2]
['_hs_psize--;                                               \\', 2]
['b[2] = swap;', 2]
['if(seed->actives[i] == node) {', 2]
['if (_hs_p){                                                \\', 2]
['ngx_int_t        rc;', 2]
['thing_t               *thing;', 2]
['if (frame->mask) {', 2]
['int len = sdslen(s), j;', 2]
['r->len = sdslen(r->buf);', 2]
['reply->elements == 2 &&', 2]
['case NGX_HTTP_OK:', 2]
['head->last_msgid.tagcount = 1;', 2]
['return cmp_write_str16_marker(ctx, size);', 2]
['sub->fn->subscribe(sub, channel_id);', 2]
['local key={', 2]
['redisEchoCallback(c,reply,privdata);', 2]
['#include "cmp.h"', 2]
['ngx_buf_t     *hdr_buf = &fsub->hdr_buf;', 2]
['if (!ctx->read(ctx, data, bin_size)) {', 2]
['bc[2].chain.buf = &bc[2].buf;', 2]
['The MIT License (MIT)', 2]
['i = be32(i);', 2]
['struct sdshdr *sh = (void*)(s-sizeof *sh);', 2]
['if (sz <= 0xFF)', 2]
['group: "meta",', 2]
['sds newbuf;', 2]
['msg->id.time = ngx_time();', 2]
['return cmp_write_map32(ctx, obj->as.map_size);', 2]
['"  redis.call(\'LPUSH\', key.messages, msg.id)\\n"', 2]
['offsetof(nchan_loc_conf_t, max_channel_subscribers),', 2]
['local old, oldkey', 2]
['ctx->prev_msg_id = ctx->msg_id;', 2]
['struct sub_data_s {', 2]
['fsub->awaiting_destruction = 0;', 2]
['*s = obj->as.u16;', 2]
['#include <store/memory/store.h>', 2]
['char c;', 2]
['rc = nchan_output_filter(fsub->sub.request, &bc[0].chain);', 2]
['rbtree_conditional_walk_real(seed, node->left, sentinel, callback, data);', 2]
['"      if ex==1 then\\n"', 2]
['if (redisContextWaitReady(c,timeout) != REDIS_OK)', 2]
['head->spooler.running=0;', 2]
['#ifdef NO_DECLTYPE', 2]
['return h', 2]
['reply = redisCommand(c,"LRANGE mylist 0 -1");', 2]
['else if(CHECK_REPLY_ARRAY_MIN_SIZE(reply, 3)', 2]
['if(tc->thing_tail) {', 2]
['c->fd = s;', 2]
['if (c->flags & REDIS_FREEING) {', 2]
['if(head != NULL) {', 2]
['rbtree_destroy_node(seed, node);', 2]
['boundary[i].end = &char_boundary_last[-4];', 2]
['enqueue_llist_thing(tc, cur);', 2]
['return n;', 2]
['rsv->prev = NULL;', 2]
['if (__redisAsyncHandleConnect(ac) != REDIS_OK)', 2]
['memstore_fakeprocess_push_random();', 2]
['redisAsyncContext *ac = *context;', 2]
['_hs_p = (UT_hash_handle*)((_hs_p->next) ?                \\', 2]
['if(msg->id.tagcount > NCHAN_FIXED_MULTITAG_MAX) {', 2]
['msg.id.time = tv.tv_sec;', 2]
['#include <nchan_websocket_publisher.h>', 2]
['local k=nil', 2]
['DBG("%p not ready to destroy (reserved for %i) for req %p", sub, sub->reserved, fsub->sub.request);', 2]
['case NGX_HTTP_NOT_MODIFIED:', 2]
['_count = 0;                                                              \\', 2]
['return cmp_write_s8(ctx, obj->as.s8);', 2]
['frame->last = NULL;', 2]
['assert(spool->id.tag.allocd != msg->id.tag.allocd);', 2]
['### Connecting', 2]
['data.privdata = privdata;', 2]
['unsigned                shook_hands:1;', 2]
['test("Format command with printf-delegation (" #type "): ");                          \\', 2]
['if(p != NULL) {', 2]
['if (sz == 8)', 2]
['}                                                         \\', 2]
['l = be64(l);', 2]
['chanhead_delete_message(ch, cur);', 2]
['verify_reaper_list(rp, thing);', 2]
['ret = last;', 2]
['printf("Connection error: %s\\n", c->errstr);', 2]
['rbtree_conditional_walk_real(seed, node->right, sentinel, callback, data);', 2]
['websocket_send_frame(fsub, WEBSOCKET_CLOSE_LAST_FRAME_BYTE, 0);', 2]
['head->status = NOTREADY;', 2]
['static void sudden_abort_handler(subscriber_t *sub) {', 2]
['ngx_del_timer(&f->timeout_ev);', 2]
['if(sub->cf->subscribe_only_existing_channel) {', 2]
['redisCallback cb;', 2]
['memstore_sub_debug_start();', 2]
['case CMP_TYPE_BOOLEAN:', 2]
['if((shmsg_link = create_shared_message(msg, msg_in_shm)) == NULL) {', 2]
['DBG("%p created for request %p", &fsub->sub, r);', 2]
['head->spooler.fn->respond_status(&head->spooler, status_code, status_line);', 2]
['"if key.last_message then\\n"', 2]
['self->fn->dequeue(self);', 2]
['bc[2].buf.last_buf = 0;', 2]
['spool_respond_general(spool, spool->msg, 0, NULL);', 2]
['b[4] = swap;', 2]
['k=v', 2]
['return h;', 2]
['group: "development",', 2]
['} nchan_pub_upstream_data_t;', 2]
['//super-heavy debugging', 2]
['head->meta = 0;', 2]
['"end",', 2]
['proc->wbuf.overflow_last = NULL;', 2]
['if (context != NULL) {', 2]
['ctx->subscriber_type = fsub->sub.name;', 2]
['internal_subscriber_t  *fsub = (internal_subscriber_t  *)d->sub;', 2]
['printf("Connection error: can\'t allocate redis context\\n");', 2]
['if(renew) {', 2]
['msgid.tagcount = 1;', 2]
['err = ngx_errno;', 2]
['cur += 3;', 2]
['#define REQUEST_PALLOC(r, what) what = ngx_palloc((r)->pool, sizeof(*(what)))', 2]
['sub->dbg_next = NULL;', 2]
['buf->flush = 1;', 2]
['DBG("create for req %p", r);', 2]
['want[i]=1;', 2]
['static ngx_int_t sub_notify_handler(ngx_int_t code, void *data, sub_data_t *d) {', 2]
['if(rdt.ctx && rdt.sub_ctx) {', 2]
['"      k=v\\n"', 2]
['if (s != NULL) {', 2]
['ipc_try_close_fd(&socks[0]);', 2]
['if (obj.as.boolean)', 2]
['_mur_k1 = MUR_ROTL32(_mur_k1,15);                                  \\', 2]
['sh = (void*) (x-(sizeof(struct sdshdr)));', 2]
['nchan_store_messages_directive,', 2]
['swap = b[2];', 2]
['//ngx_memzero(&fake_conf, sizeof(fake_conf));', 2]
['ac = redisAsyncInitialize(c);', 2]
['b[3] = b[4];', 2]
['ngx_buf_t *nchan_channel_info_buf(ngx_str_t *accept_header, ngx_uint_t messages, ngx_uint_t subscribers, time_t last_seen, nchan_msg_id_t *last_msgid, ngx_str_t **generated_content_type);', 2]
['nchan_store_channel_head_t     *head = NULL;', 2]
['_hs_qsize--;                                               \\', 2]
['case NGX_HTTP_PUT:', 2]
['local tohash=function(arr)', 2]
['dictReleaseIterator(it);', 2]
['content_length = sr->upstream->headers_in.content_length_n > 0 ? sr->upstream->headers_in.content_length_n : 0;', 2]
['if(msg_id) {', 2]
['if(self->dequeue_after_response) {', 2]
['assert(pos == totlen);', 2]
['if (n == NGX_AGAIN) {', 2]
['#if (NGX_DEBUG_POOL)', 2]
['if (e->writing) {', 2]
['*target = cmd;', 2]
['"    msg.time,\\n"', 2]
['pubt->http=1;', 2]
['local keys = {', 2]
['reply = redisCommand(c,"SELECT 9");', 2]
['@@scripts.each do |name, script|', 2]
['static ngx_int_t nchan_store_delete_channel(ngx_str_t *channel_id, callback_pt callback, void *privdata) {', 2]
['case NGX_HTTP_CREATED:', 2]
['"local tohash=function(arr)\\n"', 2]
['"    tonumber(msg.tag) or 0,\\n"', 2]
['THE SOFTWARE.', 2]
['/* Hash table implementation.', 2]
['internal_subscriber_t   *fsub = (internal_subscriber_t *)self;', 2]
['msgtag_str.data = (u_char *)msgtag_str_buf;', 2]
['IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,', 2]
['int fd;', 2]
['// handle error', 2]
['fake_conf.use_redis = d->use_redis;', 2]
['int index;', 2]
['status = __redisAsyncCommand(ac,fn,privdata,cmd,len);', 2]
['if(rdt.ctx == ac) {', 2]
['assert(spool->msg == NULL);', 2]
['/* Return early when this reader is in an erroneous state. */', 2]
['assert(spool != newspool);', 2]
['assert(CHANHEAD_SHARED_OKAY(head));', 2]
['msgid.tagactive = 0;', 2]
['r->ridx--;', 2]
['return cur;', 2]
['offsetof(nchan_loc_conf_t, channel_timeout),', 2]
['websocket_respond_status(&fsub->sub, NGX_HTTP_INTERNAL_SERVER_ERROR, NULL);', 2]
['head->id.len = channel_id->len;', 2]
['//no good', 2]
['}                                                                          \\', 2]
['if(cb != NULL) {', 2]
['head->oldest_msgid.time = 0;', 2]
['nchan_pub_upstream_data_t  *d = (nchan_pub_upstream_data_t *)data;', 2]
['"    if k == nil then\\n"', 2]
['b->flush = 1;', 2]
['return cmp_write_u8(ctx, obj->as.u8);', 2]
['internal_subscriber_t  *fsub = (internal_subscriber_t  *)self;', 2]
['return out;', 2]
['static ngx_int_t start_chanhead_spooler(nchan_store_channel_head_t *head) {', 2]
['ctx->sub = NULL;', 2]
['cur->shutting_down = 1;', 2]
['break;                                                               \\', 2]
['nextHe = he->next;', 2]
['if(r->headers_in.accept == NULL) {', 2]
['/* Extracted from anet.c to work properly with Hiredis error reporting.', 2]
['_p += 1;', 2]
['event_del(&e->rev);', 2]
['if(ngx_rwlock_write_check(lock))', 2]
['ngx_http_request_t         *r = sr->parent;', 2]
['remove_spool(spool);', 2]
['ngx_buf_t     *msg_buf = &fsub->msg_buf;', 2]
['params->host = cur_out;', 2]
['nchan_free_msg_id(&fsub->sub.last_msgid);', 2]
['//status strings', 2]
['if (elements > 0) {', 2]
['*c = obj->as.s8;', 2]
['ngx_str_t       *accept_header;', 2]
['next->dbg_prev = prev;', 2]
['&sub_name,', 2]
['return oldkey', 2]
['if (throughput) test_throughput(cfg);', 2]
['spool_respond_general(spool, msg, 0, NULL);', 2]
['global_redis_enabled = 1;', 2]
["cmd[pos] = '\\0';", 2]
['subt->eventsource=1;', 2]
['head->sub_count++;', 2]
['head->id.data = (u_char *)&head[1];', 2]
['static ngx_int_t redis_subscriber_register(nchan_store_channel_head_t *chanhead, subscriber_t *sub);', 2]
['_hs_e = _hs_q;                                             \\', 2]
['nchan_msg_id_t             last_msgid;', 2]
['psrd->ch_id = channel_id;', 2]
['etag->data = (u_char *)(etag+1);', 2]
['return cmp_write_str32(ctx, data, size);', 2]
['ctx->prev_msg_id = self->last_msgid;', 2]
['proc->wbuf.n = 0;', 2]
['return cmp_write_fixstr(ctx, data, size);', 2]
['NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS', 2]
['for i, v in ipairs(arr) do', 2]
['goto forbidden;', 2]
['/* Try again later */', 2]
['return ensure_last_buf(pool, chain->buf);', 2]
['d->sub->fn->release(d->sub, 1);', 2]
['"    return nil\\n"', 2]
['value: [:on, :off],', 2]
['test_cond(strncmp(cmd,"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$0\\r\\n\\r\\n",len) == 0 &&', 2]
['head->multi_waiting = 0;', 2]
['if (ac->err) {', 2]
['--output: subscriber_id, num_current_subscribers', 2]
['case NOTREADY:', 2]
['if (p != NULL) {', 2]
['bc[0].buf.memory = 1;', 2]
['static void spooler_add_handler(channel_spooler_t *spl, subscriber_t *sub, void *privdata) {', 2]
['"  end; else\\n"', 2]
['DBG("%p destroy for req %p", sub, fsub->sub.request);', 2]
['if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {', 2]
['} else if (!*p) {', 2]
['ngx_free(msg);', 2]
['size_t len = 0;', 2]
['subscriber_t                *sub;', 2]
['ngx_connection_t *connection = (ngx_connection_t *) ev->data;', 2]
['"if on then\\n"', 2]
['#include <nchan_defs.h>', 2]
['redisLibuvEvents* p = (redisLibuvEvents*)handle->data;', 2]
['if (*(p+1) && !isspace(*(p+1))) goto err;', 2]
['return cmp_write_float(ctx, obj->as.flt);', 2]
['bc->chain.buf = &bc->buf;', 2]
['d->channel_owner = owner;', 2]
['"  for i, v in ipairs(arr) do\\n"', 2]
['ngx_str_t                   *channel_id;', 2]
["cur[0]='/';", 2]
['#ifdef HASH_BLOOM', 2]
['//     __test_callback_flags <<= 8;', 2]
['for(i = 0; i < max; i++) {', 2]
['key.last_message=nil', 2]
['if (*(char *)&num == 42) {', 2]
['ngx_int_t                 content_length;', 2]
['ngx_str_t           *msgid;', 2]
['nchan_store_multi_t          *multi;', 2]
['b[1] = b[2];', 2]
['nchan_channel_t       *ch = rptr;', 2]
['&nchan_store_publish_message, //+callback', 2]
['return cmp_write_double(ctx, obj->as.dbl);', 2]
['LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING', 2]
['return RBTREE_WALK_LEFT;', 2]
['static ngx_str_t str;', 2]
['*argc = 0;', 2]
['for(i = memstore_procslot_offset; i < memstore_procslot_offset + shdata->old_max_workers; i++) {', 2]
['_mur_k1 *= _mur_c1;                                                \\', 2]
['((void)revents);', 2]
['event_del(&e->wev);', 2]
['return function(...) return; end', 2]
['full_subscriber_t  *fsub = (full_subscriber_t  *)sub;', 2]
['msg->rsv = rsv;', 2]
['offsetof(nchan_loc_conf_t, buffer_timeout),', 2]
['nchan_set_sub_channel_id,', 2]
['if(node == sentinel || node == NULL) {', 2]
['* Copyright (c) 2006-2011, Salvatore Sanfilippo <antirez at gmail dot com>', 2]
['ngx_memcpy(cur_out, cur, ret-cur);', 2]
['return write_fixed_value(ctx, c);', 2]
['notice, this list of conditions and the following disclaimer.', 2]
['test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);', 2]
['void redis_nginx_ping_callback(redisAsyncContext *ac, void *rep, void *privdata);', 2]
['free(tokens);', 2]
['if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {', 2]
['assert(d->shm_chid->len>1);', 2]
['"  local k=nil\\n"', 2]
['ngx_add_timer(&tc->gc_timer, tc->ttl * 1000);', 2]
["//remove from gc list if we're there", 2]
['e->writing = 1;', 2]
['head->latest_msgid.time = 0;', 2]
['static ngx_int_t nchan_store_find_channel(ngx_str_t *channel_id, callback_pt callback, void *privdata) {', 2]
['--now publish to the efficient channel', 2]
['"local key={\\n"', 2]
['assert(memstore_slot() == memstore_channel_owner(d->shm_chid));', 2]
['ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "nchan: can\'t allocate space for legacy channel id");', 2]
['copies of the Software, and to permit persons to whom the Software is', 2]
['redis_nginx_force_close_context(&ctx);', 2]
['wev = c->write;', 2]
['if(r->method != NGX_HTTP_GET) {', 2]
['unpacked= {', 2]
['char *cmd = NULL; /* final command */', 2]
['printf("INCR counter: %lld\\n", reply->integer);', 2]
['ngx_str_t              *channel_id;', 2]
["if((ret = ngx_strlchr(cur, last, '/')) == NULL) {", 2]
['if ((reply == NULL) || (reply->type == REDIS_REPLY_ERROR)) {', 2]
['return cmp_write_fixext4_marker(ctx, obj->as.ext.type);', 2]
['return cmp_write_fixext2_marker(ctx, obj->as.ext.type);', 2]
['return __redisBlockForReply(c);', 2]
['static ngx_int_t keepalive_reply_handler(ngx_int_t renew, void *_, void* pd) {', 2]
['return &msgtag_str;', 2]
['fsub->timeout_ev.cancelable = 1;', 2]
['#include <stdarg.h>', 2]
['full_subscriber_t *fsub = (full_subscriber_t *)ev->data;', 2]
['__redisSetError(c,REDIS_ERR_IO,NULL);', 2]
['uint64_t              msgtag;', 2]
['redisContextConnectUnix(c,path,NULL);', 2]
['nchan_store_channel_head_t *head;', 2]
['ngx_free(p);', 2]
['cur = id->data;', 2]
['* is unsupported by MessagePack v4, the version implemented by many other', 2]
['ngx_free(data);', 2]
['if (n == -1) {', 2]
['return cmp_write_s32(ctx, obj->as.s32);', 2]
['c->fd = -1;', 2]
['callback = empty_callback;', 2]
['mcf->shm_size=NGX_CONF_UNSET_SIZE;', 2]
['temp_pool = NULL;', 2]
['ngx_chain_t   *hdr_chain = &fsub->hdr_chain;', 2]
['return nchan_respond_string(r, status_code, content_type, &str, finalize);', 2]
['if (r->fn && r->fn->createNil)', 2]
['fsub->sub.enqueued = 0;', 2]
['if(!authorize_request_url_ccv) {', 2]
['static store_redis_lua_scripts_t store_rds_lua_hashes = {', 2]
['case CMP_TYPE_NIL:', 2]
['return cmp_write_fixext1_marker(ctx, obj->as.ext.type);', 2]
['websocket_subscriber_destroy(self);', 2]
['d->renew = 1;', 2]
["// 'subscriber_id' is an existing id", 2]
['assert_equal false, cur', 2]
['if(head->meta) {', 2]
['internal_subscriber_set_notify_handler(sub, (callback_pt )sub_notify_handler);', 2]
['&nchan_store_subscribe, //+callback', 2]
['if((overflow = ngx_alloc(sizeof(*overflow), ngx_cycle->log)) == NULL) {', 2]
['if (buf->file!=NULL) {', 2]
['sds sname;', 2]
['cf.use_redis = d->use_redis;', 2]
['create_dataline_bufchain(pool, &first_link, &last_link, &databuf);', 2]
['ngx_uint_t                  responded_count;', 2]
['nchan_llist_timed_t    *cur, *next;', 2]
['r->reply = NULL;', 2]
['ngx_http_post_subrequest_t    psr;', 2]
['HASH_ITER(hh, rdt.subhash, cur, tmp) {', 2]
['request_chain = NULL;', 2]
['arg[i]=tostring(arg[i])', 2]
['offsetof(store_message_t, prev),', 2]
['int main(int argc, char **argv) {', 2]
['"    return function(...)\\n"', 2]
['case NGX_HTTP_ACCEPTED:', 2]
["cmd[pos++] = '\\n';", 2]
['__redisRunCallback(ac,dictGetEntryVal(de),NULL);', 2]
['unsigned                finalize_request:1;', 2]
['//     ((void)c);', 2]
['err:', 2]
['validate_chanhead_messages(ch);', 2]
['ctx->msg_id = ch != NULL ? ch->last_published_msg_id : empty_msgid;', 2]
['//init redis', 2]
['"  subscriber_id=\'channel:next_subscriber_id:\'..id, --integer\\n"', 2]
['fsub->sub.request = r;', 2]
['if(nodestroy == 0 && fsub->awaiting_destruction == 1 && self->reserved == 0) {', 2]
['return hdr_chain;', 2]
['nchan_free_msg_id(&data->msgid);', 2]
['len++;', 2]
['if(file->fd==NGX_INVALID_FILE) {', 2]
['if(memstore_slot() == owner) {', 2]
['if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)', 2]
['typedef struct nchan_store_channel_head_s nchan_store_channel_head_t;', 2]
['static void nchan_store_exit_master(ngx_cycle_t *cycle) {', 2]
['static void spooler_bulk_post_subscribe_handler(channel_spooler_t *spl, int n, void *d) {', 2]
['msg->prev_id.tagactive = 0;', 2]
['head->multi_count = 0;', 2]
['free(cmd);                                                                            \\', 2]
['if(!cmp_read_uinteger(&cmp, (uint64_t *)&msgid.time)) {', 2]
['e->reading = 0;', 2]
['&nchan_store_init_module,', 2]
['head->spooler.publish_events = 0;', 2]
['if (!e->writing) {', 2]
['ngx_http_finalize_request(r, r->headers_out.status ? NGX_OK : NGX_HTTP_INTERNAL_SERVER_ERROR);', 2]
['if (r->ridx == 0) r->reply = obj;', 2]
['prev = thing_prev(rp, cur);', 2]
['void *data;', 2]
['e->loop = loop;', 2]
['test_cond(reply->type == REDIS_REPLY_STRING &&', 2]
['THING_HASH_DEL(tc, (thing_t *)cur->data);', 2]
['msg->expires = ngx_time() + ttl;', 2]
['The length of this string can be accessed using `reply->len`.', 2]
['if ttl > 0 then', 2]
['b[5] = swap;', 2]
['assert(head->status == READY || head->status == STUBBED);', 2]
['dictSetHashVal(ht, entry, val);', 2]
['boundary[i].start = &char_boundary[0];', 2]
['head->status = READY;', 2]
['redisReaderFeed(reader,(char*)"@foo\\r\\n",6);', 2]
['sdsfree(c->obuf);', 2]
['ngx_fd_t    fd;', 2]
['ctx->error = BIN_DATA_LENGTH_TOO_LONG_ERROR;', 2]
['head->shutting_down = 0;', 2]
['void *reply;', 2]
['subscriber_t           *sub;', 2]
['test_cond(reply->type == REDIS_REPLY_ARRAY &&', 2]
['return cmp_write_str16(ctx, data, size);', 2]
['return cmp_write_map16(ctx, obj->as.map_size);', 2]
['success = 1;', 2]
['//bubble on up, yeah', 2]
['nchan_publisher_directive,', 2]
['self->enqueued = 1;', 2]
['pubt->websocket=1;', 2]
['"  return function(...)\\n"', 2]
['if (r->ridx == -1) {', 2]
['ccv.value = value;', 2]
['static ngx_int_t chanhead_messages_delete(nchan_store_channel_head_t *ch);', 2]
['he = nextHe;', 2]
['case MSG_EXPIRED:', 2]
['/* This is ok. */', 2]
['e->reading = e->writing = 0;', 2]
['memstore_fakeprocess_push(fsub->owner);', 2]
['/**', 2]
['//     __test_callback_flags |= (long)privdata;', 2]
['h = ngx_list_push(&r->headers_in.headers);', 2]
['ensure_handshake(fsub);', 2]
['"  local old, oldkey\\n"', 2]
['assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);', 2]
['r->headers_out.status=NGX_HTTP_NO_CONTENT; //fake it to fool the chunking module (mostly);', 2]
['*i = obj->as.u16;', 2]
['memstore_sub_debug_end();', 2]
['//     }', 2]
['ccv.complex_value = *cv;', 2]
['he = he->next;', 2]
['*cv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));', 2]
['* references must be substituted with the new pointer returned by the call.', 2]
['return RBTREE_WALK_RIGHT;', 2]
['len = strlen(str);', 2]
['return cmp_write_fixmap(ctx, obj->as.map_size);', 2]
['del=del+1', 2]
['if on then return function(...)', 2]
['b[0] = b[7];', 2]
['_hs_e = _hs_p;                                             \\', 2]
['for i,v in pairs(keys) do', 2]
['if type(arr)~="table" then', 2]
['nchan_pub_upstream_data_t   psr_data;', 2]
['//     redisSetDisconnectCallback(c,__test_callback,(void*)2);', 2]
['return t;', 2]
['if (c->err)', 2]
['switch(code) {', 2]
['void         *p;', 2]
['} nchan_pub_upstream_stuff_t;', 2]
['memstore_fakeprocess_push(fsub->data.owner);', 2]
['next->dbg_prev = NULL;', 2]
['assert(ch->msg_first != NULL);', 2]
['if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {', 2]
['sub_data_t *d = (sub_data_t *)pd;', 2]
['#define NCHAN_DEFAULT_CHANHEAD_CLEANUP_INTERVAL 1000', 2]
['sds join = sdsempty();', 2]
['int num = 42;', 2]
['if(n_out < NCHAN_MULTITAG_REQUEST_CTX_MAX) {', 2]
['else \\', 2]
['cmd = malloc(totlen+1);', 2]
['* Writes the string marker to the backend.  This is useful if you are writing', 2]
['return cmp_write_s16(ctx, obj->as.s16);', 2]
['ngx_memzero(&msg, sizeof(msg));', 2]
['return cmp_write_array32(ctx, obj->as.array_size);', 2]
['r->fn->freeObject(r->reply);', 2]
['static ngx_int_t nchan_store_publish_message(ngx_str_t *channel_id, nchan_msg_t *msg, nchan_loc_conf_t *cf, callback_pt callback, void *privdata) {', 2]
['if (c >= -32 && c <= -1)', 2]
['ngx_str_t str;', 2]
['if (obj.type != CMP_TYPE_BOOLEAN) {', 2]
['return cmp_write_pfix(ctx, c);', 2]
['if(content_type) {', 2]
['FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE', 2]
['return cmp_write_fixext16_marker(ctx, obj->as.ext.type);', 2]
['_h ^= _h >> 16;    \\', 2]
['head = chanhead_memstore_create(channel_id, cf);', 2]
['* to get a pipeline of commands. */', 2]
['c++;', 2]
['if(is_multi_id(id)) {', 2]
['#include <stdbool.h>', 2]
["local ex=redis.call('exists', oldkey)", 2]
['local id = ARGV[1]', 2]
['local setkeyttl=function(ttl)', 2]
['if (j != argc-1) join = sdscatlen(join,sep,seplen);', 2]
['fsub->sub.cf = ngx_http_get_module_loc_conf(r, nchan_module);', 2]
['if(ngx_buf_in_memory(buf)) {', 2]
['if(!cf->msg_in_etag_only) {', 2]
['full_subscriber_t   *fsub = (full_subscriber_t  *)sub;', 2]
['c->reader->fn->freeObject(reply);', 2]
['AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER', 2]
['return cmp_write_nfix(ctx, obj->as.s8);', 2]
["case '\\\\':", 2]
['nchan_main_conf_t     *conf = ngx_http_conf_get_module_main_conf(cf, nchan_module);', 2]
['_EL_ADD_READ(ac);', 2]
['#include "store.h"', 2]
['void redisAsyncDisconnect(redisAsyncContext *ac);', 2]
['ngx_table_elt_t                 *header= part->elts;', 2]
['LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,', 2]
['*b = false;', 2]
['newarg = sdscatlen(curarg,arg,size);', 2]
['if (sz == 1)', 2]
['"local setkeyttl=function(ttl)\\n"', 2]
['totlen += bulklen(sdslen(curarg));', 2]
['c->obuf = sdsempty();', 2]
['head->spooler.fn->respond_message(&head->spooler, msg);', 2]
['for (i = 0; /* void */ ; i++) {', 2]
['nchan_store_channel_head_t   *head = (nchan_store_channel_head_t *)privdata;', 2]
["//  'active_ttl' is channel ttl with non-zero subscribers. -1 to persist, >0 ttl in sec", 2]
['if (blocking && redisSetBlocking(c,1) != REDIS_OK)', 2]
['tonumber(msg.tag) or 0,', 2]
['&nchan_subscriber_authorize_subscribe', 2]
['ngx_connection_t      *c;', 2]
['spool = (subscriber_pool_t *)rbtree_data_from_node(node);', 2]
['fsub->data.finalize_request = 1;', 2]
['switch(obj->type) {', 2]
['int reading, writing;', 2]
['urnode = rbtree_data_from_node(node);', 2]
['* Redistributions of source code must retain the above copyright', 2]
['ngx_str_t                    *chid;', 2]
['"--now publish to the efficient channel\\n"', 2]
['if (dictCompareHashKeys(ht, key, he->key))', 2]
['nchan_request_set_content_type_multipart_boundary_header(r, ctx);', 2]
["local key_channel='channel:'..id", 2]
['curargv[argc++] = curarg;', 2]
["redis.call('expire', v, ttl)", 2]
['if (reply != NULL)', 2]
['head->sub_count=0;', 2]
['int ret;', 2]
['b[3] = swap;', 2]
['ngx_conf_set_size_slot,', 2]
['reply = redisCommand(c,"PING");', 2]
['"        return oldkey\\n"', 2]
['redisLibevEvents *e = (redisLibevEvents*)watcher->data;', 2]
['"  }\\n"', 2]
['*s = obj.as.s16;', 2]
['"  if type(arr)~=\\"table\\" then\\n"', 2]
['assert(self->reserved > 0);', 2]
['data.use_redis = cf->use_redis;', 2]
['slot = shdata->procslot[i + memstore_procslot_offset];', 2]
['*i = obj.as.s32;', 2]
['offsetof(store_message_t, next),', 2]
['subt->longpoll=1;', 2]
['static nchan_msg_id_t  empty_msgid = NCHAN_ZERO_MSGID;', 2]
['for i = 1, #arg do', 2]
['_dictReset(ht);', 2]
['if(head->multi) {', 2]
['return cmp_write_u16(ctx, obj->as.u16);', 2]
['close(c->fd);', 2]
['buf->end = buf->last;', 2]
['* thanks, guys!', 2]
['ipc_close(ipc, cycle);', 2]
['/* closing quote must be followed by a space or', 2]
['return fd;', 2]
['assert(seed->active_nodes < max);', 2]
['in the Software without restriction, including without limitation the rights', 2]
['&nchan_store_delete_channel, //+callback', 2]
['frame->step = WEBSOCKET_READ_START_STEP;', 2]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "shpool alloc failed");', 2]
['if key.last_message then', 2]
['//cur_out += (ret - cur) + 1;', 2]
['cmp_read_uinteger(&cmp, (uint64_t *)&subscriber_id);', 2]
['*status = MSG_FOUND;', 2]
['nchan_pub_upstream_stuff_t    *psr_stuff;', 2]
['if (pvariant)', 2]
['ngx_str_t                  *group = &cf->channel_group;', 2]
['sub_data_t                 *d;', 2]
['if(d->sub->fn->release(d->sub, 0) == NGX_OK) {', 2]
['_mur_k1 *= _mur_c2;                                                \\', 2]
['return abort_response(self, err);', 2]
['//meh, no big deal.', 2]
['urnode->sub = *sub;', 2]
['#include "../store/memory/store.h"', 2]
['nchan_msg_t          *msg;', 2]
['b[7] = swap;', 2]
['#include <util/nchan_subrequest.h>', 2]
['ngx_del_timer(&data->timeout_ev);', 2]
['msg_id = nchan_subscriber_get_msg_id(r);', 2]
['prev = cur->prev;', 2]
['PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF', 2]
['return cmp_write_array16(ctx, obj->as.array_size);', 2]
['"  channel =     \'channel:\'..id,\\n"', 2]
['assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);', 2]
["local chan_key = 'channel:'..id", 2]
['ngx_memzero(&d->timeout_ev, sizeof(d->timeout_ev));', 2]
['&nchan_store_create_main_conf,', 2]
['&nchan_store_async_get_message, //+callback', 2]
['nchan_store_channel_head_t          *head;', 2]
['"  local n, del=0,0\\n"', 2]
['__redisRunCallback(ac,&cb,NULL);', 2]
['return NGX_DONE;', 2]
['id', 2]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "shpool free addr %p", p);', 2]
['while ((de = dictNext(it)) != NULL)', 2]
['return cmp_write_ext32_marker(ctx, obj->as.ext.type, obj->as.ext.size);', 2]
['}                                                                  \\', 2]
['*i = obj->as.u32;', 2]
['newargv = realloc(curargv,sizeof(char*)*(argc+1));', 2]
['DBG("not ready to reap %V, %i messages left", &ch->id, ch->channel.messages);', 2]
['"local chan_key = \'channel:\'..id\\n"', 2]
['fsub->sub.fn->respond_status(&fsub->sub, NGX_HTTP_NOT_MODIFIED, NULL);', 2]
['((void)fd); ((void)event);', 2]
['ngx_chain_t              *request_chain;', 2]
['//     test_cond(redisBufferWrite(c,NULL) == REDIS_ERR &&', 2]
['return RBTREE_WALK_LEFT_RIGHT;', 2]
['set_varval(v, msgidbuf, msgid->len);', 2]
['int pos; /* position in final command */', 2]
['value: "<number> (seconds)",', 2]
['return cmp_write_fixarray(ctx, obj->as.array_size);', 2]
['obj = (void*)REDIS_REPLY_NIL;', 2]
['ngx_int_t                    rc;', 2]
["// 'empty_ttl' is channel ttl when without subscribers. 0 to delete immediately, -1 to persist, >0 ttl in sec", 2]
['ctx->channel_id[n_out] = id[n_out];', 2]
['"    old=redis.call(\'lindex\', list_key, -1)\\n"', 2]
['if(lock->lock==0) {', 2]
['#define NCHAN_DEFAULT_SUBSCRIBER_POOL_SIZE (5 * 1024)', 2]
['default: :off,', 2]
['while (*(uintptr_t *) e.ip) {', 2]
['elements++;', 2]
['default: "off",', 2]
['databuf.end = last;', 2]
['subt->http_chunked=1;', 2]
['nchan_set_pubsub_channel_id,', 2]
['nchan_request_ctx_t    *ctx = ngx_http_get_module_ctx(fsub->sub.request, nchan_module);', 2]
['nchan_buf_and_chain_t           bc;', 2]
['void freeReplyObject(void *reply);', 2]
['}                                                                     \\', 2]
['_hs_q = (UT_hash_handle*)((_hs_q->next) ?                  \\', 2]
['if (e->reading) {', 2]
['int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);', 2]
['y = sdsnew("bar");', 2]
['//header values', 2]
['d->timeout_ev.cancelable = 1;', 2]
["subscriber_id='channel:next_subscriber_id:'..id --integer", 2]
['/* Return early when the context has seen an error. */', 2]
['Copyright (c) 2015 Charles Gunyon', 2]
['n_out++;', 2]
['assert(msg->refcount > 0);', 2]
['*count = 0;', 2]
['request_chain = sr->upstream->out_bufs;', 2]
['return spool;', 2]
["if redis.call('EXISTS', key_channel) ~= 0 then", 2]
['#if DEBUG_DELAY_IPC_RECEIVE_ALERT_MSEC', 2]
['* get-random-element operations. Hash tables will auto resize if needed', 2]
['int err; /* Error flags, 0 when there is no error */', 2]
['if(*mutex == 0 && ngx_atomic_cmp_set(mutex, 0, ngx_pid)) {', 2]
['all copies or substantial portions of the Software.', 2]
['of this software and associated documentation files (the "Software"), to deal', 2]
['bc.buf.last_buf = 0;', 2]
['void                *privdata;', 2]
['#define BUF(buf) (buf)->pos, ((buf)->last - (buf)->pos)', 2]
['return join;', 2]
['/* vi: set et ts=2 sw=2: */', 2]
['}*/', 2]
['if(chinfo) {', 2]
['ngx_str_t                       eventsource_event;', 2]
['//     redisCommandWithCallback(c,__test_reply_callback,(void*)2,"PING");', 2]
['if(n_out>1) {', 2]
['ngx_int_t                  rc;', 2]
['nchan_copy_new_msg_id(&fsub->sub.last_msgid, msg_id);', 2]
['fsub->sub.last_msgid.tag.fixed[0] = 0;', 2]
['"--output: subscriber_id, num_current_subscribers\\n"', 2]
['if(rp->last) {', 2]
['if (size <= FIXMAP_SIZE)', 2]
['int fd = c->fd;', 2]
['//already deleted maybe?', 2]
['"  if on then return function(...) redis.call(\'echo\', table.concat({...})); end\\n"', 2]
['@@scripts= {}', 2]
['case NGX_OK:', 2]
['((void*)((char*)(_hs_q->next) +                    \\', 2]
['((void)el); ((void)fd); ((void)mask);', 2]
['return cmp_write_s64(ctx, obj->as.s64);', 2]
['ctx->prev_msg_id = empty_msgid;;', 2]
['urnode->msg = *msg;', 2]
['#define REQUEST_PCALLOC(r, what) what = ngx_pcalloc((r)->pool, sizeof(*(what)))', 2]
["//don't edit this please, it was auto-generated", 2]
['ngx_memzero(p, size);', 2]
['"      end \\n"', 2]
['case NGX_HTTP_POST:', 2]
['switch(r->method) {', 2]
['nchan_msg_id_t         *msg_id;', 2]
['"  redis.call(\'echo\', table.concat({...}))\\n"', 2]
['*d = obj.as.dbl;', 2]
['swap = b[3];', 2]
['case NGX_HTTP_GET:', 2]
['* tables of power of two in size are used, collisions are handled by', 2]
['nchan_free_msg_id(&sub->last_msgid);', 2]
['The above copyright notice and this permission notice shall be included in', 2]
['//DBG("ok to delete channel %V", &ch->id);', 2]
['case INACTIVE:', 2]
['strcasecmp(reader->errstr,"Protocol error, got \\"@\\" as reply type byte") == 0);', 2]
['static ngx_int_t nchan_store_init_postconfig(ngx_conf_t *cf) {', 2]
['@false', 2]
['reset_timer(f);', 2]
['if(ch == NULL) {', 2]
['head->meta = 1;', 2]
['spool_transfer_subscribers(spool, newspool, 0);', 2]
['--input: keys: [],  values: [ channel_id ]', 2]
['*i = obj.as.u8;', 2]
['case NGX_HTTP_NO_CONTENT:', 2]
['* chaining. See the source code for more information... :)', 2]
['* backend', 2]
['ngx_core_conf_t                *ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);', 2]
['b[6] = swap;', 2]
['default: "0 (none)",', 2]
['/* Try again later when the context is still not connected. */', 2]
['"      local ex=redis.call(\'exists\', oldkey)\\n"', 2]
['if(head->use_redis) {', 2]
['"  oldestmsg(key.messages, \'channel:msg:%s:\'..id)\\n"', 2]
['return &str;', 2]
['case MSG_INVALID:', 2]
['if (newbuf == NULL) {', 2]
['id.tagcount=1;', 2]
['tried_count++;', 2]
["assert(ch->foreign_owner_ipc_sub == NULL); //we don't accept still-subscribed chanheads", 2]
['void *obj;', 2]
['if (len == -1) {', 2]
['"  local h = {}\\n"', 2]
['subt->poll=0;', 2]
['if on then', 2]
['DBG("%p dequeue", self);', 2]
['if (redisSetBlocking(c,0) != REDIS_OK)', 2]
["subscribers = 'channel:subscribers:'..id,", 2]
["while (*_p != '\\0' && isdigit(*_p)) _p++;", 2]
['for (i = 0; i < num; i++)', 2]
['if (sz == 16)', 2]
['if (err == NGX_EAGAIN) {', 2]
['d->callback(NGX_HTTP_INTERNAL_SERVER_ERROR, NULL, d->privdata);', 2]
['if (!ctx->read(ctx, data, str_size)) {', 2]
['OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN', 2]
['callback_pt          callback;', 2]
['r->ridx = -1;', 2]
['count++;', 2]
['d->timeout_ev.log = ngx_cycle->log;', 2]
['d->timeout_ev.data = d;', 2]
['buf->temporary = 0;', 2]
['unsigned                        websocket:1;', 2]
['if(!msg->buf->in_file) {', 2]
['//output: channel_hash {ttl, time_last_seen, subscribers, messages} or nil', 2]
['static ngx_int_t sub_respond_message(ngx_int_t status, void *ptr, sub_data_t* d) {', 2]
['CHANNEL_HASH_ADD(head);', 2]
['ngx_int_t memstore_slot(void);', 2]
['if(!ch->shutting_down) {', 2]
['r->pos = 0;', 2]
['NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1|NGX_CONF_TAKE2,', 2]
['local n, del=0,0', 2]
['if(file->fd == NGX_INVALID_FILE) {', 2]
['fsub->dequeue_handler_data = NULL;', 2]
['rbtree_seed_t      *seed = &spl->spoolseed;', 2]
['static void empty_handler() { }', 2]
['if (ch->sub_count > 0) { //there are subscribers', 2]
['void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);', 2]
['"local id = ARGV[1]\\n"', 2]
['offsetof(nchan_loc_conf_t, max_channel_id_length),', 2]
['#include <strings.h>', 2]
['return cmp_write_str16_marker(ctx, obj->as.str_size);', 2]
['*i = obj->as.u8;', 2]
['return cmp_write_fixext8_marker(ctx, obj->as.ext.type);', 2]
['return cmp_write_str32_marker(ctx, size);', 2]
["require 'digest/sha1'", 2]
['spooled_subscriber_t  *ssub;', 2]
['case NCHAN_MESSAGE_QUEUED:', 2]
['return cmp_write_bin16_marker(ctx, obj->as.bin_size);', 2]
['if (touched) {', 2]
['ac->ev.data = NULL;', 2]
['assert(replies[i] != NULL && replies[i]->elements == 500);', 2]
['concurrency = "broadcast";', 2]
['//initialization', 2]
['redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,', 2]
['callback_pt           callback;', 2]
['}; //sub_data_t', 2]
['return (((uint64_t)low_part) << 32) | high_part;', 2]
['head = nchan_store_get_chanhead(channel_id);', 2]
['return reply;', 2]
['&nchan_store_init_worker,', 2]
["//  'subscriber_id' can be '-' for new id, or an existing id", 2]
['if (ac->ev.data != NULL) {', 2]
['proc->active = 0;', 2]
['void *redisCommand(redisContext *c, const char *format, ...);', 2]
['nchan_store_channel_head_t  *chanhead;', 2]
['msg->dbg_next = NULL;', 2]
['if(publisher_upstream_request_url_ccv == NULL) {', 2]
['if(c==NULL) {', 2]
['if (size > 0)', 2]
["redis.call('LPUSH', key.messages, msg.id)", 2]
['memstore_ensure_chanhead_is_ready(head, 0);', 2]
['return dequeue_maybe(self);', 2]
['subscriber_t        *sub;', 2]
['return tokens;', 2]
['assert(ttl > 0);', 2]
['dictEntry *he, *nextHe;', 2]
['sub->destroy_after_dequeue = 1;', 2]
['if (reply == NULL) {', 2]
['nchan_store_channel_head_t *head = (nchan_store_channel_head_t *)privdata;', 2]
['"local key_channel=\'channel:\'..id\\n"', 2]
['local arg, cur = {...}, nil', 2]
['d->timeout_ev.handler = timeout_ev_handler;', 2]
['if(lock->lock == NGX_RWLOCK_WRITE) {', 2]
['id.tagactive=0;', 2]
['d->chanhead = chanhead;', 2]
['d->shm_chid=NULL;', 2]
['return cmp_write_bin32_marker(ctx, obj->as.bin_size);', 2]
['return totlen;', 2]
['_p += 2;', 2]
['fsub->sub.request->write_event_handler = ngx_http_request_empty_handler;', 2]
['test_cond(reply == NULL);', 2]
['he = ht->table[h];', 2]
['char errstr[128]; /* String representation of error when applicable */', 2]
['sz += id[n_out].len + 1 + grouplen; // "group/<channel-id>"', 2]
['rp->count--;', 2]
['u_char         *cur = id->data;', 2]
['"    return {418, \\"\\", \\"\\", \\"\\", \\"\\", subs_count}\\n"', 2]
['ngx_int_t memstore_slot() {', 2]
['#include "../store/redis/store.h"', 2]
['"  return h\\n"', 2]
['rds_sub_ctx();', 2]
['//input: keys: [],  values: [ channel_id ]', 2]
['websocket_publish_continue(fsub, buf);', 2]
['if (!ac->err) {', 2]
['if (p == NULL) {', 2]
['assert(rp->count >= 0);', 2]
['chanhead_gc_add(cur, "exit worker");', 2]
['switch(reply->type) {', 2]
['(head)->hh.tbl->num_items, _count );                             \\', 2]
['nchan_msg_buf_open_fd_if_needed(&bc[2].buf, &file_copy, NULL);', 2]
['static void reset_timer(sub_data_t *data) {', 2]
['"        del=del+1\\n"', 2]
['struct nchan_store_channel_head_s {', 2]
['__redisSetError(c,c->reader->err,c->reader->errstr);', 2]
['"local keys = {\\n"', 2]
['redisReply *reply = rep;', 2]
['chanhead_gc_add(head, "sub count == 0 after spooler dequeue");', 2]
['//cancel publication', 2]
['"  for i,v in pairs(keys) do\\n"', 2]
['return cmp_write_fixstr_marker(ctx, obj->as.str_size);', 2]
['} subscribe_data_t;', 2]
['ctx->msg_id = self->last_msgid;', 2]
['lock->lock=0;', 2]
['if(ch->shared) {', 2]
['"      h[k]=v; k=nil\\n"', 2]
['if(!head->spooler.running) {', 2]
['memstore_fakeprocess_push(i);', 2]
['case NGX_HTTP_CONFLICT:', 2]
['b[1] = b[6];', 2]
['"if on then return function(...) redis.call(\'echo\', table.concat({...})); end\\n"', 2]
['if(msg->prev != NULL) {', 2]
['p = ngx_alloc(size, ngx_cycle->log);', 2]
['fsub->sub.last_msgid.time = 0;', 2]
['if (!e->reading) {', 2]
['undocumented: true,', 2]
['curarg = sdsempty();', 2]
['len == 4+5+(12+2)+4+(9+2));                                                       \\', 2]
['e->writing = 0;', 2]
['if (*cv == NULL) {', 2]
['//input: keys: [], values: [channel_id, subscriber_id, empty_ttl]', 2]
['"  unpacked= {\\n"', 2]
['bc[1].chain.buf = &bc[1].buf;', 2]
['spool_respond_general(spool, NULL, NGX_HTTP_NO_CONTENT, NULL);', 2]
['*status = MSG_EXPECTED;', 2]
['#define STR(buf) (buf)->data, (buf)->len', 2]
['if(d->reserved) {', 2]
['ngx_destroy_pool(temp_pool);', 2]
['for(i = first; i < last; i++) {', 2]
['r->buf = sdsempty();', 2]
['d->shm_channel_info = NULL;', 2]
['subscriber_t            sub;', 2]
['ngx_buf_t               buf;', 2]
['"      oldkey=old_fmt:format(old)\\n"', 2]
['if(code >= 200 && code <299) {', 2]
['to use, copy, modify, merge, publish, distribute, sublicense, and/or sell', 2]
['nchan_request_ctx_t       *ctx = ngx_http_get_module_ctx(r, nchan_module);', 2]
['"local oldestmsg=function(list_key, old_fmt)\\n"', 2]
['req_msgid[i].tagcount = 1;', 2]
['sdslen(y) == 0 && memcmp(y,"\\0",1) == 0)', 2]
['ch.last_published_msg_id.tagactive = 0;', 2]
['(void (*)(void *)) memstore_reap_store_message,', 2]
['ngx_core_conf_t    *ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);', 2]
["info: <<-EOS.gsub(/^ {8}/, '')", 2]
['u_char                     *cur;', 2]
['/* unterminated quotes */', 2]
['#define HASH_ITER(hh,head,el,tmp)                                                \\', 2]
['data[str_size] = 0;', 2]
['if (newarg == NULL) goto err;', 2]
['THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR', 2]
['ipc_try_close_fd(&socks[1]);', 2]
['uint32_t bin_size = 0;', 2]
['int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,', 2]
['if(callback == NULL) {', 2]
['fsub->sub.reserved = 0;', 2]
['redisLibeventEvents *e = (redisLibeventEvents*)arg;', 2]
['sdslen(y) == 3 && memcmp(y,"iao\\0",4) == 0)', 2]
["oldestmsg(key.messages, 'channel:msg:%s:'..id)", 2]
['return NGX_OK; //async only now!', 2]
['static store_redis_lua_scripts_t store_rds_lua_script_names = {', 2]
['static store_redis_lua_scripts_t store_rds_lua_scripts = {', 2]
["redis.call('echo', table.concat({...}))", 2]
['if ((rc = ws_recv(c, rev, &buf, 2)) != NGX_OK) {', 2]
['void                      *callback_privdata;', 2]
['return {sub_id, sub_count}', 2]
['* Wandenberg Peixoto <wandenberg@gmail.com>, Rog\xc3\xa9rio Carvalho Schneider <stockrt@gmail.com>', 2]
['"  subscriber_id=\'channel:next_subscriber_id:\'..id --integer\\n"', 2]
['void                 *privdata;', 2]
['d->renew = 0;', 2]
['return (void *)NGX_INVALID_FILE;', 2]
['if(cf->args->nelts == 1){ //no arguments', 2]
['sdsfree(curarg);', 2]
['/* Build the command at protocol level */', 2]
['"--input: keys: [],  values: [ channel_id ]\\n"', 2]
['"    if old then\\n"', 2]
['return cmp_write_u32(ctx, obj->as.u32);', 2]
['nchan_store_channel_head_t  *ch;', 2]
['clcf = ngx_http_get_module_loc_conf(r->main, ngx_http_core_module);', 2]
['redisContextConnectTcp(c,ip,port,NULL);', 2]
['assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);', 2]
['"      redis.call(\'expire\', v, ttl)\\n"', 2]
["channel =     'channel:'..id,", 2]
['*b = true;', 2]
['return cmp_write_u64(ctx, obj->as.u64);', 2]
['#include "redis_nginx_adapter.h"', 2]
['"  while true do\\n"', 2]
['databuf.last = last;', 2]
['ngx_int_t    rc = NGX_OK;', 2]
['prev->dbg_next = next;', 2]
['static ngx_int_t nchan_store_subscribe(ngx_str_t *channel_id, subscriber_t *sub) {', 2]
['//authorized. proceed as planned', 2]
['"  subscribers = \'channel:subscribers:\'..id,\\n"', 2]
['nchan_maybe_send_channel_event_message(r, CHAN_PUBLISH);', 2]
['spool->bulk_dequeue_handler(spool, sub->type, 1, pd);', 2]
['ngx_int_t                 code = sr->headers_out.status;', 2]
['head->foreign_owner_ipc_sub = NULL;', 2]
['ctx->msg_id = empty_msgid;', 2]
['params->password = NULL;', 2]
['ngx_memcpy(cur, tmpid.data, tmpid.len);', 2]
['if (chain->buf->in_file) {', 2]
['redisAsyncDisconnect(ac);', 2]
['case NGX_DECLINED: //not found', 2]
['nchan_msg_id_t        msgid;', 2]
['test_blocking_io_errors(cfg);', 2]
['/* Abort connect was not successful. */', 2]
['while(memstore_fakeprocess_pop()) {  };', 2]
['dictEntry *de;', 2]
['ngx_http_request_t    *r = fsub->sub.request;', 2]
['if old then', 2]
['redisContext *redisConnect(const char *ip, int port);', 2]
['if (b)', 2]
['offsetof(nchan_loc_conf_t, channel_group),', 2]
['if (!(c->flags & REDIS_CONNECTED))', 2]
['&nchan_store_find_channel, //+callback', 2]
['ctx->error = STR_DATA_LENGTH_TOO_LONG_ERROR;', 2]
['0, //reserved', 2]
['newlen = (start > end) ? 0 : (end-start)+1;', 2]
['return cmp_write_str32_marker(ctx, obj->as.str_size);', 2]
['reply = redisCommand(c,"INCR counter");', 2]
['case NGX_HTTP_INTERNAL_SERVER_ERROR:', 2]
['ipc_process_t                  *proc;', 2]
['if (tokens[elements] == NULL) goto cleanup;', 2]
['params->port = 6379;', 2]
['char *p, *s;', 2]
['//               strncmp(c->error,"write:",6) == 0);', 2]
['if (ctx->write(ctx, &size, sizeof(uint8_t)))', 2]
['if(d->d.resp.shm_msg) {', 2]
['NGX_RWLOCK_MUTEX_COND(lock, (lock->lock != NGX_RWLOCK_WRITE), lock->lock++)', 2]
['ngx_str_t          *val = &((ngx_str_t *) cf->args->elts)[1];', 2]
['offsetof(nchan_loc_conf_t, subscribe_only_existing_channel),', 2]
['//shared memory', 2]
['"    if ttl > 0 then\\n"', 2]
['if(is_multi_id(channel_id)) {', 2]
['if(!cmp_read_uinteger(cmp, &msgtag)) {', 2]
['if (ht->size == 0)', 2]
['offsetof(nchan_main_conf_t, shm_size),', 2]
['for (i = 0; i < ht->size && ht->used > 0; i++) {', 2]
['&nchan_store_init_postconfig,', 2]
['return cmp_write_ext16_marker(ctx, obj->as.ext.type, obj->as.ext.size);', 2]
['if (reply->type == REDIS_REPLY_ARRAY) {', 2]
['THING_HASH_FIND(tc, id, thing);', 2]
['obj = r->fn->createNil(cur);', 2]
['static void ensure_request_hold(full_subscriber_t *fsub) {', 2]
['if (temp_pool != NULL) {', 2]
['"      redis.call(\'persist\', v)\\n"', 2]
['obj->type = CMP_TYPE_BOOLEAN;', 2]
['static void nchan_store_create_main_conf(ngx_conf_t *cf, nchan_main_conf_t *mcf) {', 2]
['static ngx_int_t nchan_store_async_get_message(ngx_str_t *channel_id, nchan_msg_id_t *msg_id, callback_pt callback, void *privdata) {', 2]
['return msg;', 2]
['//Copyright (c) 2014 Wandenberg Peixoto under the MIT Licence', 2]
['for(i=0; i< max; i++) {', 2]
['if (_count != (head)->hh.tbl->num_items) {                               \\', 2]
['&& CHECK_REPLY_INT(reply->element[2])) {', 2]
['HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));               \\', 2]
['val = interval;', 2]
['e->reading = 1;', 2]
['_mur_h1 ^= _mur_k1;                                                \\', 2]
['redis_channel_callback_data_t *d;', 2]
['#define DECLTYPE_ASSIGN(dst,src)                                                 \\', 2]
['*s = obj.as.u8;', 2]
['value: "<url>",', 2]
['responded_subs += spool->sub_count;', 2]
['freeReplyObject(r);', 2]
["redis.call('persist', v)", 2]
["redis.call('rpop', list_key)", 2]
['CHANNEL_HASH_DEL(ch);', 2]
['* Copyright (c) 2006-2014, Salvatore Sanfilippo <antirez at gmail dot com>', 2]
['ngx_free(of);', 2]
['#include "ipc-handlers.h"', 2]
['&nchan_store_exit_worker,', 2]
['d->getting++;', 2]
['static void nchan_store_exit_worker(ngx_cycle_t *cycle) {', 2]
['return node;', 2]
['cur = ret + 1;', 2]
['c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);', 2]
['memstore_ensure_chanhead_is_ready(head, 1);', 2]
['static ngx_int_t dequeue_maybe(subscriber_t *self) {', 2]
['"    return function(...) return; end\\n"', 2]
['nchan_worker_processes = ccf->worker_processes;', 2]
['if(data->timeout_ev.timer_set) {', 2]
['*s = obj->as.u8;', 2]
['* function returning NULL is interpreted as OOM. */', 1]
['/* lines of entry */', 1]
['/* Disconnect when there was an error reading the reply */', 1]
['* MessagePack libraries.', 1]
['nchan_loc_conf_t        cf;', 1]
['dst->tagactive = src->tagactive;', 1]
['nchan_store_publish_generic(&chanhead->id, &msg, 0, NULL);', 1]
['msg.buf = &buf;', 1]
['r->request_body_in_single_buf = 1;', 1]
['dummy_config.buffer_timeout = 0;', 1]
['size_t newlen, len = sdslen(s);', 1]
['reply = redisCommand(c,"INFO");', 1]
['{ ngx_string("nchan_subscriber_type"),    nchan_subscriber_type_variable, 0},', 1]
['#define NGX_HTTP_ACCEPTED 202', 1]
['#define __HIREDIS_H', 1]
['if(status == NGX_HTTP_NO_CONTENT || status == NGX_HTTP_NOT_MODIFIED) {', 1]
['if(msg_ids_equal(&spool->id, &new_id)) {', 1]
['if(spl->dequeue_handler) {', 1]
['ngx_int_t memstore_channel_owner(ngx_str_t *id);', 1]
['"  new_channel = true\\n"', 1]
['return {err="Argument 7, max_msg_buf_size, can\'t be empty"}', 1]
['void           *callback_privdata;', 1]
['nchan_complex_value_arr_t   *alt_msgid_cv_arr = &cf->last_message_id;', 1]
['ac->ev.delRead = redis_nginx_del_read;', 1]
['callback_pt             callback;', 1]
['pd->callback = callback;', 1]
['b[0] = b[1];', 1]
['/* Writes an object to the backend */', 1]
["dbg(' ######## SUBSCRIBER UNREGISTER SCRIPT ####### ')", 1]
['freeReplyObject(redisCommand(c,"PING"));', 1]
['publish_msg->prev_id.tagcount = 1;', 1]
['|| (lastid->time == req_msgid[i].time && lastid->tag.fixed[0] >= req_msgid[i].tag.fixed[0])) {', 1]
['void    **next = thing_next_ptr(rp, thing);', 1]
['rp->position = cur;', 1]
['ngx_int_t internal_subscriber_set_name(subscriber_t *sub, ngx_str_t *name);', 1]
['(signed)iter->ht->size) break;', 1]
['return ch->msg_last == msg ? NGX_OK : NGX_ERROR;', 1]
['void subscriber_debug_remove(subscriber_t *sub) {', 1]
['unsigned                        stub:1;', 1]
['#define HASH_BLOOM_BITLEN (1ULL << HASH_BLOOM)', 1]
['return nchan_respond_membuf(r, NGX_HTTP_OK, content_type, b, 0);', 1]
['bool cmp_read_ext16_marker(cmp_ctx_t *ctx, int8_t *type, uint16_t *size) {', 1]
['*prev_ptr = rp->last;', 1]
['memcpy(cb,source,sizeof(*cb));', 1]
['redisAsyncContext *redis_nginx_open_context(u_char *host, int port, int database, u_char *password, redisAsyncContext **context);', 1]
['if(d->timeout_ev.timer_set) {', 1]
['ngx_buf_t *cbuf;', 1]
['test("Set error when an invalid timeout usec value is given to redisConnectWithTimeout: ");', 1]
['{ ngx_string("nchan_max_channel_subscribers"),', 1]
['char                 *name;', 1]
['u_char                 *cur;', 1]
['#include "nchan_reaper.h"', 1]
['p = ngx_slab_alloc(SHPOOL(shm), size);', 1]
['async.o: async.c async.h hiredis.h sds.h dict.c dict.h', 1]
['if (target == NULL)', 1]
['ngx_int_t rbtree_destroy_node(rbtree_seed_t *seed, ngx_rbtree_node_t *node) {', 1]
['EXT_TYPE_READING_ERROR,', 1]
['struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */', 1]
['the command is initially queued for execution.', 1]
['ssub->sub = sub;', 1]
['ngx_atomic_fetch_add(&head->shared->sub_count, 1);', 1]
['"if sub_id == \\"-\\" then\\n"', 1]
['if(r->headers_in.content_type) {', 1]
['if((msg=msg_from_redis_get_message_reply(reply, 1, &ngx_store_alloc))) {', 1]
['const ngx_str_t   *format;', 1]
['next->prev = NULL;', 1]
['#define NCHAN_FIXED_MULTITAG_MAX 4', 1]
['if (_prev !=(char*)(_thh->prev)) {                                    \\', 1]
['"  no_msgid_order = \'FILO\'\\n"', 1]
['else if (type_marker == FALSE_MARKER) {', 1]
['cur = ngx_snprintf(cbuf, 100, "multipart/mixed; boundary=%V", nchan_request_multipart_boundary(r, ctx));', 1]
['buflen *= 2;', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "REDISTORE: " fmt, ##args)', 1]
['obj->type = CMP_TYPE_EXT32;', 1]
['cmp_writer  write;', 1]
['*value = e.buf;', 1]
['fsub->sub.request->read_event_handler = websocket_reading;', 1]
["//meh, this can't be triggered... can it?...", 1]
['*thing_next_ptr(rp, rp->last) = thing;', 1]
['*s = obj->as.s16;', 1]
['info: "Controls the first message received by a new subscriber. \'oldest\' returns the oldest available message in a channel\'s message queue, \'newest\' waits until a message arrives."', 1]
['nchan_store_channel_head_t  *origin_chanhead;', 1]
['subscriber_t *memstore_multi_subscriber_create(nchan_store_channel_head_t *chanhead, uint8_t n) {', 1]
['CONN_TCP,', 1]
['static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {', 1]
['((internal_subscriber_t *)sub)->dequeue = handler;', 1]
['nchan_max_channel_subscribers [:main, :srv, :loc],', 1]
['bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size) {', 1]
['ids[n].len = sep - cur;', 1]
['wfd[0].fd     = c->fd;', 1]
['#define NCHAN_MULTITAG_REQUEST_CTX_MAX 4', 1]
['int len = 0;', 1]
['(head)->hh.tbl->hho) : NULL );                 \\', 1]
['ngx_buf_t    *buf;', 1]
['// reinitialize already active pipes. This is done to prevent IPC alerts', 1]
['"-- \'empty_ttl\' is channel ttl when without subscribers. 0 to delete immediately, -1 to persist, >0 ttl in sec\\n"', 1]
['_he_newbkt->expand_mult = _he_newbkt->count /                       \\', 1]
['void *urs_node_id(void *data) {', 1]
['u_char                    *cur = accept;', 1]
['ERR("couldn\'t allocate llink for websocket publisher");', 1]
['u_char         *sep;', 1]
['* The number of arguments is stored into *argc, and an array', 1]
['nchan_pub_upstream_stuff_t  *upstream_stuff;', 1]
['(head)->hh.tbl->hho);                                            \\', 1]
['nchan_store_channel_head_t     *gc_prev;', 1]
['nchan_pubsub_directive,', 1]
['d->chid = chid;', 1]
['const uint8_t *_mur_data = (const uint8_t*)(key);                    \\', 1]
['$(MAKE) CFLAGS="-pg" LDFLAGS="-pg"', 1]
['/* Run subscription callbacks callbacks with NULL reply */', 1]
['redisEchoCallback(c, reply->element[i], "  ");', 1]
['join = sdscat(join, argv[j]);', 1]
['req_msgid[i].time = 0;', 1]
['#define __NET_H', 1]
['ngx_http_request_t      *r = fsub->sub.request;', 1]
['if (!write_type_marker(ctx, FLOAT_MARKER))', 1]
['__redisReaderSetError(r,REDIS_ERR_PROTOCOL,sbuf);', 1]
['size_t len, newlen;', 1]
['redisReply *r = reply;', 1]
['obj->type = CMP_TYPE_STR8;', 1]
['bool cmp_object_is_ulong(cmp_object_t *obj);', 1]
['union cmp_object_data_u {', 1]
['frame->last = buf.last;', 1]
['/* Initializes a CMP context */', 1]
['/* Writes NULL to the backend */', 1]
['returned. The `err` field inside the context will be non-zero and set to one of the', 1]
['ngx_str_t                          *value;', 1]
['//msgtag', 1]
['bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {', 1]
['float     flt;', 1]
['ngx_http_subrequest(r, &psrd->upstream_request_url, NULL, &sr, psr, NGX_HTTP_SUBREQUEST_IN_MEMORY);', 1]
['extern const ngx_str_t NCHAN_HEADER_IF_NONE_MATCH;', 1]
['--dbg(k.."="..v)', 1]
['assert(ht->used == 0);', 1]
['static char msgtag_str_buf[10*255 + 30];', 1]
['obj->type = CMP_TYPE_FIXEXT8;', 1]
['ac->sub.channels = dictCreate(&callbackDict,NULL);', 1]
['* writing data in chunks instead of a single shot.', 1]
['if (r->buf != NULL)', 1]
['extern const ngx_str_t NCHAN_CHANNEL_INFO_YAML;', 1]
['callback_pt              callback;', 1]
['else if(tc > 0) {', 1]
['redis_nginx_close_context(redisAsyncContext **context)', 1]
['u_char fin:1;', 1]
['elements = readLongLong(p);', 1]
['r->err = type;', 1]
['__redisReaderSetError(r,REDIS_ERR_OOM,"Out of memory");', 1]
['//message data', 1]
['unsigned                    publish_events:1;', 1]
['#define NCHAN_DEFAULT_MIN_MESSAGES 1', 1]
['//void verify_unique_response(ngx_str_t *uri, nchan_msg_id_t *msgid, nchan_msg_t *msg, subscriber_t *sub);', 1]
['if (redisBufferWrite(c,&done) == REDIS_ERR) {', 1]
['BIN8_MARKER            = 0xC4,', 1]
['if (fails) {', 1]
['for(_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head;                \\', 1]
['ac->ev.cleanup = redisAeCleanup;', 1]
['char *stype;', 1]
['/* Awesome, DB 9 is empty and we can continue. */', 1]
['"if redis.call(\'EXISTS\', keys.channel) ~= 0 then\\n"', 1]
['"local num_messages = redis.call(\'llen\', key.messages)\\n"', 1]
['When you need to pass binary safe strings in a command, the `%b` specifier can be', 1]
['mmapped = 1;', 1]
['event_base_set(base,&e->wev);', 1]
["* here's what a websocket frame looks like", 1]
['ngx_int_t ngx_http_complex_value_noalloc(ngx_http_request_t *r, ngx_http_complex_value_t *val, ngx_str_t *value, size_t maxlen) {', 1]
['proc->wbuf.first = 0; // for debugging and stuff', 1]
['//     test("Process callbacks in the right sequence: ");', 1]
['#define __MAX_MSEC (((LONG_MAX) - 999) / 1000)', 1]
['ngx_int_t nchan_channel_info(ngx_http_request_t *r, ngx_uint_t messages, ngx_uint_t subscribers, time_t last_seen, nchan_msg_id_t *msgid);', 1]
['ngx_int_t     content_length = r->headers_in.content_length_n > 0 ? r->headers_in.content_length_n : 0;', 1]
['static ngx_int_t websocket_respond_message(subscriber_t *self, nchan_msg_t *msg) {', 1]
['For instance if you have a normal Redis context you can set the maximum idle', 1]
['aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);', 1]
['size_t _l = 0;', 1]
['e->wev.data = e;', 1]
['"dbg(\' ####### PUBLISH STATUS ####### \')\\n"', 1]
['redisAsyncCommand(rds_ctx(), &redis_get_message_callback, (void *)d, "EVALSHA %s 0 %b %i %i %s", store_rds_lua_hashes.get_message, STR(channel_id), msg_id->time, msg_id->tag.fixed[0], "FILO", 0);', 1]
['static void test_blocking_connection_errors(void) {', 1]
['Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>', 1]
['self.class.luac', 1]
['const ngx_str_t NCHAN_HEADER_CONNECTION = ngx_string("Connection");', 1]
['lcov -d . -c -o tmp/lcov/hiredis.info', 1]
['STLIB_MAKE_CMD=ar rcs $(STLIBNAME)', 1]
['} nchan_llist_timed_t;', 1]
['//ERR(" -- newid                       %V", msgid_to_str(&new_id));', 1]
['THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS', 1]
['union subdata_u              d;', 1]
['shm_free_immutable_string(nchan_memstore_get_shm(), str);', 1]
['/* Create a list of numbers, from 0 to 9 */', 1]
['ngx_free(ch->multi);', 1]
['ngx_init_set_membuf(&bc.buf, hello.data, hello.data + hello.len);', 1]
['if (_hs_tail){                                                         \\', 1]
['ERR("REDIS: PUB/SUB already unsubscribed from %s, chanhead %p (id %V) INACTIVE.", reply->element[1]->str, chanhead, &chanhead->id);', 1]
['ngx_str_t                 *name;', 1]
['/* Free the context as well, but keep the fd if requested. */', 1]
['"if type(msg.content_type)==\'string\' and msg.content_type:find(\':\') then\\n"', 1]
['uint8_t                      want[NCHAN_MULTITAG_MAX];', 1]
['* an indirection to the redisContext struct. */', 1]
['install: $(DYLIBNAME) $(STLIBNAME)', 1]
['overflow = data->overflow;', 1]
['};// spool_collect_overflow_t;', 1]
['cfg.tcp.host = argv[0];', 1]
['etag->len = ngx_sprintf(etag->data,"%i", msg->id.tag.fixed[0])- etag->data;', 1]
['if(d->rc == NGX_OK) {', 1]
['return NCHAN_INVALID_SLOT;', 1]
['@echo "$$REDIS_TEST_CONFIG" | $(REDIS_SERVER) -', 1]
['spool->bulk_dequeue_handler(spool, sub->type, spool->shortlived_sub_count + 1, pd);', 1]
['struct nchan_msg_s {', 1]
['d->msg_time=msg->id.time;', 1]
['* conditions, the error will be set to EOF. */', 1]
['inq=1;', 1]
['v->no_cacheable = 1;', 1]
['c = redisConnectNonBlock(ip,port);', 1]
['ac->sub.invalid.head = NULL;', 1]
['default: :on,', 1]
['if((d = shm_calloc(shm, sizeof(*d), "root shared data")) == NULL) {', 1]
['u_char              buf[255];', 1]
['static void redisLibeventAddWrite(void *privdata) {', 1]
['assert( msg->id.tagcount == 1 );', 1]
['head->stub = 1;', 1]
['}; //ngx_rbtree_debug_node_t;', 1]
['msg->start_tv = ctx->start_tv;', 1]
['fsub->hdr_chain.buf = &fsub->hdr_buf;', 1]
['if (cur->idx == prv->elements-1) {', 1]
['* If the context had an error but the fd still valid is because another context got the same fd from OS.', 1]
['for(_ho_i=0; _ho_i < keylen; _ho_i++) {                                        \\', 1]
['//ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "got msg %V", msgid_to_str(&msg));', 1]
['wb->overflow_last->next = overflow;', 1]
['ngx_int_t nchan_respond_cstring(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *content_type, char *body, ngx_int_t finalize) {', 1]
['sdata->generation = chanhead->generation;', 1]
['int8_t            sign = 1;', 1]
['ac->err = 0;', 1]
['sub->fn = chunked_fn;', 1]
['head->last_subscribed_local = 0;', 1]
['ws_pub_head.prev = &ws_pub_head;', 1]
['if((sr->request_body = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t))) == NULL) {', 1]
['char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */', 1]
['redis_nginx_add_write(void *privdata)', 1]
['sdsrange(y,1,1);', 1]
['DBG("tried publishing %V with a NULL chanhead", msgid_to_str(&msg->id));', 1]
['reply = redisCommand(context,"SUBSCRIBE foo");', 1]
['#define REDIS_REPLY_INTEGER 3', 1]
['ngx_str_t *ngx_http_debug_pool_str(ngx_pool_t *pool) {', 1]
['|                               |Masking-key, if MASK set to 1  |', 1]
['int redisBufferRead(redisContext *c) {', 1]
['write(HASH_EMIT_KEYS, keyptr, fieldlen);                                     \\', 1]
['__attribute__((format(printf, 2, 3)));', 1]
['//yeah', 1]
['d->use_redis = use_redis;', 1]
['ERR("what\'s the deal with this NGX_HTTP_LOWLEVEL_BUFFERED thing?");', 1]
['ngx_free(ssub);', 1]
['printf("Connecting to inherited fd %d\\n", fd);', 1]
['static store_message_t *create_shared_message(nchan_msg_t *m, ngx_int_t msg_already_in_shm);', 1]
['CMP_TYPE_UINT8,           /* 14 */', 1]
['ngx_file_t              file;', 1]
['nchan_longpoll_multipart_response [:srv, :loc, :if],', 1]
['if (obj->as.u16 <= 32767) {', 1]
['target_ch = nchan_memstore_get_chanhead(&d->multi->id, &cf);', 1]
['ngx_int_t             msglen;', 1]
['ipc->handler=alert_handler;', 1]
['rbtree_conditional_walk_real(seed, seed->tree.root, seed->tree.sentinel, callback, data);', 1]
['typedef struct ipc_writebuf_overflow_s ipc_writebuf_overflow_t;', 1]
['* is a valid hex digit. */', 1]
['void *redisCommand(redisContext *c, const char *format, ...) {', 1]
['if((tmp = nchan_get_header_value(r, NCHAN_HEADER_UPGRADE))) {', 1]
['info: "Contents of channel event message"', 1]
['/* Size: char */', 1]
['uint32_t signature; /* used only to find hash tables in external analysis */', 1]
['_he_hh_nxt = _he_thh->hh_next;                                        \\', 1]
['cur += 7;', 1]
['DBG("IPC channel handler");', 1]
['//string constants', 1]
['psrd->tmp_pool = ngx_create_pool(NCHAN_WS_UPSTREAM_TMP_POOL_SIZE, r->connection->log);', 1]
['hiredis-example-libuv: examples/example-libuv.c adapters/libuv.h $(STLIBNAME)', 1]
['int64_t   s64;', 1]
['nchan_set_channel_events_channel_id,', 1]
['Dir[ "#{File.dirname(__FILE__)}/*.lua" ].each do |f|', 1]
['* Note: this does not change the *length* of the sds string as returned', 1]
['bool cmp_object_as_map(cmp_object_t *obj, uint32_t *size) {', 1]
['if((n = parse_multi_id(&head->id, ids)) > 0) {', 1]
['* Trouble is, ngx_spawn_process() creates them one-by-one, and we need to', 1]
['ngx_http_script_len_code_pt   lcode;', 1]
['if sub_id == "-" then', 1]
['# Hiredis Makefile', 1]
['info: "The length of time a message may be queued before it is considered expired. If you do not want messages to expire, set this to 0. Applicable only if a nchan_publisher is present in this or a child context."', 1]
['c->err = REDIS_ERR_OTHER;', 1]
['default: "127.0.0.1:6379",', 1]
['static void nchan_publisher_post_request(ngx_http_request_t *r, ngx_str_t *content_type, size_t content_length, ngx_chain_t *request_body_chain, ngx_str_t *channel_id, nchan_loc_conf_t *cf) {', 1]
['head->sub_count -= count;', 1]
['* same function but for zero-terminated strings.', 1]
['assert(self->sub_count > 0);', 1]
['typedef void (redisDisconnectCallback)(const struct redisAsyncContext*, int status);', 1]
['ERR("can\'t create temp upstream handler pool");', 1]
['frame->payload = NULL;', 1]
['test("Format command with %%s and an empty string: ");', 1]
['while(cur <= last && i < NCHAN_MULTITAG_MAX) {', 1]
['time_t                          subscriber_timeout;', 1]
['obj->as.array_size = type_marker & FIXARRAY_SIZE;', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:MULTIPART:" fmt, ##arg)', 1]
['bool cmp_read_integer(cmp_ctx_t *ctx, int64_t *d);', 1]
['redisAsyncCommand(rds_ctx(), &redisChannelInfoCallback, d, "EVALSHA %s 0 %b", store_rds_lua_hashes.find_channel, STR(channel_id));', 1]
['and a reply object (as described above) via `void **reply`. The returned status', 1]
['fakeprocess_top = next;', 1]
['NEGATIVE_FIXNUM_MARKER = 0xE0', 1]
['if(validate_id(r, &id[n_out], cf) != NGX_OK) {', 1]
['DBG("msgid: %V", msgid_to_str(&msg->id));', 1]
['static void dictRelease(dict *ht);', 1]
['--input:  keys: [], values: [channel_id, time, message, content_type, eventsource_event, msg_ttl, max_msg_buf_size]', 1]
['if next(dict) == nil then return nil end', 1]
['subscriber_debug_remove(&fsub->sub);', 1]
['//404!', 1]
['bool cmp_read_nfix(cmp_ctx_t *ctx, int8_t *c);', 1]
['set_buf_to_str(msg_buf, err);', 1]
['"--update channel\\n"', 1]
['return cmp_object_as_ulong(obj, d);', 1]
['/* Command functions for an async context. Write the command to the', 1]
['////////// DELETE ////////////////', 1]
["local ttl = redis.call('TTL', key)", 1]
['nchan_msg_t                    *msg;', 1]
['else if(cf->sub.longpoll) {', 1]
['//edited by slact 2015', 1]
['else if (type_marker == MAP16_MARKER) {', 1]
['nchan_worker_msg_sentinel_t  *ipc; //interprocess stuff', 1]
['ngx_int_t                       workers;', 1]
['ngx_inline void verify_reaper_list(nchan_reaper_t *rp, void *thing) {', 1]
['#define cmp_write_sinteger cmp_write_integer', 1]
['unsigned                   dequeue_after_response:1;', 1]
['static ngx_str_t * nchan_store_content_type_from_message(nchan_msg_t *, ngx_pool_t *);', 1]
['publish_msg= shmsg_link->msg;', 1]
['*cbuf = *buf;', 1]
['* in the context will be set.', 1]
['tc->thing_head = cur;', 1]
['chaninfo = ch->channel;', 1]
['d->name = "get_message (subscribe)";', 1]
['ngx_str_t                       channel_id_split_delimiter;', 1]
['ngx_buf_t     msgbuf;', 1]
['Minitest::Reporters.use! Minitest::Reporters::DefaultReporter.new(color: true)', 1]
['sdsfree(tokens[count]);', 1]
['time_t                msg_time;', 1]
['/* Reads an extended type from the backend */', 1]
['reply = redisCommand(c,"GET nokey");', 1]
['if(create_complex_value_from_ngx_str(cf, &conf->last_message_id.cv[0], &first_choice_msgid) == NGX_CONF_ERROR) {', 1]
['if (len <= 125) {', 1]
['ngx_uint_t           subscribers = 0;', 1]
['rdt.ctx = c;', 1]
['* marker, which is unsupported by MessagePack v4, the version implemented by', 1]
['static void fwd_buf_to_str(ngx_buf_t *buf, size_t sz, ngx_str_t *str) {', 1]
['ngx_atomic_fetch_add(&head->shared->internal_sub_count, head->internal_sub_count);', 1]
['b = &fsub->msg_buf;', 1]
['DBG("%p (%V) destroy", sub, fsub->sub.name);', 1]
['c = redisConnectUnix((char*)"/tmp/idontexist.sock");', 1]
['nchan_channel_t              channel_copy_data;', 1]
['return DICT_OK; /* never fails */', 1]
['str->len=str_in->len;', 1]
['-- delete this channel and all its messages', 1]
['static ngx_int_t spooler_add_subscriber(channel_spooler_t *self, subscriber_t *sub) {', 1]
['ev_io_init(&e->rev,redisLibevReadEvent,c->fd,EV_READ);', 1]
['refute_equal m[0], m[1], "two different messages should have different message ids"', 1]
['/* Create an sds string from a long long value. It is much faster than:', 1]
['if (!connection->read->active && redis_nginx_fd_is_valid(connection->fd)) {', 1]
['void __redisAppendCommand(redisContext *c, char *cmd, size_t len);', 1]
['ids[n].data=cur;', 1]
['static void *nchan_create_loc_conf(ngx_conf_t *cf) {', 1]
['return write_type_marker(ctx, TRUE_MARKER);', 1]
['static void __redisAsyncFree(redisAsyncContext *ac) {', 1]
['memcmp(reply->str,"hello\\x00world",11) == 0)', 1]
['ngx_int_t                       gc_queued_times; // useful for debugging', 1]
['ngx_fd_t     fd = (ngx_fd_t )(uintptr_t )fdv;', 1]
['return select_database(c);', 1]
['static const u_char WEBSOCKET_CLOSE_LAST_FRAME_BYTE = WEBSOCKET_OPCODE_CLOSE | (WEBSOCKET_LAST_FRAME << 4);', 1]
['* the hash will still work, albeit no longer in constant time. */', 1]
['bool cmp_object_is_bool(cmp_object_t *obj) {', 1]
['nchan_msg_buf_open_fd_if_needed(rbuffer, NULL, r);', 1]
['if (obj.type != CMP_TYPE_UINT16) {', 1]
['"    redis.call(\'DEL\', key_msg:format(msg))\\n"', 1]
['are met:', 1]
['static void subscribe_data_free(subscribe_data_t *d) {', 1]
['else if (type_marker == FIXEXT16_MARKER) {', 1]
['return sdsnewlen(init, initlen);', 1]
['} else if (res == 0) {', 1]
["case 'e': case 'E': return 14;", 1]
["assert(pt[str->len]=='>');", 1]
['memstore_ipc_send_delete(slot, channel_id, (callback_pt )delete_multi_callback_handler, d);', 1]
['#include <subscribers/intervalpoll.h>', 1]
['nchan_subscriber [:srv, :loc, :if],', 1]
['assert(d != NULL);', 1]
['#define CHANHEAD_SHARED_OKAY(head) head->status == READY || head->status == STUBBED || (head->use_redis == 1 && head->status == WAITING && head->owner == head->slot)', 1]
['hashed_table=[]', 1]
['for(of = proc->wbuf.overflow_first; of != NULL; of = of_next) {', 1]
['$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< -levent $(STLIBNAME)', 1]
['static ngx_int_t empty_callback(ngx_int_t code, void *ptr, void *d) {', 1]
['ngx_atomic_int_t                   active_workers;', 1]
['/* Initialize read/write events */', 1]
['union nchan_msg_multitag        tag;', 1]
['struct config {', 1]
['int dec, mult = 1;', 1]
['|| lastid->time > req_msgid[i].time', 1]
['chid = &rlch->id;', 1]
['if(ch->churn_time - ngx_time() > 0) {', 1]
['assert(task->type == REDIS_REPLY_ERROR  ||', 1]
['_dst_hh->tbl = (dst)->hh_dst.tbl;                                  \\', 1]
['test_cond("sdstrim() correctly trims characters",', 1]
['newbuf = sdscatlen(r->buf,buf,len);', 1]
['uint32_t      sz;', 1]
['static char *nchan_set_pubsub_channel_id(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['ngx_log_error(NGX_LOG_INFO, c->log, ngx_socket_errno, "push stream module: client closed prematurely connection");', 1]
['* subscribed to one or more channels or patterns. */', 1]
['len = redisFormatCommand(&cmd,"key:%08" fmt " str:%s", value, "hello");               \\', 1]
['"      arg[i]=tostring(arg[i])\\n"', 1]
['lcf->pub.http=0;', 1]
['DBG("get_msg_from_msgkey_callback");', 1]
['//channel info', 1]
['if (v == NULL) {', 1]
['rc = nchan_output_filter(r, NULL);', 1]
['if (c->obuf != NULL)', 1]
['obj->as.ext.size = be32(ext_size);', 1]
['} nchan_auth_subrequest_data_t;', 1]
['setting the `fn` field on the `redisReader` struct. This should be done', 1]
['} else if(strncasecmp(cstr,"monitor\\r\\n",9) == 0) {', 1]
['if String===opt', 1]
['bool cmp_write_str32_marker(cmp_ctx_t *ctx, uint32_t size);', 1]
['lcf->max_messages=NGX_CONF_UNSET;', 1]
['nchan_thing_cache_t *tc;', 1]
['auxentry = *entry;', 1]
['redis_subscriber_register_t *sdata=NULL;', 1]
['if (inq) {', 1]
['c->error = 1;', 1]
['nchan_init_module,             /* init module */', 1]
['ngx_conf_log_error(NGX_LOG_ERR, cf, 0, "unable to allocate space for complex value");', 1]
['int redisAsyncCommandArgv(', 1]
['static ngx_int_t nchan_channel_event(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['static ngx_int_t nchan_store_async_get_multi_message(ngx_str_t *chid, nchan_msg_id_t *msg_id, callback_pt callback, void *privdata) {', 1]
['if(ch->status != INACTIVE) {', 1]
['if (!write_type_marker(ctx, U8_MARKER))', 1]
['if(eventsource_fn == NULL) {', 1]
['_h *= 0x85ebca6b;  \\', 1]
['if(qval_fp == NGX_ERROR) {', 1]
['ht->used = 0;', 1]
['ngx_memzero(&ch, sizeof(ch)); //for debugging basically. should be removed in the future and zeroed as-needed', 1]
['callback_pt                  cb;', 1]
["--  'concurrency' can be 'FIFO', 'FILO', or 'broadcast'", 1]
["hasnext = (p[0] == '$');", 1]
['/* The common way to detect an established connection is to wait for', 1]
['str.each_line do |l|', 1]
['ctx->request_origin_header.data=NULL;', 1]
['nchan_loc_conf_t       *prev = parent, *conf = child;', 1]
['DBG("received unsubscribed request for channel %V privdata %p", d->shm_chid, d->privdata);', 1]
['sds sdsdup(const sds s) {', 1]
['static void redisLibevWriteEvent(EV_P_ ev_io *watcher, int revents) {', 1]
['if (hasnext && strncasecmp(cstr,"subscribe\\r\\n",11) == 0) {', 1]
['nchan_llist_timed_t    *cl;', 1]
['u_char mask_key[4];', 1]
['subscriber_pool_t     *spool;', 1]
['first = ch->msg_first;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS SCRIPT ERROR: %s :%s", (*names)[i], &reply->str[script_error_start.len + REDIS_LUA_HASH_LENGTH + 2]);', 1]
["case '*':", 1]
['//input:  keys: [], values: [channel_id, time, message, content_type, msg_ttl, max_messages]', 1]
['d = subscribe_data_alloc(owner);', 1]
['p->events &= ~UV_WRITABLE;', 1]
['ngx_int_t           getting;', 1]
['--update channel', 1]
['redisContext *redisConnectUnix(const char *path) {', 1]
['ngx_int_t                     i, n = 0;', 1]
['Hiredis only supports the binary-safe Redis protocol, so you can use it with any', 1]
['bc[3].buf.last_in_chain = 1;', 1]
['if(head->sub_count > 0) {', 1]
['//this can and should be optimized later', 1]
['static ngx_int_t spooler_respond_status(channel_spooler_t *self, ngx_int_t code, const ngx_str_t *line) {', 1]
['rdt.cleanup_timer.cancelable = 1;', 1]
['ngx_str_t                     channel_id;', 1]
['static char *nchan_publisher_directive_parse(ngx_conf_t *cf, ngx_command_t *cmd, void *conf, ngx_int_t fail) {', 1]
["/* Connection may be disconnected before being free'd. The second bit", 1]
['redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv);', 1]
['#define HASH_BLOOM_TEST(tbl,hashv) (1)', 1]
['u_char                  boundary[50];', 1]
['ngx_buf_t           *buf=NULL;', 1]
['else { //in a file', 1]
['fsub->sub.request->main->count++; //this is the right way to hold and finalize the request... maybe', 1]
['stype = reply->element[0]->str;', 1]
['return dir;', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:EVENTSOURCE:" fmt, ##arg)', 1]
['msgbuf.pos = msgbuf.start;', 1]
['static void __redisRunCallback(redisAsyncContext *ac, redisCallback *cb, redisReply *reply) {', 1]
['((tbl->num_items & ((tbl->num_buckets*2)-1)) ? 1 : 0);                    \\', 1]
['#include "memstore_ipc.h"', 1]
['ipc_alert(nchan_memstore_get_ipc(), sender, IPC_GET_CHANNEL_INFO_REPLY, d, sizeof(*d));', 1]
['if (ctx->read(ctx, data, 16))', 1]
['ngx_str_t              *shm_chid;', 1]
['event_set(&e->wev,c->fd,EV_WRITE,redisLibeventWriteEvent,e);', 1]
['uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                          \\', 1]
['psr->handler = nchan_publisher_body_authorize_handler;', 1]
['int redisvFormatCommand(char **target, const char *format, va_list ap) {', 1]
['struct spool_collect_overflow_s  *next;', 1]
['subscriber_data_t  data;', 1]
['/* Reset the type because the next item can be anything */', 1]
['buf.memory = 1;', 1]
['ngx_add_timer(&glob->timer, DEBUG_DELAY_IPC_RECEIVE_ALERT_MSEC);', 1]
['nchan_msg_id_t                  oldest_msgid;', 1]
['static void callbackKeyDestructor(void *privdata, void *key) {', 1]
['return newsh->buf;', 1]
['ERR("upstream missing from upstream subrequest");', 1]
['const char *format, ...);', 1]
['{ ngx_string("push_max_reserved_memory"), //legacy for nchan_max_reserved_memory', 1]
['anywhere in an argument:', 1]
['#include <hiredis/hiredis.h>', 1]
['int   i, max = id1->tagcount;', 1]
['removed = 1;', 1]
['_hs_e->prev = ((_hs_tail) ?                                    \\', 1]
['bool cmp_write_str_v4(cmp_ctx_t *ctx, const char *data, uint32_t size) {', 1]
['else if((eventsource_event = nchan_get_header_value(r, NCHAN_HEADER_EVENTSOURCE_EVENT)) != NULL) {', 1]
['int redisContextSetTimeout(redisContext *c, const struct timeval tv);', 1]
['#ifndef __HIREDIS_H', 1]
["//TODO: don't zero the whole thing!", 1]
['static void ipc_read_handler(ngx_event_t *ev) {', 1]
['/* This is the reply object returned by redisCommand() */', 1]
['case \'\\n\': s = sdscatlen(s,"\\\\n",2); break;', 1]
['ipc_writebuf_overflow_t  *of;', 1]
['sts = "????";', 1]
['//ngx_chain_t   *hdr_chain = fsub->hdr_chain;', 1]
['lcf->subscriber_start_at_oldest_message = 1;', 1]
['bool cmp_read_s32(cmp_ctx_t *ctx, int32_t *i);', 1]
['if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1) {', 1]
['#define NGX_HTTP_CONFLICT 409', 1]
['uthash_noexpand_fyi(tbl);                                                \\', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not delete read event to redis");', 1]
['assert(fsub->data.already_responded != 1);', 1]
['typedef void (*subscriber_callback_pt)(subscriber_t *, void *);', 1]
['r->rstack[r->ridx].obj = NULL;', 1]
['bool cmp_write_u8_as_bool(cmp_ctx_t *ctx, uint8_t b);', 1]
['"  msg.prev_tag = lasttag\\n"', 1]
['if (obj.type != CMP_TYPE_SINT8) {', 1]
['cmp_to_str(&cmp, &chid);', 1]
['return ipc;', 1]
['y->tv_sec -= nsec;', 1]
['// static void test_nonblocking_connection() {', 1]
['static ngx_int_t verify_msg_id(nchan_msg_id_t *id1, nchan_msg_id_t *id2, nchan_msg_id_t *msgid) {', 1]
['proc->wbuf.overflow_n = 0;', 1]
['tbl->buckets = _he_new_buckets;                                              \\', 1]
['unsigned ineff_expands, noexpand;', 1]
['static ngx_int_t destroy_spool(subscriber_pool_t *spool) {', 1]
['#ifndef NGX_MAX_INT_T_VALUE', 1]
['"\\"requested\\": %d, "', 1]
['shm_size = 8 * ngx_pagesize;', 1]
['static void *createNilObject(const redisReadTask *task);', 1]
['clcf->handler = handler;', 1]
['str->len = sz;;', 1]
['assert(sd);', 1]
['static ngx_int_t multipart_enqueue(subscriber_t *sub) {', 1]
['static void redisAeCleanup(void *privdata) {', 1]
['ngx_str_t         *tmp;', 1]
['static ngx_int_t chanhead_churner_add(nchan_store_channel_head_t *ch) {', 1]
['head->last_msgid.tag.fixed[0] = msg->id.tag.fixed[0];', 1]
['ERR("can\'t find chanhead for id %V, but it\'s okay.", d->shm_chid);', 1]
['if (cur->type < 0) {', 1]
['sds sdscatprintf(sds s, const char *fmt, ...) {', 1]
['tc->ttl = ttl;', 1]
['&websocket_set_dequeue_callback,', 1]
['int redisFreeKeepFd(redisContext *c) {', 1]
['The function `redisReaderGetReply` creates `redisReply` and makes the function', 1]
['get_msg_from_msgkey(&chid, &msgid, &msg_redis_hash_key);', 1]
['d->code = code;', 1]
['/* Put event loop in the global scope, so it can be explicitly stopped */', 1]
['/* Modify task stack when there are more than 0 elements. */', 1]
['offsetof(nchan_loc_conf_t, storage_engine),', 1]
['if((node = rbtree_find_node(urs, &id)) != NULL) {', 1]
['insq=1;', 1]
['def randid', 1]
['CMP_TYPE_NEGATIVE_FIXNUM  /* 34 */', 1]
['# HIREDIS', 1]
['//nothing to send', 1]
['if(rdt.connected) {', 1]
['"      local ttl = redis.call(\'TTL\', key.next_message)\\n"', 1]
["message=      'channel:msg:%s:'..id, --not finished yet", 1]
['*err = "can\'t allocate multimsg";', 1]
['str_size = obj->as.str_size;', 1]
['* by sdslen(), but only the free buffer space we have. */', 1]
['void                        *privdata;', 1]
['if((node = rbtree_find_node(seed, id)) != NULL) {', 1]
['ngx_memzero(&lcf->last_message_id, sizeof(nchan_complex_value_arr_t));', 1]
['task->type == REDIS_REPLY_STRING);', 1]
['void      (*exit_master)(ngx_cycle_t *cycle);', 1]
['count--;', 1]
['if (obj.type != CMP_TYPE_FIXEXT8) {', 1]
['* command is simply appended to the write buffer.', 1]
['int redisKeepAlive(redisContext *c, int interval) {', 1]
['spooler_channel_status_changed,', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:MEM-IPC:" fmt, ##arg)', 1]
['reply = redisCommand(context, "SET foo %b", value, (size_t) valuelen);', 1]
['if (!done)', 1]
['ngx_str_t                       content_type;', 1]
['entry = dictFind(ht, key);', 1]
['--publish message', 1]
['buf = ngx_palloc(r->pool, sizeof(*buf));', 1]
['#if (NGX_PTR_SIZE == 4)', 1]
['_dictInit(ht,type,privDataPtr);', 1]
['static void receive_subscriber_keepalive(ngx_int_t sender, sub_keepalive_data_t *d) {', 1]
['return sdscatlen(s, t, strlen(t));', 1]
['static ngx_int_t ws_recv(ngx_connection_t *c, ngx_event_t *rev, ngx_buf_t *buf, ssize_t len) {', 1]
['void shm_free(shmem_t *shm, void *p) {', 1]
['if sub_count == 0 then', 1]
['"    num_messages = num_messages + 1\\n"', 1]
['#define REDIS_ERR_IO 1 /* Error in read or write */', 1]
['#define IPC_PUBLISH_STATUS_reply    8', 1]
['redisCallbackList invalid;', 1]
['msg.prev_tag or 0,', 1]
['ngx_conf_log_error(NGX_LOG_INFO, cf, 0, "Using %udKiB of shared memory for nchan", shm_size >> 10);', 1]
['const ngx_str_t NCHAN_CHANNEL_INFO_XML = ngx_string(', 1]
['(head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket) ); \\', 1]
['msg_rsv_dbg_t         *next;', 1]
['static void *createArrayObject(const redisReadTask *task, int elements);', 1]
['shdata->reloading--;', 1]
['ngx_int_t nchan_memstore_force_delete_channel(ngx_str_t *channel_id, callback_pt callback, void *privdata);', 1]
['FIXSTR_MARKER          = 0xA0,', 1]
['if (_hs_e) {                                                   \\', 1]
['if (connect(c->fd, (struct sockaddr*)&sa, sizeof(sa)) == -1) {', 1]
['y->tv_usec += 1000000 * nsec;', 1]
['if((fsub->data.cln = ngx_http_cleanup_add(r, 0)) == NULL) {', 1]
['return params;', 1]
['PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR', 1]
['"    if no_msgid_order == \'FIFO\' then --most recent message\\n"', 1]
['return slot;', 1]
['#define redisReplyReaderSetPrivdata(_r, _p) (int)(((redisReader*)(_r))->privdata = (_p))', 1]
['nchan_subscriber_last_message_id [:srv, :loc, :if],', 1]
['"1c8ae4fa9658ca36790227fa2f8e0e4342ca82d2",', 1]
['obj->as.ext.size = 8;', 1]
['test_invalid_timeout_errors(cfg);', 1]
['subscriber_t *memstore_multi_subscriber_create(nchan_store_channel_head_t *chanhead, uint8_t n);', 1]
['nchan_buf_and_chain_t     *cb;', 1]
['entry->val = (ht)->type->valDup((ht)->privdata, _val_); \\', 1]
['redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {', 1]
['_hs_looping = 1;                                                           \\', 1]
['for(i=0; i < newid->tagcount; i++) {', 1]
['"    key.next_message=key.next_message:format(msg.next)\\n"', 1]
['INTEGER_WIDTH_TEST("lld", long long);', 1]
['&longpoll_dequeue,', 1]
['bool cmp_write_str16_marker(cmp_ctx_t *ctx, uint16_t size) {', 1]
['#define HTTP_CHUNKED_STRINGS "chunked", "http-chunked"', 1]
['* length is the essence of how a hash provides constant time lookup.', 1]
['#define IPC_TEST_FLOOD                 30', 1]
['table.remove(ch, 4)', 1]
['} delayed_alert_glob_t;', 1]
['if (sr->method == NGX_HTTP_HEAD) {', 1]
['* context, it will return unconsumed replies until there are no more. */', 1]
['nchan_ignore_subscriber_concurrency,', 1]
['nchan_msg_id_t              prev_msg_id;', 1]
['bool cmp_write_fixext16_marker(cmp_ctx_t *ctx, int8_t type);', 1]
['sds sdscpylen(sds s, const char *t, size_t len);', 1]
['int16_t       *oldtags, *old_largetags = NULL;', 1]
['* route could be: Use IPv6 if both addresses are available and there is IPv6', 1]
['test("%%s String interpolation works: ");', 1]
['if(cond) {                                          \\', 1]
['returned on calls to the `redisAsyncCommand` family.', 1]
['ngx_int_t nchan_output_filter(ngx_http_request_t *r, ngx_chain_t *in);', 1]
['ngx_int_t              (*set_dequeue_callback)(subscriber_t *self, subscriber_callback_pt cb, void *privdata);', 1]
['ngx_pool_t             *pool;', 1]
['struct ipc_writebuf_s {', 1]
['publish m', 1]
['ssub->dequeue_callback_data.spool = self;', 1]
['uint8_t   max = id->tagcount;', 1]
['len = redisFormatCommandArgv(&cmd,argc,argv,lens);', 1]
['[IPC_SUBSCRIBE_REPLY] =             (ipc_handler_pt )receive_subscribe_reply,', 1]
['dbg(("found msg2 %i:%i  after %i:%i"):format(ntime, ntag, time, tag))', 1]
['ngx_add_timer(&data->timeout_ev, MEMSTORE_IPC_SUBSCRIBER_TIMEOUT * 1000);', 1]
['"--output: msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, channel_subscriber_count\\n"', 1]
['#define IPC_DELETE_REPLY            12', 1]
['int on = 1;', 1]
['self->name = name;', 1]
['unsigned num_items;', 1]
['int       i = -1, j, max = id2->tagcount;', 1]
['u_char                        *cbuf;', 1]
['"dbg(\' #######  PUBLISH   ######## \')\\n"', 1]
['static void redisLibevDelWrite(void *privdata) {', 1]
['{ ngx_string("nchan_channel_id_split_delimiter"),', 1]
['nchan_llist_timed_t   *cur;', 1]
['else if((msg->id.time == d->msg->id.time && msg->id.tag.fixed[0] <  d->msg->id.tag.fixed[0])', 1]
['rbtree_remove_node(&spl->spoolseed, node);', 1]
['"local exists = false\\n"', 1]
['mpt = &mdata[(ngx_int_t )fakeprocess_top->data];', 1]
['else if(nchan_strmatch(val, 1, "newest")) {', 1]
['b->pos = b->start;', 1]
['nchan_loc_conf_t    *cf = ngx_http_get_module_loc_conf(r->parent, nchan_module);', 1]
['if (!ngx_exiting && rp->count > 0 && !rp->timer.timer_set) {', 1]
["return redis.call('HMSET', key, unpack(bulk))", 1]
['node->left = sentinel;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, ngx_errno, "Redis store: Couldn\'t mmap file %V", &buf->file->name);', 1]
['ngx_buf_t            *b;', 1]
['if(unid.tag[i] == -1)     msg->id.tag[i]   =    self->id.tag[i];', 1]
['push_min_message_buffer_length [:srv, :loc, :if],', 1]
['start_spooler(&head->spooler, &head->id, &head->status, &nchan_store_redis);', 1]
['for(_sx_i=0; _sx_i < keylen; _sx_i++)                                          \\', 1]
['local next_msg, next_msgtime, next_msgtag', 1]
['msg->id.time = tv.tv_sec;', 1]
['tbl->noexpand=1;                                                         \\', 1]
['* You can print the string with printf() as there is an implicit \\0 at the', 1]
['bool cmp_read_bool_as_u8(cmp_ctx_t *ctx, uint8_t *b) {', 1]
['"  --not efficient, but useful for a few short-term subscriptions\\n"', 1]
['} else if (argc >= 1 && !strcmp(argv[0],"--skip-throughput")) {', 1]
['time_t                          gc_time;', 1]
['#define _OSX', 1]
['iter->index = -1;', 1]
['ret = redisvAppendCommand(c,format,ap);', 1]
["if (buf[buflen-2] != '\\0') {", 1]
['if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {', 1]
['char              *name;', 1]
['if (r->len == 0 && r->maxbuf != 0 && sdsavail(r->buf) > r->maxbuf) {', 1]
['} while(fcur < flast);', 1]
['}; //store_message_t', 1]
['spooled_subscriber_t *cur;', 1]
['urnode->id.len = id.len;', 1]
['test_cond (reply->type == REDIS_REPLY_STATUS &&', 1]
['p->events |= UV_WRITABLE;', 1]
['ngx_memcpy(msg, m, sizeof(*msg));', 1]
['{ "xml"   , 3, &NCHAN_CHANNEL_INFO_XML  },', 1]
['msg.id.tagcount=1;', 1]
['left = node->left;', 1]
['return ctx->write(ctx, &i, sizeof(uint32_t));', 1]
['assert(rp->count > 0 && rp->last != NULL);', 1]
['case 500:', 1]
['* This version of the function is binary-safe but', 1]
['DBG("nomulti (lastid), want %i", i);', 1]
['1, //deque after response', 1]
['bc[1].chain.next = ngx_buf_size(msg_buf) > 0 ? &bc[2].chain : &bc[3].chain;', 1]
['if (wev->timer_set) {', 1]
['status = redisvAsyncCommand(ac,fn,privdata,format,ap);', 1]
['static void fake_ipc_alert_delay_handler(ngx_event_t *ev) {', 1]
['check: hiredis-test', 1]
['spl->chid = chid;', 1]
['redisContext *redisConnectNonBlock(const char *ip, int port) {', 1]
['DBG("free shm_str %V @ %p", str, str->data);', 1]
['static ngx_int_t nchan_memstore_store_msg_ready_to_reap(store_message_t *smsg, uint8_t force) {', 1]
['} nchan_thing_cache_t;', 1]
['nnext = nsub->next;', 1]
['bool cmp_read_sfix(cmp_ctx_t *ctx, int8_t *c) {', 1]
['unsigned                        http:1;', 1]
['*i = obj.as.s16;', 1]
['} while(v);', 1]
['size = va_arg(ap,size_t);', 1]
['callback(seed, rbtree_data_from_node(node), data);', 1]
['bool cmp_object_as_bin(cmp_object_t *obj, uint32_t *size) {', 1]
['test("Works when a single newline (\\\\r\\\\n) covers two calls to feed: ");', 1]
['tc->name = name;', 1]
['msg.content_type or "",', 1]
['void redisReaderFree(redisReader *r);', 1]
['static const ngx_str_t    STATUS_410=ngx_string("410 Channel Deleted");', 1]
['bool cmp_object_as_short(cmp_object_t *obj, int16_t *s);', 1]
['bool cmp_read_u64(cmp_ctx_t *ctx, uint64_t *l) {', 1]
['//qval=0. reject', 1]
['if(len > maxlen) {', 1]
['@@redis=Redis.new(:host => REDIS_HOST, :port => REDIS_PORT, :db => REDIS_DB)', 1]
['spooled_subscriber_t   *prev, *next;', 1]
['rdt.sub_ctx = NULL;', 1]
['redis_subscribe_data_t       *d = NULL;', 1]
['static int __redisAsyncHandleConnect(redisAsyncContext *ac) {', 1]
['len = readLongLong(p);', 1]
['int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen);', 1]
['local exists = false', 1]
['else if(data->n > 0) {', 1]
['sub->fn->respond_status(sub, status_code, status_line);', 1]
['};// nchan_loc_conf_t;', 1]
['* ... check for nread <= 0 and handle it ...', 1]
['static void nchan_exit_worker(ngx_cycle_t *cycle) {', 1]
['/* No callback for this reply. This can either be a NULL callback,', 1]
['rbtree_remove_node(&spl->spoolseed, rbtree_node_from_data(spool));', 1]
['static ngx_int_t delete_callback_handler(ngx_int_t code, nchan_channel_t *chan, delete_data_t *d) {', 1]
['DBG("%p (%V) enqueue", self, fsub->sub.name);', 1]
['.PHONY: all test check clean dep install 32bit gprof gcov noopt', 1]
['memset((tbl)->bloom_bv, 0, HASH_BLOOM_BYTELEN);                                \\', 1]
['for (p = servinfo; p != NULL; p = p->ai_next) {', 1]
['THING_HASH_ADD(tc, thing);', 1]
['content_type = (sr->upstream->headers_in.content_type ? &sr->upstream->headers_in.content_type->value : NULL);', 1]
['static const ngx_str_t script_error_start= ngx_string("ERR Error running script (call to f_");', 1]
['ngx_str_t    alerttype;', 1]
['if (vv == NULL || vv->not_found || vv->len == 0) {', 1]
['static ngx_buf_t *ensure_last_buf(ngx_pool_t *pool, ngx_buf_t *buf) {', 1]
['internal_subscriber_t               *fsub = (internal_subscriber_t *)sub;', 1]
['ngx_shmtx_unlock(&SHPOOL(shm)->mutex);', 1]
['ngx_add_timer(&fsub->ping_ev, fsub->sub.cf->websocket_ping_interval * 1000);', 1]
['ngx_file_t                     *file;', 1]
['break unless cmt', 1]
['static uint32_t be32(uint32_t x) {', 1]
['/* Calculate number of bytes needed for the command */', 1]
['/* Reads packed binary data from the backend */', 1]
['if(wb->overflow_first == NULL) {', 1]
['evcf->buffer_timeout = 10;', 1]
['/* In a blocking context, this function first checks if there are unconsumed', 1]
['"last requested: %d sec. ago" CRLF', 1]
['recycloc_llist_s *head;', 1]
['extern const ngx_str_t NCHAN_CHANNEL_INFO_XML;', 1]
['lcf->channel_event_string = NULL;', 1]
['//"<msg_time>:<msg_tag>"', 1]
['d->msg = msg;', 1]
['ngx_http_complex_value_t  *authorize_request_url_ccv = sub->cf->authorize_request_url;', 1]
['hashv += (hashv << 15);                                                        \\', 1]
['if((etag = ngx_palloc(r->pool, sizeof(*etag) + tmp_etag->len))==NULL) {', 1]
['following constants:', 1]
['return "";', 1]
['sdsrange(y,-2,-1);', 1]
['static ngx_int_t create_dataline_bufchain(ngx_pool_t *pool, ngx_chain_t **first_chain, ngx_chain_t **last_chain, ngx_buf_t *databuf) {', 1]
['fakebody_chain->next = NULL;', 1]
['//publisher and subscriber handlers now.', 1]
['r->headers_out.content_type.data = content_type.data;', 1]
['ngx_conf_merge_bitmask_value(conf->sub.http_chunked, prev->sub.http_chunked, 0);', 1]
['sds sdsfromlonglong(long long value);', 1]
['psr_stuff->psr_data.fsub = fsub;', 1]
['ipc_t *nchan_memstore_get_ipc(void);', 1]
['if(nchan_strmatch(val, 1, "http")) {', 1]
['static void dictRelease(dict *ht) {', 1]
['tbl->nonideal_items = 0;                                                     \\', 1]
['} delete_data_t;', 1]
['len = redisFormatCommand(&cmd,"SET %s %s","foo","");', 1]
['//we\'re looking at  "chunkedsomething", not "chunked;q=<...>". reject.', 1]
['newsh = realloc(sh, sizeof *newsh+newlen+1);', 1]
['#define UTHASH_H', 1]
['d->chanhead->status = READY;', 1]
[':nchan_subscriber_directive,', 1]
['ngx_memcpy(cbuf->pos, buf->pos, ngx_buf_size(buf));', 1]
['ngx_str_t              name = ngx_string("memstore");', 1]
['cur += group.len;', 1]
['size_t initlen = (init == NULL) ? 0 : strlen(init);', 1]
['ngx_log_error(NGX_LOG_WARN, r->connection->log, 0, "nchan: channel id is too long: should be at most %i, is %i.", cf->max_channel_id_length, id->len);', 1]
["/* Free an sds string. No operation is performed if 's' is NULL. */", 1]
['if(ch != NULL) {', 1]
['ERR("got IPC alert delayed by %i sec", ngx_time() - glob->alert.time_sent);', 1]
['bc[0].buf.pos = chunk_start;', 1]
['ngx_http_complex_value(r, publisher_upstream_request_url_ccv, &psr_stuff->psr_data.upstream_request_url);', 1]
['typedef struct recycloc_s recycloc_t;', 1]
['t2 = tags2[active];', 1]
['if(old_shared) {', 1]
['ngx_str_t *nchan_request_multipart_boundary(ngx_http_request_t *r, nchan_request_ctx_t *ctx);', 1]
['nchan_store_channel_head_t      *subhash;', 1]
["if redis.call('EXISTS', key.message) ~= 0 then", 1]
['shmem_t *shm_create(ngx_str_t *name, ngx_conf_t *cf, size_t shm_size, ngx_int_t (*init)(ngx_shm_zone_t *, void *), void *privdata) {', 1]
['ipc_t *nchan_memstore_get_ipc(void){', 1]
['buf->end = start + len;', 1]
['void (*addRead)(void *privdata);', 1]
['ngx_int_t                    channel_owner;', 1]
['[:loc_conf, :channel_timeout],', 1]
['#define HASH_FIND_STR(head,findstr,out)                                          \\', 1]
['subscriber_t *memstore_redis_subscriber_create(nchan_store_channel_head_t *chanhead);', 1]
['conf->authorize_request_url = prev->authorize_request_url;', 1]
['if (ngx_strcasecmp(val[1].data, (u_char *) "off") == 0) {', 1]
['ngx_err_t           err;', 1]
['node = node->right;', 1]
['* of sds is returned.', 1]
['ngx_http_complex_value_t       *cv[NCHAN_COMPLEX_VALUE_ARRAY_MAX];', 1]
['out=sprintf cout, struct.join("\\n"), hashed_table.join(",\\n"), Digest::SHA1.hexdigest("foo").length, name_table.join("\\n"), script_table.join(",\\n\\n")', 1]
['hashv = _mur_h1;                                                     \\', 1]
['proc->c=NULL;', 1]
['nchan_store_channel_head_t     *hash;', 1]
['int redisReaderGetReply(redisReader *r, void **reply);', 1]
['ipc_alert_t         alert = {0};', 1]
['ngx_add_event(c->read, NGX_READ_EVENT, 0);', 1]
['"</channel>"', 1]
['case 126:', 1]
['assert(sub->last_msgid.tagcount == 1);', 1]
['*multipart_fn = *sub->fn;', 1]
['uint32_t high_part = htonl((uint32_t)(value >> 32));', 1]
['static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {', 1]
['#include <stddef.h>', 1]
['#define DEBUG_NGX_RWLOCK 1', 1]
['info: "Send GET request to internal location (which may proxy to an upstream server) for authorization of a publisher or subscriber request. A 200 response authorizes the request, a 403 response forbids it."', 1]
['nchan_complex_value_arr_t          *chid_conf;', 1]
['sub->type = HTTP_MULTIPART;', 1]
['unsigned num_buckets, log2_num_buckets;', 1]
['sds *tokens;', 1]
['if (r->pos >= 1024) {', 1]
['ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED', 1]
['assert(proc->pipe[1] != NGX_INVALID_FILE);', 1]
['buf = malloc(buflen);', 1]
['/* For clean disconnects, there should be no pending callbacks. */', 1]
['CRLF', 1]
['SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED', 1]
['case WEBSOCKET_READ_GET_PAYLOAD_STEP:', 1]
['r->headers_out.status=NGX_HTTP_INTERNAL_SERVER_ERROR;', 1]
['str.data= (u_char *)"{not in memory}";', 1]
['if(msgid == NULL) {', 1]
['ngx_delete_file(f->name.data); // assumes string is zero-terminated, which required trickery during allocation', 1]
['c->data = ipc;', 1]
['len = redisFormatCommand(&cmd,"SET %b %b","foo",(size_t)3,"",(size_t)0);', 1]
['if(last_chain) {', 1]
['head=ngx_alloc(sizeof(*head) + sizeof(u_char)*(channel_id->len), ngx_cycle->log);', 1]
['raise stdouterr.read unless process.value.success?', 1]
['assert(array_sz == 10);', 1]
['After calling either function one or more times, `redisGetReply` can be used to receive the', 1]
['for (j = 0; j < reply->elements; j++) {', 1]
['ngx_http_request_t  *r = fsub->sub.request;', 1]
['sent << Msg.new(id, data: w, ttl: 100)', 1]
['void *internal_subscriber_get_privdata(subscriber_t *sub);', 1]
['char *cur;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: AUTH command failed, probably because the password is incorrect");', 1]
['ipc_alert(nchan_memstore_get_ipc(), d->sender, IPC_DELETE_REPLY, d, sizeof(*d));', 1]
['redis_connect_params_t  *params;', 1]
['for (i = 0; /* void */; i++) {', 1]
['b -= c; b -= a; b ^= ( a << 10 );                                              \\', 1]
['#endif  /* HASH_USING_NO_STRICT_ALIASING */', 1]
['/* Allocates the memory and stores key */', 1]
['src++;', 1]
[':                     Payload Data continued ...                :', 1]
['DBG("stopped reaper %s", rp->name);', 1]
['"--set expiration times for all the things\\n"', 1]
['_he_thh->hh_prev = NULL;                                              \\', 1]
['if((rc = nchan_respond_msg(r, fsub->data.multimsg_first->msg, &fsub->sub.last_msgid, 0, &err)) != NGX_OK) {', 1]
['#include <adapters/libev.h>', 1]
['ngx_int_t           ws_version;', 1]
['#include <ngx_event.h>', 1]
['/* Writes true to the backend */', 1]
['fakeprocess_top->prev = link;', 1]
['case 403: //channel not found', 1]
["if (*_p != '\\0' && *_p == '#') _p++;", 1]
['tags_latest[i] = 0;', 1]
['ngx_str_t             ids[NCHAN_MULTITAG_MAX];', 1]
['fakebody_buf->end = fakebody_buf->start + sz;', 1]
['nchan_msg_t       *msg = (nchan_msg_t *) ptr;', 1]
['#include "../../subscribers/memstore_ipc.h"', 1]
['self->add_handler_privdata = privdata;', 1]
['ngx_int_t              i;', 1]
['fsub->cln = NULL;', 1]
['ngx_int_t nchan_OPTIONS_respond(ngx_http_request_t *r, const ngx_str_t *allow_origin, const ngx_str_t *allowed_headers, const ngx_str_t *allowed_methods);', 1]
["case 't': c = '\\t'; break;", 1]
['nchan_reaper_stop(&mpt->msg_reaper);', 1]
['cbuf->pos = (u_char *) (cbuf+1);', 1]
['HIREDIS_MINOR=11', 1]
['//         usleep(500);', 1]
['if(!file) {', 1]
['HASH_BLOOM_BITSET((tbl)->bloom_bv, (hashv & (uint32_t)((1ULL << (tbl)->bloom_nbits) - 1)))', 1]
['head->multi = multi;', 1]
['typedef enum {RBTREE_WALK_LEFT, RBTREE_WALK_RIGHT, RBTREE_WALK_LEFT_RIGHT, RBTREE_WALK_STOP} rbtree_walk_direction_t;', 1]
['nchan_copy_new_msg_id(&d->wanted_msgid, msg_id);', 1]
['if(tags2[i] != -1 && tags1[i] != tags2[i]) {', 1]
['"if exists or (not exists and num > 0) then\\n"', 1]
['if(msg->refcount < 0) {', 1]
['static rdstore_data_t        rdt;', 1]
['case CHAN_PUBLISH:', 1]
['nchan_loc_conf_t  *cf = sub->cf;', 1]
['h=@@redis.script :load, script', 1]
['if(urs == NULL) {', 1]
['bc[1].buf.memory = 1;', 1]
['*    -1 if s1 < s2.', 1]
['last = url->data + url->len;', 1]
['if(chanhead->status == INACTIVE) {', 1]
['*buf->file = *mbuf->file;', 1]
['void *redisContext = NULL;', 1]
['fsub->finalize_request = 0;', 1]
['//content_length = 0;', 1]
['DBG("fetchmsg callback for spool %p msg EXPECTED", spool);', 1]
['if(fsub->shook_hands == 0) {', 1]
['lcf->msg_in_etag_only = NGX_CONF_UNSET;', 1]
['rbuffer = &cb->buf;', 1]
['hashv += _ho_key[_ho_i];                                                   \\', 1]
['reply = redisCommand(c,"DBSIZE");', 1]
['msg->rsv->prev = rsv;', 1]
['redis_get_message_from_key_data_t   *d;', 1]
['ngx_int_t       rc;', 1]
['int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {', 1]
['ngx_int_t memstore_ipc_send_delete(ngx_int_t owner, ngx_str_t *shm_chid, callback_pt callback, void *privdata);', 1]
['spl->channel_status = channel_status;', 1]
['DBG("IPC: send delete to %i ch %V", dst, chid);', 1]
['bool cmp_object_is_ushort(cmp_object_t *obj) {', 1]
['fsub->data.holding = 0;', 1]
['fsub->timeout_handler_data = NULL;', 1]
['dummy_config_ptr = &dummy_config;', 1]
['static void redisLibuvDelRead(void *privdata) {', 1]
['&websocket_set_timeout_callback,', 1]
['//is this a missed message, or just a multi msg?', 1]
['#define THING_HASH_FIND(tc, id_str, p)    HASH_FIND( hh, tc->things, (id_str)->data, (id_str)->len, p)', 1]
['ngx_int_t     db;', 1]
['ngx_int_t              (*respond_message)(struct subscriber_s *, nchan_msg_t *);', 1]
['typedef struct cmp_ext_s {', 1]
['hashv += hashv >> 6;                                                         \\', 1]
['int l1, l2;', 1]
['if (d >= -128)', 1]
['"--publish message\\n"', 1]
['if (ht->table[i] == NULL) continue;', 1]
['is_hex_digit(*(p+2)) &&', 1]
['ngx_file_t              msg_file;', 1]
['d->callback(MSG_FOUND, msg, d->privdata);', 1]
['else if(nchan_strmatch(val, EVENTSOURCE_STRINGS_N, EVENTSOURCE_STRINGS)) {', 1]
['join = sdscatsds(join, argv[j]);', 1]
['else if(nchan_strmatch(val, INTERVALPOLL_STRINGS_N, INTERVALPOLL_STRINGS)) {', 1]
['switch(redis_array_to_channel(reply, &channel)) {', 1]
['time_t                          churn_time;', 1]
['the stateless 0.0.1 that only has a file descriptor to work with.', 1]
["if(c == '-') {", 1]
['static void redisPublishCallback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['if((bc = ngx_palloc(pool, sizeof(*bc)*2)) == NULL) {', 1]
['unsigned                holding:1;', 1]
['static void * ngx_store_alloc(size_t size) {', 1]
['static void receive_subscribe_reply(ngx_int_t sender, subscribe_data_t *d) {', 1]
['There are several ways to issue commands to Redis. The first that will be introduced is', 1]
['msgstart = NULL;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS_REPLY_STRING: %s", reply->str);', 1]
['if(ngx_buf_size(buffer) > 0) {', 1]
['rdt.chanhead_cleanup_tail=NULL;', 1]
['value: "<time>",', 1]
['static void spool_sub_dequeue_callback(subscriber_t *sub, void *data) {', 1]
['size_t                 size = 0;', 1]
['"  redis.call(\'PUBLISH\', pubsub, del_msgpack)\\n"', 1]
['default: "1h",', 1]
['fsub->data.dequeue_handler = empty_handler;', 1]
['char buf[32], *p;', 1]
['"local nearly_departed = nil\\n"', 1]
['* the hash keeps a bound on the chain length. This bounded chain', 1]
['struct timeval          tv, diff;', 1]
["local ch = redis.call('hmget', key_channel, 'ttl', 'time_last_seen', 'subscribers', 'fake_subscribers')", 1]
['level language bindings.', 1]
['if(ngx_strmatch(&msg_type, "msg")) {', 1]
['bool cmp_write_str8_marker(cmp_ctx_t *ctx, uint8_t size) {', 1]
['d->getting = n;', 1]
['cb.privdata = privdata;', 1]
['msg->content_type.len=content_type_len;', 1]
['static int dictDelete(dict *ht, const void *key) {', 1]
['extern ngx_pool_t *nchan_pool;', 1]
['static ngx_int_t spooler_spool_dequeue_all(rbtree_seed_t *seed, subscriber_pool_t *spool, void *data) {', 1]
['2. The input buffer is empty:', 1]
['seed->actives[i]=node;', 1]
['redisReply *reply=r;', 1]
['return x->tv_sec < y->tv_sec;', 1]
['shdata->old_max_workers = NGX_CONF_UNSET;', 1]
['//assert(cur->msg->id.tagcount == 1);', 1]
['void                        *redis_subscriber_privdata;', 1]
['callback_pt         cb;', 1]
['id(arg[:id]) if arg[:id]', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS_REPLY_ERROR: %s", reply->str);', 1]
['_hs_p = _hs_list;                                                      \\', 1]
['* **`REDIS_REPLY_INTEGER`**:', 1]
["The context object is always free'd after the disconnect callback fired. When a reconnect is needed,", 1]
['for(i=0; i<sizeof(store_rds_lua_scripts)/sizeof(char*); i++) {', 1]
['uint8_t                         multi_count;', 1]
['chaninfo_copy.last_seen = ch->shared->last_seen;', 1]
['"publish_status",', 1]
['redisAsyncContext *redisAsyncConnectBind(const char *ip, int port,', 1]
['sdslen(y) == 1 && memcmp(y,"i\\0",2) == 0)', 1]
['/* When an error occurs, the err flag in a context is set to hold the type of', 1]
['*count = elements;', 1]
["if((split = ngx_strlchr(str->data, last, ':')) != NULL) {", 1]
['unit = (u_char *) "KB";', 1]
['if(params->port == NGX_ERROR) {', 1]
['time_t      timmin = data->min.time, timmax = data->max.time, timcur = spool->id.time;', 1]
['if(f->fd != NGX_INVALID_FILE) {', 1]
['#include "subscribers/websocket.h"', 1]
['subt->longpoll=0;', 1]
['static dictEntry *dictFind(dict *ht, const void *key) {', 1]
['time_t          time_sent;', 1]
['*     1 if s1 > s2.', 1]
['//lame content-negotiation (without regard for qvalues)', 1]
['nchan_store_t  nchan_store_memory = {', 1]
['sds sdsjoin(char **argv, int argc, char *sep, size_t seplen) {', 1]
['bool cmp_write_fixext4(cmp_ctx_t *ctx, int8_t type, const void *data);', 1]
['test_cond("sdsnew() free/len buffers", sh->len == 1 && sh->free == 0);', 1]
['ngx_add_timer(&rp->timer, rp->tick_usec);', 1]
['if ((out)->hh.hh_next) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,(out)->hh.hh_next)); \\', 1]
['const  ngx_str_t NCHAN_HTTP_STATUS_409 = ngx_string("409 Conflict");', 1]
['#define redisReplyReaderGetError(_r) (((redisReader*)(_r))->errstr)', 1]
['ngx_int_t         mcount;', 1]
['*u = obj.as.u64;', 1]
['assert(head->internal_sub_count >= 0);', 1]
['/* Append to the sds string "s" an escaped string representation where', 1]
['ngx_int_t nchan_store_chanhead_publish_message_generic(nchan_store_channel_head_t *chead, nchan_msg_t *msg, ngx_int_t msg_in_shm, nchan_loc_conf_t *cf, callback_pt callback, void *privdata) {', 1]
['/* summary line */', 1]
['INTEGER_WIDTH_TEST("ld", long);', 1]
['"dbg((\\"Stored message with id %i:%i => %s\\"):format(msg.time, msg.tag, msg.data))\\n"', 1]
['//Vary header needed for proper HTTP caching.', 1]
['extern const ngx_str_t NCHAN_HEADER_ALLOW_ORIGIN;', 1]
['if((cbuf = ngx_palloc(r->pool, sizeof(u_char)*100)) == NULL) {', 1]
['redis_nginx_read_event(ngx_event_t *ev)', 1]
['bool cmp_object_as_ext(cmp_object_t *obj, int8_t *type, uint32_t *size) {', 1]
['ch->in_gc_queue = 0;', 1]
['data.msg_timeout = cf->buffer_timeout;', 1]
['* might not have a trailing NULL character. */', 1]
['hashv ^= hashv << 3;                                                         \\', 1]
['//TODO: be smarter about garbage-collecting chanheads', 1]
['//and maybe the event type?', 1]
['static void redisLibeventCleanup(void *privdata) {', 1]
['spool->msg_status = MSG_CHANNEL_NOTREADY;', 1]
['DBG("found node %p", found);', 1]
['_he_newbkt = &(_he_new_buckets[ _he_bkt ]);                           \\', 1]
['#if (FAKESHARD)', 1]
['bool cmp_read_char(cmp_ctx_t *ctx, int8_t *c) {', 1]
['if (ctx->read(ctx, data, 4))', 1]
['data->spooler = spool->spooler;', 1]
['ngx_int_t nchan_cleverly_output_headers_only_for_later_response(ngx_http_request_t *r) {', 1]
['#define NGX_HTTP_BUF_ALLOC_SIZE(buf)                                         \\', 1]
['DBG("%p (%V) memstore subscriber respond with status", d->sub, d->chid);', 1]
['{                                                                            \\', 1]
['/* Emit a reply when there is one. */', 1]
['clen -= pvariant;', 1]
['r->connection->data = r;', 1]
['if(c->flags & REDIS_MONITORING) {', 1]
['case \'\\a\': len = snprintf(buf,size,"\\"\\\\a\\""); break;', 1]
['ch[i]=tonumber(ch[i]) or 0', 1]
['//we prefer to subscribe', 1]
['unsigned _count, _bkt_count;                                                 \\', 1]
['INTERNAL,', 1]
['"    table.insert(bulk, k)\\n"', 1]
['subscriber_pool_t       *spool;', 1]
['if((origin_header = nchan_get_header_value(r, NCHAN_HEADER_ORIGIN)) != NULL) {', 1]
['ngx_memcpy(msg->eventsource_event.data, els[offset+7]->str, es_event_len);', 1]
['exists = true', 1]
['### Customizing replies', 1]
['dst->tag.allocd = largetags;', 1]
['assert_equal cur, n', 1]
['tags1 = (id1->tagcount <= NCHAN_FIXED_MULTITAG_MAX) ? id1->tag.fixed : id1->tag.allocd;', 1]
['void *(*createArray)(const redisReadTask*, int);', 1]
['#define HASH_BLOOM_ADD(tbl,hashv)                                                \\', 1]
['bool cmp_write_ext_marker(cmp_ctx_t *ctx, int8_t tp, uint32_t sz) {', 1]
['char *publish;', 1]
['ngx_int_t (*subscribe)   (ngx_str_t *, subscriber_t *);', 1]
['void redisAsyncFree(redisAsyncContext *ac) {', 1]
['free(iter);', 1]
['const subscriber_fn_t     *fn;', 1]
['ngx_int_t nchan_create_websocket_publisher(ngx_http_request_t  *r);', 1]
['a -= b; a -= c; a ^= ( c >> 13 );                                              \\', 1]
['(MUR_PLUS2_ALIGNED(p) ? MUR_TWO_TWO(p) :  \\', 1]
['//redis_channel_head_cleanup_t *hcln;', 1]
['rbtree_walk(&self->spoolseed, callback, NULL);', 1]
['frame->rsv3 = (frame->header[0] >> 4) & 1;', 1]
['to endorse or promote products derived from this software without specific', 1]
['#define IPC_UNSUBSCRIBE             3  //NOT USED', 1]
['ngx_int_t memstore_ensure_chanhead_is_ready(nchan_store_channel_head_t *head, uint8_t ipc_subscribe_if_needed) {', 1]
['field in the context can be accessed to find out the cause of the error.', 1]
['"<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" ?>" CRLF', 1]
['return processBulkItem(r);', 1]
['cur->time = ngx_time() + tc->ttl;', 1]
['It has the following prototype:', 1]
['static nchan_llist_timed_t   *nchan_ws_llist_enqueue(subscriber_t *sub) {', 1]
['sds sdscatvprintf(sds s, const char *fmt, va_list ap);', 1]
['(head)->hh.tbl->hho)) : NULL);                   \\', 1]
['*size = obj->as.str_size;', 1]
['UT_hash_handle     hh;', 1]
['/* Reset task stack. */', 1]
['DBG("Do not want %i", i);', 1]
['if (ac == NULL)', 1]
['"  if concurrency == \\"FIFO\\" then\\n"', 1]
['//ERR("id1 is larger. 1");', 1]
['if(head->multi[i].sub == NULL) {', 1]
['to the `redisCommand` family, apart from not returning a reply:', 1]
['if (ctx->write(ctx, data, 1))', 1]
['void __redisSetError(redisContext *c, int type, const char *str);', 1]
['ch_id=msg', 1]
['/hiredis-test', 1]
['if(spool == NULL || newspool == NULL) {', 1]
['{ ngx_string("nchan_pubsub"),', 1]
['case SUB_CHANNEL_UNAUTHORIZED:', 1]
["// \xe2\x99\xab It's gonna be the future soon \xe2\x99\xab", 1]
['return r->headers_out.status ? NGX_OK : NGX_HTTP_INTERNAL_SERVER_ERROR;', 1]
['static void websocket_reading(ngx_http_request_t *r);', 1]
['ngx_http_finalize_request(r->parent, NGX_HTTP_INTERNAL_SERVER_ERROR);', 1]
['nuspool = get_spool(spool->spooler, &anymsg);', 1]
[']]', 1]
['ERR("nchan: unexpected msgpack object from redis");', 1]
['if (len == 0) {', 1]
['"  arg[i]=tostring(arg[i])\\n"', 1]
['/* Copy va_list before consuming with va_arg */', 1]
['#define IPC_PUBLISH_MESSAGE         5', 1]
['static char *nchan_subscriber_first_message_directive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['#ifndef __HIREDIS_FMACRO_H', 1]
['ngx_module_t     nchan_module;', 1]
['if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK)', 1]
['cur->prev->next = next;', 1]
['ngx_http_variable_value_t  *vv = NULL;', 1]
['/* Default target pointer to NULL. */', 1]
['#define WEBSOCKET_LAST_FRAME                0x8', 1]
['#define CHANNEL_HASH_DEL(chanhead)      HASH_DEL( rdt.subhash, chanhead)', 1]
['c->err = type;', 1]
["case '\\t':", 1]
['port $(REDIS_PORT)', 1]
['ngx_int_t            (*add)(channel_spooler_t *self, subscriber_t *sub);', 1]
['if(shdata->old_max_workers != shdata->max_workers) {', 1]
['typedef struct msg_rsv_dbg_s msg_rsv_dbg_t;', 1]
['local num=tonumber(ARGV[2])', 1]
['set_varval(v, ctx->publisher_type->data, ctx->publisher_type->len);', 1]
['//do the actual publishing', 1]
['nchan_copy_msg_id(&self->prev_msg_id, &msg->id, NULL);', 1]
['if (zone == NULL || shm == NULL) {', 1]
['spl->running = 0;', 1]
['assert(r->buf != NULL);', 1]
['shm_destroy(shm);', 1]
['* sdsrange(s,1,-1); => "ello World"', 1]
['d->d.subscriber = ipc_sub;', 1]
['fsub->timeout_ev.data = fsub;', 1]
['[IPC_DELETE] =                      (ipc_handler_pt )receive_delete,', 1]
['ipc_init(ipc);', 1]
['ac->ev.cleanup = redisLibevCleanup;', 1]
['return nchan_respond_status(fsub->sub.request, status_code, status_line, 0);', 1]
['ngx_conf_merge_sec_value(conf->buffer_timeout, prev->buffer_timeout, NCHAN_DEFAULT_BUFFER_TIMEOUT);', 1]
['while (_hb_keylen--)  { (hashv) = (((hashv) << 5) + (hashv)) + *_hb_key++; }   \\', 1]
['cur = ch;', 1]
["/* Clear curarg because it was put in curargv or was free'd. */", 1]
['cur += content_type_len;', 1]
['/* Format a command according to the Redis protocol. This function', 1]
['_hs_q = (UT_hash_handle*)((_hs_q->next) ?                      \\', 1]
['ngx_int_t internal_subscriber_set_respond_message_handler(subscriber_t *sub, callback_pt handler) {', 1]
['ch->spooler.fn->respond_status(&ch->spooler, NGX_HTTP_GONE, &NCHAN_HTTP_STATUS_410);', 1]
['freeReplyObject(redisCommand(c,"LRANGE mylist 0 -1"));', 1]
['offsetof(nchan_loc_conf_t, publisher_upstream_request_url),', 1]
['if(cd->allocd) {', 1]
['ngx_rbtree_init(&seed->tree, &seed->sentinel, &rbtree_insert_generic);', 1]
['typedef struct redisLibeventEvents {', 1]
['if(chain == NULL) {', 1]
['static ngx_int_t chunked_enqueue(subscriber_t *sub) {', 1]
['databuf.file_pos = fcur;', 1]
['_h *= 0xc2b2ae35l; \\', 1]
['{ ngx_string("nchan_max_channel_id_length"),', 1]
['bool cmp_write_ext16_marker(cmp_ctx_t *ctx, int8_t type, uint16_t size) {', 1]
['static ngx_chain_t *websocket_close_frame_chain(full_subscriber_t *fsub, uint16_t code, ngx_str_t *err);', 1]
['redisReaderFeed(reader,(char*)"x",1);', 1]
['c = *p;', 1]
['} redisAsyncContext;', 1]
['static ngx_int_t is_multi_id(ngx_str_t *id);', 1]
['bool cmp_object_to_str(cmp_ctx_t *ctx, cmp_object_t *obj, char *data, uint32_t buf_size);', 1]
['last_link->next=&bc->chain;', 1]
['d->callback(ch.subscribers > 0 ? NCHAN_MESSAGE_RECEIVED : NCHAN_MESSAGE_QUEUED, &ch, d->privdata);', 1]
['ngx_conf_merge_str_value(conf->allow_origin, prev->allow_origin, "*");', 1]
['msg->eventsource_event = cf->eventsource_event;', 1]
['redisAsyncContext **context = privdata;', 1]
['static void spoolcollector_addspool(spooler_respond_data_t *data, subscriber_pool_t *spool) {', 1]
['msg->shared = 1;', 1]
['cur = ngx_cpymem(cur, "Etag: ", sizeof("Etag: ") - 1);', 1]
['rwl_unlock_mutex(lock);                         \\', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "no message, something else");', 1]
['r->headers_out.status = NGX_HTTP_OK;', 1]
['ngx_atomic_fetch_add(&shdata->active_workers, 1);', 1]
['} sub_keepalive_data_t;', 1]
['msg.refcount = 0;', 1]
['ipc_t                 *ipc; //useful for write events', 1]
['/* ------------------------------- Macros ------------------------------------*/', 1]
['LIBNAME=libhiredis', 1]
['msg->msg->id.tag.fixed[0] = 0;', 1]
['proc->wbuf.overflow_first = NULL;', 1]
['start = j+seplen;', 1]
['ngx_str_t                          id;', 1]
['static ngx_int_t spool_remove_subscriber(subscriber_pool_t *self, spooled_subscriber_t *ssub) {', 1]
['static ngx_str_t REDIS_DEFAULT_URL = ngx_string("127.0.0.1:6379");', 1]
['cf.max_messages = d->max_msgs;', 1]
['//DBG("add sub %p to spool %p", sub, self);', 1]
['#undef get16bits', 1]
['redis_subscriber_register_t *sdata= (redis_subscriber_register_t *) privdata;', 1]
['if(channel!=NULL) {', 1]
['ngx_int_t            code = r->headers_out.status;', 1]
['if(! nchan_strmatch(val,', 1]
['shdata->msgdebug_head = msg;', 1]
['if(tags2[j] != -1) {', 1]
['assert(proc->wbuf.overflow_n >= 0);', 1]
['if (obj.type != CMP_TYPE_DOUBLE) {', 1]
['msg->id.time = time_int;', 1]
['/* Compute the time remaining to wait.', 1]
['"--[[\\n"', 1]
['ccv.complex_value = cv;', 1]
['will hold the status as a vanilla C string. However, the functions that are', 1]
['head->use_redis = cf->use_redis;', 1]
['for (;_sfh_len > 0; _sfh_len--) {                                              \\', 1]
['assert(d->msg_status != MSG_FOUND);', 1]
["no_msgid_order = 'FILO'", 1]
['int i=0;', 1]
['int wdone = 0;', 1]
['tc->gc_timer.handler = nchan_thingcache_gc_timer_handler;', 1]
['#define uthash_fatal(msg) exit(-1)        /* fatal error (out of memory,etc) */', 1]
['max = shdata->max_workers;', 1]
['ngx_memcpy(&bc[1].buf, databuf, sizeof(*databuf));', 1]
['spl->fn=&spooler_fn;', 1]
['One or more spaces separates arguments, so you can use the specifiers', 1]
['dbg("channel current_message absent")', 1]
['return ctx->read(ctx, x, sizeof(uint8_t));', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS SCRIPT ERROR: %s", reply->str);', 1]
['off_t       fcur, flast;', 1]
['DBG("add %p to GC", head);', 1]
['if(cur->time <= time) {', 1]
['DBG("%p not ready to destroy (reserved for %i)", sub, sub->reserved);', 1]
['ngx_int_t nchan_detect_chunked_subscriber_request(ngx_http_request_t *r) {', 1]
['switch(c[1]) {', 1]
['sub_data_t                  *d;', 1]
['if(msgidtags[i] != 0) {', 1]
['/* Function to free the reply objects hiredis returns by default. */', 1]
['int main(void) {', 1]
['ngx_str_t                   id[NCHAN_MULTITAG_MAX];', 1]
['out->next = NULL;', 1]
['ngx_str_t                  auth_request_url;', 1]
['char *hash=(*hashes)[i];', 1]
['r->elements = elements;', 1]
['d->chanhead->spooler.fn->handle_channel_status_change(&d->chanhead->spooler);', 1]
['#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)', 1]
['static int16_t    tags[NCHAN_MULTITAG_MAX];', 1]
['createIntegerObject,', 1]
['"local subs_key = \'channel:subscribers:\'..id\\n"', 1]
['//DBG("%s channel id %V", what == PUB ? "pub" : "sub", id);', 1]
['return write_type_marker(ctx, NIL_MARKER);', 1]
['void redisReaderFree(redisReader *reader);', 1]
["return (cur[0] == 'm' && cur[1] == '/' && cur[2] == NCHAN_MULTI_SEP_CHR);", 1]
['/*if (context != NULL) {', 1]
['if (reply == NULL || reply->type == REDIS_REPLY_ERROR) {', 1]
['FIXARRAY_MARKER        = 0x90,', 1]
['CMP_TYPE_UINT64,          /* 17 */', 1]
['int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout);', 1]
['#define WEBSOCKET_READ_GET_REAL_SIZE_STEP   1', 1]
['nchan_store_channel_head_t    *ch;', 1]
['if (ngx_buf_size(msg_buf) == 0) {', 1]
['static void moveToNextTask(redisReader *r) {', 1]
['if (cur->type == REDIS_REPLY_INTEGER) {', 1]
['assert(n > in_n && n > out_n);', 1]
['void              shm_free(shmem_t *shm, void *p);', 1]
['static nchan_loc_conf_t           *evcf = NULL;', 1]
['DBG("%p dequeued (%p %V %i) %V", d->multi->sub, d->multi_chanhead, &d->multi_chanhead->id, d->n, &d->multi->id);', 1]
['[IPC_DOES_CHANNEL_EXIST] =          (ipc_handler_pt )receive_does_channel_exist,', 1]
['recycloc_t *recycloc_destroy(recycloc_t *self) {', 1]
['nchan_longpoll_multimsg_t *first, *cur;', 1]
['va_copy(_cpy,ap);', 1]
['msg = getmsg m[0]', 1]
['obj->type = CMP_TYPE_FIXMAP;', 1]
['d->multi_chanhead = chanhead;', 1]
['void               **next_ptr, **prev_ptr;', 1]
['head = nchan_memstore_get_chanhead_no_ipc_sub(d->shm_chid, &fake_conf);', 1]
['"  if lasttime==msg.time then\\n"', 1]
['bool cmp_write_fixext16(cmp_ctx_t *ctx, int8_t type, const void *data) {', 1]
['//fuck it, just always allocate. we need to handle multis and shit too', 1]
['"redis.call(\'DEL\', subs_key)\\n"', 1]
['nchan_use_redis [:main, :srv, :loc],', 1]
['} redis_publish_callback_data_t;', 1]
['@echo "Please specify AE_DIR (e.g. <redis repository>/src)"', 1]
['* as the previous one. In this context, think to reference counting,', 1]
['u_char               *last = buf->start;', 1]
["//but that would mean not reusing longpoll's fsub directly", 1]
['if(msg->content_type.len > 0) {', 1]
['typedef struct dict {', 1]
['redisCallback cb = {NULL, NULL, NULL};', 1]
['#define HASH_TO_BKT( hashv, num_bkts, bkt )                                      \\', 1]
['bool cmp_write_map32(cmp_ctx_t *ctx, uint32_t size) {', 1]
['test("Can parse multi bulk replies: ");', 1]
['ngx_log_error(NGX_LOG_ERR, log, 0, "nchan: can\'t create output chain file cleanup.");', 1]
['NULL,                          /* exit thread */', 1]
["r->errstr[0] = '\\0';", 1]
['if (head) {                                                                  \\', 1]
["local stored_messages = tonumber(redis.call('LLEN', key.messages))", 1]
['"  redis.call(\'HSET\', key.last_message, \'next\', msg.id)\\n"', 1]
['Redis. It returns a pointer to the newly created `redisAsyncContext` struct. The `err` field', 1]
['buf_body_size = ngx_buf_size(mbuf);', 1]
['HASH_TO_BKT( _hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt);   \\', 1]
['//empty messages are skipped, because a zero-length chunk finalizes the request', 1]
['ERROR_NONE,', 1]
['cur->elements = -1;', 1]
['//just something unlikely', 1]
['ngx_socket_t           pipe[2];', 1]
['//     redisSetFreeCallback(c,__test_callback,(void*)4);', 1]
['else if(cf->sub.http_chunked && nchan_detect_chunked_subscriber_request(r)) {', 1]
['#define HASH_COUNT(head) HASH_CNT(hh,head)', 1]
['delete_data_t  data = {str_shm_copy(chid), 0, NULL, 0, callback, privdata};', 1]
['msgbuf.end = msgbuf.start + frame->payload_len;', 1]
['# This file is released under the BSD license, see the COPYING file', 1]
['if (header[i].key.len == sizeof("Content-Length") - 1', 1]
['{ ngx_string("push_max_message_buffer_length"), //legacy for nchan_message_buffer_length', 1]
['bool cmp_read_str(cmp_ctx_t *ctx, char *data, uint32_t *size);', 1]
['ERR("Unable to add request cleanup for websocket upstream request");', 1]
['if (!c->read->ready) {', 1]
[':alpha', 1]
['void redis_nginx_init(void);', 1]
['bool cmp_read_double(cmp_ctx_t *ctx, double *d) {', 1]
['obj = (void*)(size_t)(cur->type);', 1]
["redis.call('EXPIRE', key.subscriber_id, channel.ttl)", 1]
['x = sdsnew("0");', 1]
["/* r->buf should not be NULL since we just free'd a larger one. */", 1]
['//nothing to do', 1]
['ngx_http_post_subrequest_t  psr;', 1]
['} shmsg_memspace_t;', 1]
['return cmp_write_fixext16(ctx, tp, data);', 1]
['"    return {err=\\"Subscriber count for channel \\" .. id .. \\" less than zero: \\" .. sub_count}\\n"', 1]
['@id||= "#{time}:#{tag}" unless time.nil? || tag.nil?', 1]
['setkeyttl(empty_ttl)', 1]
['if (!read_type_marker(ctx, &type_marker))', 1]
['int i, num;', 1]
['ht->privdata = privDataPtr;', 1]
['nchan_memstore_force_delete_channel(channel_id, callback, privdata);', 1]
['case \'\\r\': len = snprintf(buf,size,"\\"\\\\r\\""); break;', 1]
['#    info: "Controls how multiple subscriber requests to a channel (identified by some common ID) are handled.The values work as follows:', 1]
['DBG(" -- %V", msgid_to_str(&msg->id));', 1]
["### Sending commands (cont'd)", 1]
['bool cmp_write_nfix(cmp_ctx_t *ctx, int8_t c);', 1]
['d->sub->fn->reserve(d->sub);', 1]
['if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {', 1]
['&& CHECK_REPLY_INT(els[offset])            //msg TTL', 1]
['memcpy(_format,c,_l);', 1]
['uthash_expand_fyi(tbl);                                                      \\', 1]
['&longpoll_release,', 1]
['num = 1000;', 1]
['callbackValDestructor', 1]
['b->start = channel_info_buf_str;', 1]
['if (!write_type_marker(ctx, U64_MARKER))', 1]
['The `privdata` argument can be used to curry arbitrary data to the callback from the point where', 1]
['if(c->flags & REDIS_SUBSCRIBED)', 1]
['bool cmp_write_s8(cmp_ctx_t *ctx, int8_t c);', 1]
['tc->thing_tail = cur;', 1]
['ac->ev.delRead = redisAeDelRead;', 1]
['if (root) r->reply = obj;', 1]
['nchan_msg_id_t          msgid;', 1]
['test_cond("sdscmp(bar,bar)", sdscmp(x,y) == 0)', 1]
['#endif /* UTHASH_H */', 1]
['DBG("not subscribed anymore");', 1]
['asynchronous API is used. This means you should not call `freeReplyObject` when', 1]
['//DBG("publish_callback %V owner %i status %i", ch_id, memstore_channel_owner(ch_id), status);', 1]
['bc[3].buf.end = ngx_snprintf(boundary, 50, "\\r\\n--%V", nchan_request_multipart_boundary(fsub->sub.request, ctx));', 1]
['* we were forfeiting our ability to further refer to the deletee (users)', 1]
['nchan_msg_status_t      getmsg_code;', 1]
['_hs_psize++;                                                   \\', 1]
['_he_thh = tbl->buckets[ _he_bkt_i ].hh_head;                             \\', 1]
['ngx_log_debug(NGX_LOG_ERR, c->log, 0, "push stream module: unknown websocket step (%d)", frame->step);', 1]
['cur = &mdata[i];', 1]
['if ( !CHECK_REPLY_ARRAY_MIN_SIZE(reply, 2) || !CHECK_REPLY_INT(reply->element[1]) ) {', 1]
['oldtags = old_largetags;', 1]
['sds sdsMakeRoomFor(sds s, size_t addlen);', 1]
['redisFree(redisContext);', 1]
['chan.messages = chinfo->stored_message_count;', 1]
['nchan_store_subscribe_continued(SUB_CHANNEL_AUTHORIZED, NULL, d);', 1]
['nchan_copy_msg_id(&new_id, &spool->id, largetags);', 1]
['* is performed. */', 1]
['uint16_t                   msg_timeout;', 1]
['if(ngx_buf_in_memory_only(mbuf)) {', 1]
['ARRAY_LENGTH_TOO_LONG_ERROR,', 1]
['ngx_conf_log_error(NGX_LOG_ERR, cf, 0, "invalid %V value: %V, must be either \'oldest\' or \'newest\'", &cmd->name, val);', 1]
['else if (type_marker == EXT32_MARKER) {', 1]
["-- 'empty_ttl' is channel ttl when without subscribers. 0 to delete immediately, -1 to persist, >0 ttl in sec", 1]
['static void receive_publish_status(ngx_int_t sender, publish_status_data_t *d) {', 1]
['static shmem_t         *shm = NULL;', 1]
['ngx_conf_merge_bitmask_value(conf->sub.longpoll, prev->sub.longpoll, 0);', 1]
['ngx_str_t                   empty_id_str = ngx_string("-");', 1]
['ch->last_seen = r->element[1]->integer;', 1]
['rwl_unlock_mutex(lock);                           \\', 1]
['bool cmp_read_s8(cmp_ctx_t *ctx, int8_t *c) {', 1]
['--delete all the messages right now mister!', 1]
['*d = obj.as.s8;', 1]
['nchan_store_memory.exit_master(cycle);', 1]
["* doesn't know what the server will spit out over the wire. */", 1]
['for ( _hs_i = 0; _hs_i  < _hs_insize; _hs_i++ ) {                  \\', 1]
['//#define DEBUG_DELAY_IPC_RECEIVE_ALERT_MSEC 100', 1]
['msg.id.tag.fixed[0]=0;', 1]
['if(rp->timer.timer_set) {', 1]
['// result_code can be: 200 - ok, 403 - channel not found, 404 - not found, 410 - gone, 418 - not yet available', 1]
['ac->replies.head = NULL;', 1]
['size += ngx_buf_size(chains[0].buf);', 1]
['//input:  keys: [], values: [channel_id, number]', 1]
['/* Ignore broken pipe signal (for I/O error tests). */', 1]
['if(ngx_buf_size(msg_buf) > 0) {', 1]
['### 0.10.1', 1]
['### 0.10.0', 1]
['spool->spooler->store->get_message(spool->spooler->chid, &spool->id, (callback_pt )spool_fetch_msg_callback, data);', 1]
['* The app can #include <unistd.h> to get the prototype for write(2). */', 1]
['redisCallback *cb = list->head;', 1]
['#include <ev.h>', 1]
['const  ngx_str_t NCHAN_HEADER_ALLOW_METHODS = ngx_string("Access-Control-Allow-Methods");', 1]
['buf->last = (last != NULL) ? last : start;', 1]
['nchan_msg_id_t        anymsg;', 1]
['"  redis.call(\'EXPIRE\', key.message, msg.ttl)\\n"', 1]
['const char *source_addr);', 1]
['assert(rp->count > 0 && rp->first != NULL);', 1]
['#include "redis_lua_commands.h"', 1]
['ngx_memcpy(&conf->redis_url, &REDIS_DEFAULT_URL, sizeof(REDIS_DEFAULT_URL));', 1]
['script=v.last', 1]
['wev->delayed = 0;', 1]
['if (msg->content_type.data!=NULL) {', 1]
['/* When the buffer is empty, there will never be a reply. */', 1]
['prev = thing_prev(rp, thing);', 1]
['redisContext *c = redisConnect("127.0.0.1", 6379);', 1]
['THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND', 1]
['redisConnectCallback *onConnect;', 1]
['Usually this buffer is destroyed when it is empty and is larger than 16', 1]
['static ngx_int_t nchan_parse_compound_msgid(nchan_msg_id_t *id, ngx_str_t *str){', 1]
['* blocking, immediately read the reply into the "reply" pointer. When the', 1]
['ngx_memzero(&pd->ch, sizeof(pd->ch));', 1]
['size_t j;', 1]
['b->last = b->end;', 1]
['char                         *name;', 1]
['obj->as.u8 = type_marker;', 1]
['if (ht->used == ht->size)', 1]
['static ngx_str_t            debug_pool_str;', 1]
['d->callback=callback;', 1]
['extern const ngx_str_t NCHAN_WEBSOCKET;', 1]
['tokens = newtokens;', 1]
['static ngx_inline void *thing_prev(nchan_reaper_t *rp, void *thing) {', 1]
['ngx_http_request_t        *rcur;', 1]
['static ngx_flag_t is_utf8(u_char *p, size_t n) {', 1]
['* **`REDIS_ERR_IO`**:', 1]
['* **`REDIS_REPLY_STATUS`**:', 1]
['for (b = bservinfo; b != NULL; b = b->ai_next) {', 1]
['char *sts;', 1]
['nchan_store_channel_head_t        *head;', 1]
['#ifndef __SDS_H', 1]
['cur += len;', 1]
['node->left = NULL;', 1]
['dictFreeEntryVal(ht,de);', 1]
['ch->msg_last = msg->prev;', 1]
['strcasecmp(reply->element[1]->str,"pong") == 0);', 1]
['d->callback(NGX_OK, &channel, d->privdata);', 1]
['nchan_loc_conf_t       *cf = ngx_http_get_module_loc_conf(r, nchan_module);', 1]
['it = dictGetIterator(ac->sub.channels);', 1]
['channel_spooler_fn_t       *fn;', 1]
["require 'securerandom'", 1]
['lack of explicit bindings for every Redis command.', 1]
['CMP_TYPE_POSITIVE_FIXNUM, /*  0 */', 1]
['@@files[scriptname]=f', 1]
['minlen = (l1 < l2) ? l1 : l2;', 1]
['static void redisLibeventReadEvent(int fd, short event, void *arg) {', 1]
['data.callback_privdata = privdata;', 1]
['"  <requested>%d</requested>" CRLF', 1]
['Incoming data -- most likely from a socket -- can be placed in the internal', 1]
['TYPE_MARKER_READING_ERROR,', 1]
['extern const ngx_str_t NCHAN_HEADER_CACHE_CONTROL;', 1]
['bool cmp_write_array16(cmp_ctx_t *ctx, uint16_t size) {', 1]
['v->valid = 1;', 1]
['} nchan_store_multi_t;', 1]
['ipc_process_t           *proc = (ipc_process_t *) c->data;', 1]
["/* Discard part of the buffer when we've consumed at least 1k, to avoid", 1]
['def self.test_order', 1]
['i = -i;', 1]
["if (*c != '%' || c[1] == '\\0') {", 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_DOES_CHANNEL_EXIST, &data, sizeof(data));', 1]
['ngx_int_t nchan_free_msg_id(nchan_msg_id_t *id);', 1]
['obj->type = CMP_TYPE_NEGATIVE_FIXNUM;', 1]
['c = calloc(1,sizeof(redisContext));', 1]
['msg_rsv_dbg_t     *cur, *prev, *next;', 1]
['d->d.resp.getmsg_code = status;', 1]
['* 1) The sds header before the pointer.', 1]
['////////// DOES CHANNEL EXIST? ////////////////', 1]
['#define NCHAN_REAPER_H', 1]
['static ngx_int_t websocket_send_close_frame(full_subscriber_t *fsub, uint16_t code, ngx_str_t *err);', 1]
['ngx_uint_t                   internal_sub_count;', 1]
['/* Initialize the hash table */', 1]
['ngx_memzero(&buf, sizeof(buf));', 1]
['bin_size = obj->as.bin_size;', 1]
['nchan_msg_id_t                  last_published_msg_id;', 1]
['((redisReply*)reply)->elements == 0);', 1]
['static ngx_int_t spooler_set_bulk_dequeue_handler(channel_spooler_t *self, void (*handler)(channel_spooler_t *, subscriber_type_t, ngx_int_t, void *), void *privdata) {', 1]
["//don't destroy the temp pool just yet,", 1]
['_src_hh = _src_hh->hh_next) {                                          \\', 1]
['params->password = cur_out;', 1]
['UT_hash_handle                  hh;', 1]
['nchan_memstore_publish_generic(d->multi_chanhead, NULL, NGX_HTTP_CONFLICT, &NCHAN_HTTP_STATUS_410);', 1]
['NIL_MARKER             = 0xC0,', 1]
['return redisContextSetTimeout(c,tv);', 1]
['connection->data = ac;', 1]
['/* ----------------------------- API implementation ------------------------- */', 1]
['$(INSTALL) $(DYLIBNAME) $(INSTALL_LIBRARY_PATH)/$(DYLIB_MINOR_NAME)', 1]
['cur->type = -1;', 1]
['static nchan_msg_t *create_shm_msg(nchan_msg_t *m) {', 1]
['ngx_http_finalize_request(r, nchan_response_channel_ptr_info(ch, r, NGX_HTTP_CREATED));', 1]
['#define HASH_REPLACE_PTR(head,ptrfield,add,replaced)                             \\', 1]
['cur = last + 1;', 1]
['fsub->sub.name= (name == NULL ? &subscriber_name : name);', 1]
['//     /* Read until at least one callback is executed (the 3 replies will', 1]
['/* in an ideal situation (all buckets used equally), no bucket would have', 1]
['assert(max->tagcount == id->tagcount);', 1]
['current = NULL;', 1]
['"-- have a solution to this, please help.\\n"', 1]
['if (redisGetReply(c,&reply) != REDIS_OK)', 1]
['* in the patch-up process. Solution: use scratch space to', 1]
['ngx_conf_log_error(NGX_LOG_WARN, cf, 0, "Cannot change memory area size without restart, ignoring change");', 1]
['test_format_commands();', 1]
['ngx_memset(node, 0x65, sizeof(*node));', 1]
['test.o: test.c hiredis.h', 1]
['} nchan_shm_data_t;', 1]
['hiredis-test: test.o $(STLIBNAME)', 1]
['if(! cmp_to_str(&cmp, &chid)) {', 1]
['ngx_str_t            *chid = &d->channel_id;', 1]
['prepend_es_response_line(&event_line, &first_link, &msg->eventsource_event, pool);', 1]
['typedef struct redisReplyObjectFunctions {', 1]
['if(t1 > t2) {', 1]
['/* Reads an unsigned integer that fits inside an unsigned char */', 1]
['* remains 6 bytes. */', 1]
['assert(foreign_chanhead != NULL);', 1]
['l2 = msgtag_to_strptr(id, cur);', 1]
['lcf->channel_events_channel_id = NULL;', 1]
['l.gsub! \'"\', \'\\"\'', 1]
['self->add_handler = handler;', 1]
['obj->as.map_size = be32(obj->as.u32);', 1]
['the error. More information on errors can be found in the **Errors** section.', 1]
['return (shared_sub_count > 0) ? NCHAN_MESSAGE_RECEIVED : NCHAN_MESSAGE_QUEUED;', 1]
['tbl->log2_num_buckets++;                                                     \\', 1]
['if(shdata->old_max_workers == NGX_CONF_UNSET) {', 1]
['"  if next(dict) == nil then return nil end\\n"', 1]
['while((status = redisGetReply(c,&reply)) == REDIS_OK) {', 1]
["time_offset=  'nchan:message_time_offset',", 1]
['bool cmp_write_str_marker(cmp_ctx_t *ctx, uint32_t size) {', 1]
['if(!(origin_header->len == cf->allow_origin.len && ngx_strnstr(origin_header->data, (char *)cf->allow_origin.data, origin_header->len) != NULL)) {', 1]
['bool cmp_read_ulong(cmp_ctx_t *ctx, uint64_t *u);', 1]
['ret= NGX_OK;', 1]
['if( msgid_tag_compare(&spool->id, &data->max) < 0', 1]
['if(multi) {', 1]
['len == 4+4+(3+2)+4+(1+2)+4+(1+2));', 1]
["* is called with a REDIS_ERR status and the context is free'd. */", 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: error reading request body with multiple ");', 1]
['data.last_msgid = zero_msgid;', 1]
['((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&', 1]
['tmp_buf = nchan_channel_info_buf(accept_header, messages, subscribers, last_seen, msgid, NULL);', 1]
['cur = id_out->data;', 1]
['nchan_variable_t nchan_vars[] = {', 1]
['nchan_store_channel_head_t *nchan_memstore_get_chanhead_no_ipc_sub(ngx_str_t *channel_id, nchan_loc_conf_t *cf) {', 1]
['int                      i, first = proc->wbuf.first, last = first + proc->wbuf.n;', 1]
['cd->sender = sender;', 1]
['static void ipc_write_handler(ngx_event_t *ev) {', 1]
['chan_info->last_seen = chan->last_seen;', 1]
['ngx_table_elt_t * nchan_add_response_header(ngx_http_request_t *r, const ngx_str_t *header_name, const ngx_str_t *header_value) {', 1]
['bool cmp_write_str16_marker(cmp_ctx_t *ctx, uint16_t size);', 1]
['static void its_reaping_time(nchan_reaper_t *rp, uint8_t force) {', 1]
['clnf->fd = file->fd;', 1]
['inserted = 1;', 1]
['uint16_t                  close_code=0;', 1]
['assert(slot < MAX_FAKE_WORKERS);', 1]
['store_message_t   *next = NULL;', 1]
['static void memstore_pub_debug_end() {', 1]
['nchan_store_publish_generic(&chid, &msg, 0, NULL);', 1]
['redisReply                *reply= r;', 1]
['static void spool_bubbleup_dequeue_handler(subscriber_pool_t *spool, subscriber_t *sub, channel_spooler_t *spl) {', 1]
['struct full_subscriber_s {', 1]
['ac = *context;', 1]
['multipart_fn->enqueue = multipart_enqueue;', 1]
['if(msg_file->fd == NGX_INVALID_FILE) {', 1]
['if(chr_int == EOF) {', 1]
['ERR("%V sub count already shared, don\'t update", &head->id);', 1]
['5', 1]
["cur = ngx_strlchr(cur, last, '\\n');", 1]
['* Since the ideal chain length is an integer, we want to calculate', 1]
['size_t buflen = 16;', 1]
['if(cur == rp->first) rp->first = next;', 1]
['#define DECLTYPE(x)', 1]
['bool cmp_read_u8(cmp_ctx_t *ctx, uint8_t *c) {', 1]
['nchan_store_redis.get_message(channel_id, msg_id, callback, privdata);', 1]
['//initialize cleanup timer', 1]
['Examples are bundled that show using Hiredis with [libev](http://software.schmorp.de/pkg/libev.html)', 1]
['void redisAsyncHandleWrite(redisAsyncContext *ac);', 1]
['ERR("can\'t allocate multi array for multi-channel %p", head);', 1]
['DYLIB_MAKE_CMD=$(CC) -G -o $(DYLIBNAME) -h $(DYLIB_MINOR_NAME) $(LDFLAGS)', 1]
['int type; /* REDIS_REPLY_* */', 1]
["unsigned                holding:1; //make sure the request doesn't close right away", 1]
['at the same time it uses an high level printf-alike API in order to make it', 1]
['nchan_copy_msg_id(&retmsg.id, &d->msg->id, multi_largetag);', 1]
['tbl->num_buckets *= 2;                                                       \\', 1]
['ngx_int_t memstore_ipc_send_flood_test(ngx_int_t dst) {', 1]
['unsigned long bytelen;', 1]
['/* (P)UNSUBSCRIBE does not have its own response: every channel or', 1]
['for k, v in pairs(dict) do', 1]
['unsigned                        in_gc_queue:1;', 1]
['ngx_str_t *msgid_to_str(nchan_msg_id_t *id) {', 1]
['ngx_uint_t                          i;', 1]
["* or there were no callbacks to begin with. Either way, don't", 1]
['ngx_memcpy(cur, group->data, grouplen);', 1]
['else if(cur > last) {', 1]
['DYLIB_MAJOR_NAME=$(LIBNAME).$(DYLIBSUFFIX).$(HIREDIS_MAJOR)', 1]
['static void redisLibeventWriteEvent(int fd, short event, void *arg) {', 1]
['d->sub = NULL; //debug', 1]
['nchan_msg_id_t              id;', 1]
['static void set_varval(ngx_http_variable_value_t *v, u_char *data, size_t len) {', 1]
['$(DYLIB_MAKE_CMD) $(OBJ)', 1]
['typedef struct redisContext {', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "no callback given for async get_message. someone\'s using the API wrong!");', 1]
['ctx->write = write;', 1]
['*size = bin_size;', 1]
["case '8': return 8;", 1]
['if (callback != NULL) {', 1]
['chunked_fn->enqueue = chunked_enqueue;', 1]
['if (read_byte(ctx, marker))', 1]
['info: "Split the channel id into several ids for multiplexing using the delimiter string provided."', 1]
['next_ptr = thing_next_ptr(rp, cur);', 1]
['return spooler;', 1]
['smsg->msg->refcount = MSG_REFCOUNT_INVALID;', 1]
['if(shdata->msgdebug_head == NULL) {', 1]
['ngx_http_core_loc_conf_t  *clcf;', 1]
['bool cmp_write_float(cmp_ctx_t *ctx, float f) {', 1]
["redis.call('HSET', key.channel, 'max_stored_messages', store_at_most_n_messages)", 1]
['ngx_memcpy(&fsub->msg_buf, tmp_buf, sizeof(*tmp_buf));', 1]
['} redis_get_message_from_key_data_t;', 1]
['if(ch->owner == memstore_slot() && ch->shared) {', 1]
['msg.content_type.data = r->headers_in.content_type->value.data;', 1]
['DBG("ensure chanhead ready: request for %V from %i to %i", &head->id, memstore_slot(), owner);', 1]
['if(id2->tagcount > 1) {', 1]
['part = &pr->headers_in.headers.part;', 1]
['nchan_store_publish_generic(chid, msg, 0, NULL);', 1]
['if(data_size > IPC_DATA_SIZE) {', 1]
['/* Copy string value */', 1]
['bool cmp_read_long(cmp_ctx_t *ctx, int64_t *d);', 1]
['d->reserved = 1;', 1]
['{ ngx_string("push_subscriber_timeout"), //legacy for nchan_subscriber_timeout', 1]
['if (errno == EHOSTUNREACH) {', 1]
['default: c = *p; break;', 1]
['getmessage_blob_t   *blob;', 1]
['#nice!', 1]
["/* Returns a string description of a CMP context's error */", 1]
['#define WP(p) ((uint32_t*)((unsigned long)(p) & ~3UL))', 1]
['static int dictDelete(dict *ht, const void *key);', 1]
['for (var = nchan_vars; var->name.len; var++) {', 1]
['proc->wbuf.first = 0;', 1]
['cf.max_messages = -1; //TODO: fix this value', 1]
['successfully executed. When an error occurs, the return value is `NULL` and', 1]
['x = sdsnew("bar");', 1]
['a -= b; a -= c; a ^= ( c >> 3 );                                               \\', 1]
['redisContext *redisConnectBindNonBlock(const char *ip, int port,', 1]
['void (*delWrite)(void *privdata);', 1]
['msgtag_str.len = len;', 1]
['obj->as.ext.size = be16(ext_size);', 1]
['DBG("chanhead_gc max %i count %i", max_messages, ch->channel.messages);', 1]
['[:loc_conf, :longpoll_multimsg],', 1]
['static ngx_int_t nchan_store_publish_generic(ngx_str_t *channel_id, nchan_msg_t *msg, ngx_int_t status_code, const ngx_str_t *status_line){', 1]
['flood_data_t        data = {flood_seq++};', 1]
['} dictType;', 1]
['int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {', 1]
['void *shm_locked_alloc(shmem_t *shm, size_t size, const char *label) {', 1]
['buf->pos=buf->start;', 1]
['assert(spool->msg_status == MSG_INVALID);', 1]
['sh->len = 0;', 1]
['if(fsub->data.act_as_intervalpoll) {', 1]
['if (!cmp_write_fixstr_marker(ctx, size))', 1]
['unsigned                        shutting_down:1;', 1]
['unsigned                        eventsource:1;', 1]
['to the socket or read from the socket. If you included `errno.h` in your', 1]
['cur->elements = elements;', 1]
['CMP_TYPE_ARRAY32,         /* 31 */', 1]
['connection->fd = NGX_INVALID_FILE;', 1]
[':nchan_set_pubsub_channel_id,', 1]
['if (n == 0) {', 1]
['nchan_msg_t            *shm_msg;', 1]
['DBG("IPC received delete reply for channel %V privdata %p", d->shm_chid, d->privdata);', 1]
['spool->non_internal_sub_count = 0;', 1]
['if (r->reply != NULL && r->fn && r->fn->freeObject) {', 1]
['struct UT_hash_handle *_hd_hh_del;                                           \\', 1]
['d->sub->fn->release(d->sub, 0);', 1]
['sds sdscat(sds s, const char *t);', 1]
['"  return {err=\\"non-numeric status code given, bailing!\\"}\\n"', 1]
['ac->ev.data    = p;', 1]
['ngx_rbtree_node_t       *node;', 1]
['ngx_int_t nchan_channel_info(ngx_http_request_t *r, ngx_uint_t messages, ngx_uint_t subscribers, time_t last_seen, nchan_msg_id_t *msgid) {', 1]
['ngx_str_t   dst_str, src_str = {buf_body_size, mbuf->pos};', 1]
['switch (subscriber_concurrency) {', 1]
['int                    i;', 1]
['/* Always schedule a write when the write buffer is non-empty */', 1]
['static char *nchan_set_channel_events_channel_id(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['ngx_int_t ipc_set_handler(ipc_t *ipc, void (*alert_handler)(ngx_int_t, ngx_uint_t, void *)) {', 1]
['rdt.chanhead_cleanup_head = chanhead_cleanlink;', 1]
['* callbacks with a NULL-reply. */', 1]
['fmt_valid:', 1]
['ngx_int_t                      i;', 1]
['if(head->in_gc_queue) {//recycled chanhead', 1]
['Both when using the Reader API directly or when using it indirectly via a', 1]
['#ifdef HASH_EMIT_KEYS', 1]
['void ngx_rwlock_reserve_write(ngx_rwlock_t * lock) {', 1]
['data->overflow = overflow->next;', 1]
['channel_spooler_t            spooler;', 1]
['void subscriber_debug_add(subscriber_t *sub) {', 1]
['if (curarg == NULL)', 1]
['fsub->data.dequeue_handler(self, fsub->data.dequeue_handler_data);', 1]
['bool cmp_write_str(cmp_ctx_t *ctx, const char *data, uint32_t size) {', 1]
['const  ngx_str_t NCHAN_HEADER_ALLOW_ORIGIN = ngx_string("Access-Control-Allow-Origin");', 1]
['* === Backwards compatibility defines', 1]
['if(d->msg_status == MSG_PENDING) {', 1]
['if (sr->request_body == NULL) {', 1]
['for(i = 0; i < n_out; i++) {', 1]
['newarg = sdscatvprintf(curarg,_format,_cpy);', 1]
['ac->errstr = NULL;', 1]
['if (n == NGX_ERROR) {', 1]
['rp->first = next;', 1]
['./hiredis-test', 1]
['de = ht->table[h];', 1]
['if(ipc_subscribe_if_needed) {', 1]
['int16_t         src_slot;', 1]
['sdsfree(curargv[argc]);', 1]
['while (node != sentinel) {', 1]
['typedef rbtree_walk_direction_t (*rbtree_walk_conditional_callback_pt)(rbtree_seed_t *, void *, void *);', 1]
['uint64_t  u64;', 1]
['legacy: "push_subscriber_timeout",', 1]
['/* Modify an sds string on-place to make it empty (zero length).', 1]
['static ngx_int_t get_msg_from_msgkey(ngx_str_t *channel_id, nchan_msg_id_t *msgid, ngx_str_t *msg_redis_hash_key) {', 1]
['def setup', 1]
['if (!cmp_write_ext16_marker(ctx, tp, sz))', 1]
['//     /* Write output buffer */', 1]
['if(thing == rp->first) rp->first = next;', 1]
['return cmp_write_fixext8(ctx, tp, data);', 1]
['bool cmp_object_is_uinteger(cmp_object_t *obj) {', 1]
['subscriber_t *eventsource_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id) {', 1]
['test_cond(ret == REDIS_ERR && reply == NULL);', 1]
['nchan_buf_and_chain_t   bc[4];', 1]
['int inq=0;  /* set to 1 if we are in "quotes" */', 1]
['ERR("Not enough free procslots?! Don\'t know what to do... :\'(");', 1]
['redis_nginx_write_event(ngx_event_t *ev)', 1]
['c -= a; c -= b; c ^= ( b >> 13 );                                              \\', 1]
['|| (msg->id.time == d->msg->id.time && msg->id.tag.fixed[0] == d->msg->id.tag.fixed[0] && sd->n < d->n) ) {', 1]
['static void rwl_unlock_mutex(ngx_rwlock_t *lock) {', 1]
['// result_code can be: 200 - ok, 404 - not found, 410 - gone, 418 - not yet available', 1]
['sds sdsgrowzero(sds s, size_t len) {', 1]
['/* Backwards compatibility, can be removed on big version bump. */', 1]
['"9af42e385bc489cae6453e569ed40423a52ab397",', 1]
['nchan_channel_events_channel_id [:srv, :loc, :if],', 1]
['chains[1].buf = &double_newline_buf;', 1]
['conf->last_message_id.n = 2;', 1]
['if ((index = _dictKeyIndex(ht, key)) == -1)', 1]
['bool cmp_object_as_char(cmp_object_t *obj, int8_t *c);', 1]
['static void receive_unsubscribed(ngx_int_t sender, unsubscribed_data_t *d) {', 1]
['#define nchan_hash_literal(s)                                        \\', 1]
['(head)->hh.tbl->tail->next = (add);                                          \\', 1]
['rdt.chanhead_cleanup_tail->next=chanhead_cleanlink;', 1]
['if ARGV[0]=="file"', 1]
['const ngx_str_t   *line;', 1]
['redisReply             *reply = r;', 1]
['spool = overflow->spool;', 1]
['node = node->left;', 1]
['b->pos = body->data;', 1]
['DBG("reattached shm data at %p", data);', 1]
['(head)=NULL;                                                                 \\', 1]
['static       ngx_str_t   sub_name = ngx_string("eventsource");', 1]
['subt->http_chunked=0;', 1]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_RCVTIMEO)");', 1]
['free(de);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "WEBSOCKET_PUBLISHER:" fmt, ##arg)', 1]
['obj->type = CMP_TYPE_SINT64;', 1]
['r->cleanup = NULL;', 1]
['info: "The path to a redis server, of the form \'redis://:password@hostname:6379/0\'. Shorthand of the form \'host:port\' or just \'host\' is also accepted."', 1]
['ac->ev.delRead = NULL;', 1]
['#define _EL_DEL_READ(ctx) do { \\', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS REPLY is NULL");', 1]
['redisContext *c = NULL;', 1]
['assert(msg->refcount >= 0);', 1]
['* items will distribute more or less evenly into the new buckets', 1]
['ifndef LIBUV_DIR', 1]
['ngx_str_t       *etag = NULL;', 1]
["if next(msg) == nil then -- no such message. it might've expired, or maybe it was never there", 1]
['static ngx_str_t evt_chan_publish= ngx_string("channel_publish");', 1]
['bound = 1;', 1]
['d->subbed = 0;', 1]
['snprintf(buf,sizeof(buf),"Can\'t bind socket: %s",strerror(errno));', 1]
['if(mid_time > cur->msg->id.time || (mid_time == cur->msg->id.time && mid_tag >= cur->msg->id.tag.fixed[0])){', 1]
['assert(target_ch);', 1]
['test_cond("sdsrange(...,-2,-1)",', 1]
['printf("\\t(%dx PING: %.3fs)\\n", num, (t2-t1)/1000000.0);', 1]
['n.size = realsize;', 1]
['const char* cmp_strerror(cmp_ctx_t *ctx) {', 1]
['* should use the "errno" variable to find out what is wrong.', 1]
['ngx_destroy_pool(psrd->tmp_pool);', 1]
['wrong (either a protocol error, or an out of memory error).', 1]
['nchan_auth_subrequest_data_t  *psrd = &psr_stuff->psr_data;', 1]
['//first response. pretend to dequeue everything right away', 1]
['if (r->fn && r->fn->createArray)', 1]
['ngx_int_t ipc_init(ipc_t *ipc);', 1]
['nchan_channel_t     *shm_channel_info;', 1]
['chan.subscribers = chinfo->sub_count;', 1]
['#define HASH_BLOOM_BYTELEN (HASH_BLOOM_BITLEN/8) + ((HASH_BLOOM_BITLEN%8) ? 1:0)', 1]
['unsigned                        use_redis:1;', 1]
['ngx_atomic_fetch_add(&head->shared->sub_count, head->sub_count - head->internal_sub_count);', 1]
['_hs_tail->next = NULL;                                               \\', 1]
['obj->type = CMP_TYPE_SINT16;', 1]
['/* Handle end cases */                                                         \\', 1]
['if(conf->storage_engine == NULL) {', 1]
['#define EVENTSOURCE_STRINGS_N 4', 1]
['test_free_null();', 1]
['bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c);', 1]
['/* Flags */', 1]
['assert(array_sz == 5);', 1]
['retmsg.id.tag.allocd[0] = d->msg->id.tag.fixed[0];', 1]
['ngx_int_t nchan_OPTIONS_respond(ngx_http_request_t *r, const ngx_str_t *allow_origin, const ngx_str_t *allowed_headers, const ngx_str_t *allowed_methods) {', 1]
['if(accept_header) {', 1]
['bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size) {', 1]
['static ngx_buf_t       *data_prefix_buf = NULL;', 1]
['num_messages = num_messages + 1', 1]
['/* Signal event lib to clean up */', 1]
['static ngx_str_t evt_sub_enqueue = ngx_string("subscriber_enqueue");', 1]
['ngx_http_request_t         *r;', 1]
['return nchan_output_filter(fsub->sub.request, websocket_frame_header_chain(fsub, opcode, len));', 1]
['if(!(rec = ngx_alloc(sizeof(recycloc_t) + page_size))){', 1]
['INTEGER_WIDTH_TEST("hd", short);', 1]
['ngx_str_t                      val;', 1]
["if (*_p != '\\0' && *_p == '-') _p++;", 1]
['ngx_memzero(&lcf->sub_chid, sizeof(nchan_complex_value_arr_t));', 1]
['chmsg->next = NULL;', 1]
['"dbg(\' ####### FAKESUBS ####### \')\\n"', 1]
['cur = (u_char *)&stuff[1];', 1]
['/* Create a reply object */', 1]
['if(cur->next == NULL) {', 1]
['// https://github.com/openresty/echo-nginx-module', 1]
['ngx_buf_t  *mpb = (ngx_buf_t *)cmp->buf;', 1]
['/* Enlarge the free space at the end of the sds string so that the caller', 1]
['head->redis_sub = NULL;', 1]
['CMP_TYPE_BIN8,            /*  6 */', 1]
['redisReaderFeed(reader,(char*)"*0\\r\\n",4);', 1]
['static u_char            *end_boundary=(u_char *)"--\\r\\n";', 1]
['_mur_k1=0;                                                           \\', 1]
['return {ttl, time, tag, prev_time or 0, prev_tag or 0, data or "", content_type or "", es_event or ""}', 1]
['test_append_formatted_commands(cfg);', 1]
['//assert(remsg);', 1]
['int16_t  *t = max <= NCHAN_FIXED_MULTITAG_MAX ? id->tag.fixed : id->tag.allocd;', 1]
['static void *__redisBlockForReply(redisContext *c) {', 1]
['u_char                    *accept = accept_header->data;', 1]
['bool cmp_object_as_uint(cmp_object_t *obj, uint32_t *i) {', 1]
['void nchan_output_init(void) {', 1]
["if(cur[0] == ':') {", 1]
['if(tc->thing_head == cur) {', 1]
['#if defined(__sun)', 1]
['ngx_memcpy(buf, cur->msg->buf, sizeof(*buf));', 1]
['frame->step = WEBSOCKET_READ_GET_MASK_KEY_STEP;', 1]
['ngx_int_t                  responded_subs = 0;', 1]
['char                *name;', 1]
['fakebody->bufs = fakebody_chain;', 1]
['Hiredis is a minimalistic C client library for the [Redis](http://redis.io/) database.', 1]
['shdata->active_workers = 0;', 1]
['assert_equal false, getmsg(cur), "Last message should return \'false\'"', 1]
['/* Free a reply object */', 1]
['for (i = 0; i < frame->payload_len; i++) {', 1]
['/* Even on empty input string return something not NULL. */', 1]
['redisAsyncCommand(ac, redis_nginx_select_callback, context, SELECT_DATABASE_COMMAND, database);', 1]
['ERR("can\'t allocate \'shared\' memory for msg for channel id");', 1]
['l.gsub! /^(.*)$/, "  \\"\\\\1\\""', 1]
['ctx->channel_id_count = 0;', 1]
['v = tags[in_n];', 1]
['"  return id\\n"', 1]
['cur++; //include the newline', 1]
['rbtree_walk_real(seed, left, sentinel, callback, data);', 1]
['d->name = "delete";', 1]
['static ngx_int_t websocket_enqueue(subscriber_t *self) {', 1]
['hiredis-example-libev: examples/example-libev.c adapters/libev.h $(STLIBNAME)', 1]
['while (out) {                                                                   \\', 1]
['value: ["http", "websocket", "eventsource", "longpoll", "intervalpoll", "chunked", "multipart-mixed"],', 1]
['nchan_reloading_channel_t         *rlch;', 1]
['raise "scripts not loaded yet"', 1]
['#else /* assume little endian non-intel */', 1]
['#    - first: only the oldest subscriber request is kept, all others get a 409 Conflict response."', 1]
['DBG("shutdown %s %p", tc->name, tc);', 1]
['//  { ngx_string("nchan_message_alert_type"), nchan_message_alert_type_variable, 0},', 1]
['static ngx_int_t memstore_reap_message( nchan_msg_t *msg );', 1]
['const ngx_str_t NCHAN_HEADER_SEC_WEBSOCKET_ACCEPT = ngx_string("Sec-WebSocket-Accept");', 1]
['* no more replies, this is the cue to really disconnect. */', 1]
['ngx_uint_t                  generation;', 1]
['FIXMAP_SIZE          = 0xF,', 1]
['y->tv_usec -= 1000000 * nsec;', 1]
['NGX_MODULE_V1_PADDING', 1]
['aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);', 1]
['if ((ht)->type->keyDestructor) \\', 1]
['* terminated by \\r\\n. Ambiguously returns -1 for unexpected input. */', 1]
['msg.tag=lasttag+1', 1]
['nchan_msg_id_t      *msgid = NULL;', 1]
['int32_t                   overflow_n;', 1]
['if (type == INTERNAL) {', 1]
['uint32_t _mur_k1 = 0;                                                \\', 1]
['sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);', 1]
['websocket_perform_handshake(fsub);', 1]
['buf->last = end;', 1]
['ngx_uint_t         subscribers = 0;', 1]
['(ht)->type->keyDestructor((ht)->privdata, (entry)->key)', 1]
['nchan_loc_conf_t            fake_conf;', 1]
['ERR("request %p, send_header response %i", r, rc);', 1]
['static ngx_int_t spool_fetch_msg(subscriber_pool_t *spool) {', 1]
['bool cmp_read_u16(cmp_ctx_t *ctx, uint16_t *s);', 1]
['else if(cf->pub.websocket) {', 1]
['fsub->sub.request->main->count++; //this is the right way to hold and finalize the', 1]
['ngx_int_t (*init_worker)(ngx_cycle_t *cycle);', 1]
['//ignore redis://', 1]
['while ((p = nextArgument(p,&astr,&alen)) != NULL) {', 1]
['ngx_rbtree_node_t   *rbtree_find_node(rbtree_seed_t *, void *);', 1]
['len == 4+4+(3+2)+4+(0+2)+4+(3+2));', 1]
['#define REDIS_REPLY_STATUS 5', 1]
["dbg(' #######  FIND_CHANNEL ######## ')", 1]
['head = nchan_memstore_get_chanhead(d->shm_chid, &fake_conf);', 1]
['ngx_int_t nchan_maybe_send_channel_event_message(ngx_http_request_t *, channel_event_type_t);', 1]
['language: c', 1]
['lcf->sub.longpoll=0;', 1]
['//DBG("set prev");', 1]
['{ ngx_string("nchan_sub_channel_id"), //alt for nchan_subscriber_channel_id', 1]
['+---------------------------------------------------------------+', 1]
['void                       *bulk_post_subscribe_privdata;', 1]
['tag= 0', 1]
['HASH_OOPS("invalid prev %p, actual %p\\n",                          \\', 1]
['r->headers_out.content_length_n = -1;', 1]
['h->key.data = header_name->data;', 1]
['if(i >= workers) {', 1]
['*last = opcode;', 1]
['redisAsyncContext *c = rdt.sub_ctx;', 1]
['debug_pool_str.data = charbuf;', 1]
['ERR("verify_msg_id: tag mismatch. missed message?");', 1]
['* start and end can be negative, where -1 means the last character of the', 1]
['void nchan_output_init(void);', 1]
["/* default to Jenkin's hash unless overridden e.g. DHASH_FUNCTION=HASH_SAX */", 1]
['if(rp->ready(thing, 0) == NGX_OK) {', 1]
['#define REDIS_REPLY_ERROR 6', 1]
['ERR("unknown status %i", status);', 1]
['shmem_t          *shm_create(ngx_str_t *name, ngx_conf_t *cf, size_t shm_size, ngx_int_t (*init)(ngx_shm_zone_t *, void *), void *privdata);', 1]
['if (_last_elt_hh) { _last_elt_hh->next = _elt; }                     \\', 1]
['self->non_internal_sub_count--;', 1]
['uint16_t   max = max1 > max2 ? max1 : max2;', 1]
["if type(msg.content_type)=='string' and msg.content_type:find(':') then", 1]
["* to write the type's data in chunks instead of a single shot.", 1]
["case '\\'':", 1]
['//DBG("last message removed");', 1]
["while(pos < _len && s[pos] != '\\r') pos++;", 1]
['boundary[i].pos = boundary[i].start;', 1]
['*s = obj.as.s8;', 1]
['assert(rp->last == NULL && rp->first == NULL);', 1]
['redisReaderFeed(reader,(char*)"\\n",1);', 1]
['ipc_writebuf_overflow_t  *overflow_last;', 1]
['ngx_memcpy(&conf->last_message_id, &prev->last_message_id, sizeof(prev->last_message_id));', 1]
['ngx_memcpy(cur, group.data, group.len);', 1]
['DBG("tried publishing %V to chanhead %p (subs: %i)", msgid_to_str(&msg->id), head, head->sub_count);', 1]
['DBG("exit worker %i  (slot %i)", ngx_pid, ngx_process_slot);', 1]
['r->buf = NULL;', 1]
['ngx_int_t chanhead_gc_add(nchan_store_channel_head_t *head, const char *);', 1]
['#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__)             \\', 1]
['ngx_http_cleanup_t     *cln;', 1]
['int redisAppendCommand(redisContext *c, const char *format, ...) {', 1]
['for(_mur_i = -_mur_nblocks; _mur_i; _mur_i++) {                      \\', 1]
['switch(status_code) {', 1]
['copy of the buffer pointed to by `buf` for `len` bytes. This data is parsed', 1]
['void             *shm_calloc(shmem_t *shm, size_t size, const char *label);', 1]
['ngx_rbtree_node_t   *rbtree_node_from_data(void *);', 1]
['DBG("Removed node %p", node);', 1]
['_hs_q = _hs_p;                                                     \\', 1]
['return sprintf(ch, "%i", t[0]);', 1]
['_count++;                                                             \\', 1]
['static char * nchan_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child) {', 1]
['tmpid.data = vv->data;', 1]
['out->buf = buf_copy;', 1]
['ngx_int_t ipc_close(ipc_t *ipc, ngx_cycle_t *cycle);', 1]
['"--  \'subscriber_id\' can be \'-\' for new id, or an existing id\\n"', 1]
['bool cmp_read_s64(cmp_ctx_t *ctx, int64_t *l);', 1]
['internal_subscriber_t *fsub = (internal_subscriber_t *)ev->data;', 1]
['static uint64_t be64(uint64_t x) {', 1]
['size_t lens[3] = { 3, 7, 3 };', 1]
['#nchan_subscriber_concurrency [:main, :srv, :loc, :if],', 1]
['bc.buf.end = ngx_snprintf(cbuf, 50, ("--%V"), nchan_request_multipart_boundary(r, ctx));', 1]
['sds sdscatprintf(sds s, const char *fmt, ...)', 1]
['if(self->want_to_stop) {', 1]
['r->write_event_handler = nchan_flush_pending_output;', 1]
['DBG("non-null-terminated filename. gotta copy.");', 1]
['a single call to `read(2)`):', 1]
['//ERR("ipc_alert_t size %i bytes", sizeof(ipc_alert_t));', 1]
['c = redisConnectUnixNonBlock(path);', 1]
['for(i=0; i< reply->elements; i++) {', 1]
['if (chan) {', 1]
['subscriber_t *intervalpoll_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id);', 1]
["elseif no_msgid_order == 'FILO' then --oldest message", 1]
['time_t                          last_seen;', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:CHUNKED:" fmt, ##arg)', 1]
['int redisLibuvAttach(redisAsyncContext*, uv_loop_t*);', 1]
['const struct timeval *timeout) {', 1]
['fsub->data.timeout_ev.cancelable = 1;', 1]
['uint8_t   u8;', 1]
["/* Reads a string's size from the backend */", 1]
['ngx_shm_zone_t    *zone;', 1]
['h = dictHashKey(ht, he->key) & n.sizemask;', 1]
['cd = &cd_data;', 1]
['return cmp_write_u32(ctx, (uint32_t) u);', 1]
['nchan_store_channel_head_t  *head;', 1]
['buf->end = end;', 1]
['ngx_int_t (*get_message) (ngx_str_t *, nchan_msg_id_t *, callback_pt, void *);', 1]
['/* Size: short */', 1]
['//ERR("id1 is smaller. -1");', 1]
['break; /* Nothing to free */', 1]
['#ifndef __HIREDIS_LIBEVENT_H__', 1]
['void *_reply;', 1]
['bool cmp_write_fixext1(cmp_ctx_t *ctx, int8_t type, const void *data) {', 1]
['if(tag1 > tag2) {', 1]
['nchan_create_websocket_publisher(r);', 1]
['fsub->timeout_handler = empty_handler;', 1]
['int yes = 1;', 1]
['&websocket_dequeue,', 1]
['DBG("get message from %V (n: %i) %V", getmsg_chid, i, msgid_to_str(&req_msgid[i]));', 1]
['ngx_buf_t              double_newline_buf;', 1]
['/* If monitor mode, repush callback */', 1]
['* Issue #45: Fix potential memory leak for a multi bulk reply with 0 elements', 1]
['msg.prev_time or 0,', 1]
['return s+pos;', 1]
['d->callback(d->code, d->shm_channel_info, d->privdata);', 1]
['#define REDIS_REPLY_ARRAY 2', 1]
[':nchan_set_pub_channel_id,', 1]
['DBG("set shdata->procslot[%i] = %i", offset, slot);', 1]
['dbg(("found msg %s:%s  after %s:%s"):format(tostring(msg.time), tostring(msg.tag), tostring(time), tostring(tag)))', 1]
['case SUB_RECEIVE_STATUS:', 1]
['if(fsub->sub.cf->sub.websocket) {', 1]
['hashv += keylen;                                                               \\', 1]
['bool cmp_write_fixext8(cmp_ctx_t *ctx, int8_t type, const void *data);', 1]
['"local num_messages = 0\\n"', 1]
['} nchan_main_conf_t;', 1]
['for(rlch = shdata->rlch; rlch != NULL; rlch = rlch->next) {', 1]
['#include <sys/un.h>', 1]
['char *current = NULL;', 1]
['sds sdsgrowzero(sds s, size_t len);', 1]
['"requested: %d" CRLF', 1]
['cbuf->end = cbuf->start + ngx_buf_size(buf);', 1]
["case 'a': case 'A': return 10;", 1]
['store_message_t             *chmsg;', 1]
['static ngx_int_t remove_spool(subscriber_pool_t *spool) {', 1]
['} full_subscriber_t;', 1]
['sds sdscatsds(sds s, const sds t);', 1]
['*d = obj->as.dbl;', 1]
['## Reply parsing API', 1]
['#define SPOOL_HEADER', 1]
['ERR("can\'t allocate message for reloading. stop trying.");', 1]
['ipc_writebuf_t         wbuf;', 1]
['printf("\\t(%dx PING (pipelined): %.3fs)\\n", num, (t2-t1)/1000000.0);', 1]
['return cur - ch - 1;', 1]
['return nchan_store_publish_message_generic(channel_id, msg, 0, cf, callback, privdata);', 1]
['nchan_OPTIONS_respond(r, &cf->allow_origin, &NCHAN_ACCESS_CONTROL_ALLOWED_PUBLISHER_HEADERS, &NCHAN_ALLOW_GET_POST_PUT_DELETE_OPTIONS);', 1]
['p = ngx_slab_alloc_locked(SHPOOL(shm), size);', 1]
['if(CHECK_REPLY_STR(el)) {', 1]
['* to do that in this order, as the value may just be exactly the same', 1]
['#define NGX_POOL_ENTRY_FORMAT   "size:%12z num:%12z cnum:%12z lnum:%12z %s\\n"', 1]
['ngx_queue_t                    queue;', 1]
['if (obj.type != CMP_TYPE_SINT32) {', 1]
['"if num==nil then\\n"', 1]
['content_length = r->headers_in.content_length_n > 0 ? r->headers_in.content_length_n : 0;', 1]
['static ngx_int_t destroy_spool(subscriber_pool_t *spool);', 1]
['cfg.unix.path = argv[0];', 1]
['u_char                          channel_info_buf_str[512]; //big enough', 1]
['time = tv.tv_sec;', 1]
['rp->strategy = RESCAN;', 1]
['buf->file_pos=0;', 1]
['#ifndef uthash_malloc', 1]
['ngx_atomic_fetch_add(&head->shared->internal_sub_count, -count);', 1]
['if(code == 0) {', 1]
['$(INSTALL) $(STLIBNAME) $(INSTALL_LIBRARY_PATH)', 1]
['void redis_nginx_close_context(redisAsyncContext **context);', 1]
['ngx_memzero(&rdt.subscriber_channel, sizeof(rdt.subscriber_channel));', 1]
['bool cmp_write_fixext8(cmp_ctx_t *ctx, int8_t type, const void *data) {', 1]
['rbtree_insert_node(&spl->spoolseed, node);', 1]
['#include <netinet/in.h>', 1]
['} nchan_complex_value_arr_t;', 1]
['#define NCHAN_DEFAULT_CHANNEL_TIMEOUT 5 //default: timeout in 5 seconds', 1]
['def _empty_is_nil(v)', 1]
['publisher_upstream_request_url_ccv = fsub->sub.cf->publisher_upstream_request_url;', 1]
['(head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket));      \\', 1]
['if(r->postponed) {', 1]
['nchan_respond_status(r, NGX_HTTP_NOT_FOUND, NULL, 0);', 1]
['ifeq ($(uname_S),Darwin)', 1]
['bool cmp_read_ext32_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size) {', 1]
['shm = shm_create(&name, cf, conf->shm_size, initialize_shm, &nchan_module);', 1]
['*ret_id = id_out;', 1]
['bc[3].chain.next = NULL;', 1]
['static ngx_int_t internal_respond_message(subscriber_t *self, nchan_msg_t *msg) {', 1]
['* Returns REDIS_ERR if an error occured trying to write and sets', 1]
['case WEBSOCKET_READ_GET_MASK_KEY_STEP:', 1]
['static int processBulkItem(redisReader *r) {', 1]
['{ ngx_string("nchan_channel_timeout"),', 1]
['def id(msgid=nil)', 1]
['value: "<size>",', 1]
['/* Destroy internal buffer when it is empty and is quite large. */', 1]
['struct dict; /* dictionary header is included in async.c */', 1]
['static       ngx_str_t   sub_name = ngx_string("intervalpoll");', 1]
['bool cmp_write_fixstr(cmp_ctx_t *ctx, const char *data, uint8_t size);', 1]
['ERR("::BENCH:: channel %V msg %p <%V> len %i responded to %i in %l.%06l sec", &head->id, msg, msgid_str, ngx_buf_size(msg->buf), head->spooler.last_responded_subscriber_count, (long int)(diff.tv_sec), (long int)(diff.tv_usec));', 1]
['"  redis.call(\'EXPIRE\', key.time_offset, channel.ttl)\\n"', 1]
['static void its_reaping_time(nchan_reaper_t *rp, uint8_t force);', 1]
['if (_hd_hh_del->next) {                                                  \\', 1]
['ngx_memcpy(cbuf->file->name.data, buf->file->name.data, buf->file->name.len);', 1]
['following two execution paths:', 1]
['ac->ev.addRead = redisLibeventAddRead;', 1]
['//DBG("squeezed in overflow at %i, %i overflow remaining", i, proc->wbuf.overflow_n);', 1]
['ERR("get_msg_from_msgkey channel id is NULL");', 1]
['{ ngx_string("nchan_redis_url"),', 1]
['const ngx_str_t NCHAN_HEADER_SEC_WEBSOCKET_VERSION = ngx_string("Sec-WebSocket-Version");', 1]
['const  ngx_str_t NCHAN_ACCESS_CONTROL_ALLOWED_SUBSCRIBER_HEADERS = ngx_string("If-None-Match, If-Modified-Since, Origin");', 1]
['/* Unlink the element from the list */', 1]
['test("%%b String interpolation works: ");', 1]
['bool cmp_write_u64(cmp_ctx_t *ctx, uint64_t l);', 1]
['ngx_int_t           multi_count;', 1]
["x[1] = '1';", 1]
['void nchan_update_multi_msgid(nchan_msg_id_t *oldid, nchan_msg_id_t *newid) {', 1]
['uint8_t active = id2->tagactive;', 1]
['nchan_llist_timed_t   *thing_head;', 1]
['nchan_msg_status_t           status;', 1]
["dbg(' ####### PUBLISH STATUS ####### ')", 1]
['d->sender = sender;', 1]
['"if next(channel) == nil then\\n"', 1]
['if(dir == RBTREE_WALK_LEFT_RIGHT) {', 1]
['#define HIREDIS_MINOR 11', 1]
['case 4:  _hj_i += ( (unsigned)_hj_key[3] << 24 );                           \\', 1]
['cur = tc->thing_head;', 1]
['//sub should be destroyed by now.', 1]
['ipc_write_handler(ev);', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:LONGPOLL:" fmt, ##arg)', 1]
['get_multi_message_data_single_t  *sd = ngx_alloc(sizeof(*sd), ngx_cycle->log);', 1]
['if(head->use_redis && head->status != READY) {', 1]
['void nchan_match_channel_info_subtype(size_t off, u_char *cur, size_t rem, u_char **priority, const ngx_str_t **format, ngx_str_t *content_type);', 1]
['#define NCHAN_OLDEST_MSGID {0, {{0}}, 1, 0}', 1]
['case RESCAN:', 1]
['if(self->first != NULL) {', 1]
['Hiredis comes with a reply parsing API that makes it easy for writing higher', 1]
['an idle buffer changing the value of the `maxbuf` field of the reader structure', 1]
['chanhead_delete_message(ch, msg);', 1]
['to the desired value. The special value of 0 means that there is no maximum', 1]
['ngx_int_t                     owner;', 1]
['case 127:', 1]
['ngx_memcpy(cbuf, buf, sizeof(*buf)); //overkill?', 1]
['subscriber_t                  *sub;', 1]
['ngx_int_t          offset = memstore_procslot_offset + n;', 1]
["This function immediately closes the socket and then free's the allocations done in", 1]
['static int redisCreateSocket(redisContext *c, int type) {', 1]
['msg_time, msg_tag = msg.split(":")', 1]
['static ngx_int_t nchan_store_async_get_multi_message_callback(nchan_msg_status_t status, nchan_msg_t *msg, get_multi_message_data_single_t *sd) {', 1]
['ngx_str_t      alt_err;', 1]
['/* Store callback in list */', 1]
['//ERR("fsub: %p, frame: %p", fsub, frame);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:MEM-IPC:" fmt, ##arg)', 1]
['static void test_format_commands(void) {', 1]
['struct ipc_s {', 1]
['_last_elt = _elt;                                                    \\', 1]
['nchan_output_filter(r, first_chain);', 1]
['ngx_int_t                       max_messages;', 1]
['/* Connection type can be blocking or non-blocking and is set in the', 1]
['struct sockaddr_un sa;', 1]
['last_chain->next = &chains[0];', 1]
['f->dequeue_handler = cb;', 1]
['*d = obj.as.s32;', 1]
['test_cond(reply->len == 11)', 1]
['chead->channel.expires = ngx_time() + cf->buffer_timeout;', 1]
['c->data = proc;', 1]
['#define HASH_SIGNATURE 0xa0111fe1', 1]
['#define NCHAN_MULTITAG_MAX 255', 1]
['+-------------------------------- - - - - - - - - - - - - - - - +', 1]
['if(self->bulk_post_subscribe_handler != NULL && subtype != INTERNAL) {', 1]
['rp->first = NULL;', 1]
['info: "Amount of time an empty channel hangs around. Don\'t mess with this setting unless you know what you are doing!"', 1]
['store_message_t           *next;', 1]
['strcmp(c->errstr,"No address associated with hostname") == 0 ||', 1]
['static ngx_int_t nchan_publisher_body_authorize_handler(ngx_http_request_t *r, void *data, ngx_int_t rc) {', 1]
['"    msg.tag=lasttag+1\\n"', 1]
['ch->expires = ngx_time() + r->element[0]->integer;', 1]
['#define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))', 1]
['*first_chain=&bc->chain;', 1]
['bool cmp_object_to_bin(cmp_ctx_t *ctx, cmp_object_t *obj, void *data, uint32_t buf_size);', 1]
['bool cmp_object_is_sinteger(cmp_object_t *obj);', 1]
['ngx_rbtree_node_t  sentinel;', 1]
['sleep 1.5', 1]
['sleep 1.6', 1]
['the disconnect callback is a good point to do so.', 1]
['cur->prev=NULL;', 1]
['sdsrange(r->buf,r->pos,-1);', 1]
['int success = 0;', 1]
['//  nchan_store_channel_head_t   *chanhead;', 1]
['c->obuf = newbuf;', 1]
['chan.last_seen = chinfo->last_seen;', 1]
['#define MUR_ONE_THREE(p) ((((*WP(p))&0x000000ff) <<24) | (((*(WP(p)+1))&0xffffff00) >>  8))', 1]
['if(spl->running) {', 1]
['//nchan_loc_conf_t             *cf = d->sub->cf;', 1]
['static ngx_inline int8_t msgid_tag_compare(nchan_msg_id_t *id1, nchan_msg_id_t *id2) {', 1]
['return cmp_write_fixext1_marker(ctx, tp);', 1]
['bool cmp_write_ext32_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size) {', 1]
['//I trust the cycle pool size to be a well-tuned one.', 1]
['ngx_int_t                   slot = memstore_slot();', 1]
['const char *_p = c+1;', 1]
['cf->storage_engine->delete_channel(channel_id, (callback_pt) &channel_info_callback, (void *)r);', 1]
['reply->element[0]->elements == 2 &&', 1]
['#include <subscribers/longpoll.h>', 1]
['#define NCHAN_DEFAULT_INTERNAL_SUBSCRIBER_POOL_SIZE 1024', 1]
['wrong.', 1]
['void sdsIncrLen(sds s, int incr);', 1]
['tv.tv_nsec=8000000;', 1]
['* considering as content only up to the first null term character.', 1]
['const  ngx_str_t NCHAN_HTTP_STATUS_101 = ngx_string("101 Switching Protocols");', 1]
['mpt = &mdata[slot];', 1]
['ngx_int_t msg_release(nchan_msg_t *msg, char *lbl);', 1]
['n = chead->multi_count;', 1]
['ngx_int_t nchan_subscriber_authorize_subscribe(subscriber_t *sub, ngx_str_t *ch_id) {', 1]
['* takes a format similar to printf:', 1]
['ch->in_churn_queue = 1;', 1]
['return cmp_write_double(ctx, d);', 1]
['* control needs to be returned to redisProcessCallbacks() before actual', 1]
['int         chr_int;', 1]
['dbg("channel ", id, " already gone")', 1]
['int res;', 1]
['* is used, you need to call redisGetReply yourself to retrieve', 1]
['ngx_rwlock_t                   lock;', 1]
['static       ngx_str_t   sub_name = ngx_string("http-chunked");', 1]
['nchan_memstore_publish_generic(head, d->shm_msg, 0, NULL);', 1]
['/* Copy the provided buffer. */', 1]
['ngx_rbtree_t                  tree;', 1]
['/* Turn the string into a smaller (or equal) string containing only the', 1]
['nchan_respond_string(r, NGX_HTTP_NOT_FOUND, &NCHAN_CONTENT_TYPE_TEXT_PLAIN, &NO_CHANNEL_ID_MESSAGE, 0);', 1]
['throughput = 0;', 1]
['_hs_tail = _hs_e;                                              \\', 1]
['#ifndef SPOOL_HEADER', 1]
['last = msg_buf->end;', 1]
['struct timeval                  tv;', 1]
['nchan_reaper_strategy_t    strategy;', 1]
['static ngx_chain_t *websocket_msg_frame_chain(full_subscriber_t *fsub, nchan_msg_t *msg) {', 1]
['#include "dict.h"', 1]
['ngx_conf_log_error(NGX_LOG_WARN, cf, 0, "ignoring obsolete nchan config directive \'%V %V;\'. Only \'broadcast\' is currently supported.", &cmd->name, val);', 1]
["* free'ing. To do so, a flag is set on the context which is picked up by", 1]
['if (iter->index >=', 1]
['* to know the descriptor is at EOF. */', 1]
['fakeprocess_top = link;', 1]
['extern ngx_int_t internal_subscriber_destroy(subscriber_t *sub);', 1]
['assert(procslot_found == 1);', 1]
['#define REDIS_BLOCK 0x1', 1]
['//publish_status', 1]
['static void *createIntegerObject(const redisReadTask *task, long long value) {', 1]
['d->shared_channel_data = head->shared;', 1]
['if(ws_version != 13) {', 1]
['subscriber_pool_t                *spool;', 1]
['static ngx_int_t longpoll_release(subscriber_t *self, uint8_t nodestroy) {', 1]
['struct ngx_rbtree_debug_node_s  *prev;', 1]
['retmsg.id.tagactive = n;', 1]
["/* Append the specified sds 't' to the existing sds 's'.", 1]
['#define HASH_BER(key,keylen,num_bkts,hashv,bkt)                                  \\', 1]
['nchan_msg_id_t   *id = (nchan_msg_id_t *)vid;', 1]
['Because commands are sent to Redis asynchronously, issuing a command requires a callback function', 1]
['if (cb == NULL)', 1]
['Open3.popen2e(\'luac\', "-p", @@files[name]) do |stdin, stdouterr, process|', 1]
['*d = obj->as.s8;', 1]
['extern const  ngx_str_t NCHAN_HTTP_STATUS_409;', 1]
['snprintf(buf,sizeof(buf),"Can\'t create socket: %s",strerror(errno));', 1]
['ngx_int_t              owner = memstore_channel_owner(&ch->id);', 1]
['*d = obj->as.u32;', 1]
['ngx_memset(cur, 0xC4, sizeof(*cur)); //debugstuffs', 1]
['* With the items distributed into more buckets, the chain length', 1]
['cur_first = cur;', 1]
['NGX_RWLOCK_MUTEX_COND(lock, lock->lock != NGX_RWLOCK_WRITE && lock->lock != 0, lock->lock--)', 1]
['last = str->data + str->len;', 1]
['h->hash = nchan_content_length_hash;', 1]
['* Write a formatted command to the output buffer. If the given context is', 1]
['ngx_str_t                      *accept_header = NULL;', 1]
['if(self->cf->subscriber_timeout > 0 && !fsub->timeout_ev.timer_set) {', 1]
['if (src) {                                                                     \\', 1]
['memstore_ensure_chanhead_is_ready(d->multi_chanhead, 1);', 1]
['p->events &= ~UV_READABLE;', 1]
['static ngx_int_t es_respond_status(subscriber_t *sub, ngx_int_t status_code, const ngx_str_t *status_line){', 1]
['DBG("%p memstore-redis subscriber respond with message", d->sub);', 1]
["//don't buffer the request body --send it right on through", 1]
['if(smsg->msg->expires > ngx_time()) {', 1]
['#else /* non intel */', 1]
['#endif // __REDIS_NGINX_ADAPTER_H', 1]
['const  ngx_str_t NCHAN_HTTP_STATUS_410 = ngx_string("410 Gone");', 1]
["The upstream response code determine how publishing will proceed. A `200 OK` will publish the message from the upstream response's body. A `304 Not Modified` will publish the message as it was received from the publisher. A `204 No Content` will result in the message not being published.", 1]
['* following schema, to cat bytes coming from the kernel to the end of an', 1]
['buf->pos = dst_str.data;', 1]
['nchan_store_t   *default_storage_engine = &nchan_store_memory;', 1]
['assert(spool->id.time == id->time);', 1]
['return { msg.tag, {tonumber(channel.ttl or msg.ttl), tonumber(channel.time or msg.time), tonumber(channel.fake_subscribers or channel.subscribers or 0), tonumber(num_messages)}, new_channel}', 1]
['static rbtree_walk_direction_t collect_spool_range(rbtree_seed_t *seed, subscriber_pool_t *spool, spooler_respond_data_t *data) {', 1]
['static ngx_int_t chanhead_push_message(nchan_store_channel_head_t *ch, store_message_t *msg) {', 1]
["ngx_memset(buf->start, '\\0', content_length + 1);", 1]
['assert(p);', 1]
['test("Don\'t fail when freeReplyObject is passed a NULL value: ");', 1]
['ngx_int_t         tag2;', 1]
['default: ["http", "websocket"],', 1]
['int16_t          mid_tag; //optimization yeah', 1]
['sh->free = sh->free+(sh->len-newlen);', 1]
['#define HASH_INITIAL_NUM_BUCKETS 32      /* initial number of buckets        */', 1]
['redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {', 1]
['ngx_atomic_int_t                   procslot[NGX_MAX_PROCESSES];', 1]
['ngx_log_error(NGX_LOG_ERR, log, 0, "nchan IPC: read() returned not enough data: %z", n);', 1]
['if (!cb) {', 1]
['d->d.resp.shm_msg = msg == NULL ? NULL : msg->msg;', 1]
['de = dictFind(callbacks,sname);', 1]
['(add)->hh.keylen = (unsigned)(keylen_in);                                       \\', 1]
['* contained string remains not altered, but next concatenation operations', 1]
['if(d->multi_count > NCHAN_FIXED_MULTITAG_MAX) {', 1]
['cmp_reader  read;', 1]
['fname = filename->data;', 1]
['sds curarg, newarg; /* current argument */', 1]
['ev->timedout = 0;', 1]
['node->right = sentinel;', 1]
['* **`REDIS_REPLY_STRING`**:', 1]
['"return {sub_id, sub_count}"', 1]
['local new_channel = false', 1]
['if (errno == EINPROGRESS && !blocking) {', 1]
['ngx_str_t              *origin_header;', 1]
['void msg_debug_remove(nchan_msg_t *msg) {', 1]
['/* -------------------------- hash functions -------------------------------- */', 1]
['"      return {404, nil}\\n"', 1]
['dbg("channel present")', 1]
['static char *seekNewline(char *s, size_t len) {', 1]
['rdt.chanhead_cleanup_tail=cl->prev;', 1]
['if (ac->onConnect) ac->onConnect(ac,REDIS_ERR);', 1]
["require 'open3'", 1]
['convert it to the protocol used to communicate with Redis.', 1]
['/* Tries to do a clean disconnect from Redis, meaning it stops new commands', 1]
['TRUE_MARKER            = 0xC3,', 1]
['lock->lock=NGX_RWLOCK_WRITE;', 1]
['redis_nginx_open_context(u_char *host, int port, int database, u_char *password, redisAsyncContext **context)', 1]
['ngx_buf_t                   buf;', 1]
['its_reaping_time(rp, 0);', 1]
['/* Set first item to process when the stack is empty. */', 1]
['if (!tokens) return;', 1]
['//any subscribers?', 1]
['if(ch->status == WAITING && !ch->use_redis) {', 1]
['/* Connect to a Redis instance. On error the field error in the returned', 1]
['typedef struct nchan_llist_timed_s {', 1]
['"for k,channel_key in pairs(redis.call(\'SMEMBERS\', subs_key)) do\\n"', 1]
['if(r->connection->data == sr) {', 1]
['test("Format command with an empty string in between proper interpolations: ");', 1]
['msec = (timeout->tv_sec * 1000) + ((timeout->tv_usec + 999) / 1000);', 1]
['redisInitScripts(c);', 1]
['ERR("invalid ttl integer value is msg response from redis");', 1]
['nchan_eventsource_event [:srv, :loc, :if],', 1]
['ngx_int_t nchan_copy_new_msg_id(nchan_msg_id_t *dst, nchan_msg_id_t *src);', 1]
['#define HASH_OAT(key,keylen,num_bkts,hashv,bkt)                                  \\', 1]
['info: "Maximum permissible channel id length (number of characters). Longer ids will be truncated."', 1]
['ngx_snprintf(rdt.subscriber_channel, 255, "nchan:%s", rdt.subscriber_id);', 1]
['* Another possibility is that the server is loading its dataset.', 1]
['if (end < 0) end = 0;', 1]
['}; //spooled_subscriber_t', 1]
['ngx_http_complex_value_t       *channel_event_string;', 1]
["if redis.call('EXISTS', key.next_message)~=0 then", 1]
['else if (type_marker == EXT8_MARKER) {', 1]
['if (cmd != NULL)', 1]
['head->channel.last_seen = t;', 1]
['head = nchan_memstore_find_chanhead(channel_id);', 1]
['redisContextConnectUnix(c,path,&tv);', 1]
['ngx_int_t (*init_postconfig)(ngx_conf_t *cf);', 1]
['"local check_concurrency_in = function(i, id)\\n"', 1]
['start_spooler(&head->spooler, &head->id, &head->status, &nchan_store_memory);', 1]
['sh = realloc(sh, sizeof *sh+sh->len+1);', 1]
['* operation. */', 1]
['assert(redisSetTimeout(c,tv) == REDIS_OK);', 1]
['rsv->lbl = (char *)(&rsv[1]);', 1]
['shdata->active_workers--;', 1]
['rds_ctx_teardown(ac);', 1]
['bool cmp_read_u32(cmp_ctx_t *ctx, uint32_t *i) {', 1]
['/* Clear & Release the hash table */', 1]
['argv[0] = "SET";', 1]
['tags2 = (id2->tagcount <= NCHAN_FIXED_MULTITAG_MAX) ? id2->tag.fixed : id2->tag.allocd;', 1]
['* integer from 0 to 15 */', 1]
['void nchan_output_shutdown(void);', 1]
['void                      *position;', 1]
['ngx_int_t            (*set_bulk_post_subscribe_handler)(channel_spooler_t *, void (*cb)(channel_spooler_t *, int, void *), void*);', 1]
['ngx_str_t *msgtag_to_str(nchan_msg_id_t *id);', 1]
['void                *cur = rp->first, *next;', 1]
['zone->data = data;', 1]
['if(mpt->chanhead_reaper.count > 0) {', 1]
['#define HASH_FNV(key,keylen,num_bkts,hashv,bkt)                                  \\', 1]
['static nchan_content_subtype_t subtypes[] = {', 1]
['bytelen += len+2; /* include \\r\\n */', 1]
['command according to the Redis protocol. The formatted command is then put in the output buffer', 1]
['r->headers_out.content_type.data = content_type->data;', 1]
["case 'd': case 'D': return 13;", 1]
['msg.prev_time = 0', 1]
['ngx_int_t          n;', 1]
['if new_channel then', 1]
['evcf->storage_engine = cf->storage_engine;', 1]
['ngx_memcpy(&len, frame->header, 8);', 1]
['ctx->request_origin_header.len=0;', 1]
['legacy: "push_channel_timeout",', 1]
['else out=NULL;                                                                  \\', 1]
['void *data = ac->data;', 1]
['ipc_alert_handler[code](sender, data);', 1]
['static ngx_str_t evt_sub_recvmsg = ngx_string("subscriber_receive_message");', 1]
['head->owner = owner;', 1]
['node->right = NULL;', 1]
['subscriber_pool_t    *spool, *nuspool;', 1]
['it is used like this:', 1]
['// static void __test_callback(redisContext *c, void *privdata) {', 1]
['#define IPC_WRITEBUF_SIZE 32', 1]
['ac->errstr = c->errstr;', 1]
['bool cmp_read_decimal(cmp_ctx_t *ctx, double *d);', 1]
['obj = (void*)REDIS_REPLY_ARRAY;', 1]
['lock->write_pid = 0;', 1]
['const ngx_str_t NCHAN_UPGRADE = ngx_string("Upgrade");', 1]
['nchan_store_channel_head_t *nchan_memstore_find_chanhead(ngx_str_t *channel_id);', 1]
['msg->lbl.len = m->lbl.len;', 1]
['f->dequeue_handler(self, f->dequeue_handler_data);', 1]
["//great, we've gotta scan this whole damn file for line breaks.", 1]
['cur = copy_preallocated_str_to_cur(&buf->file->name, &mbuf->file->name, cur);', 1]
['//got all the messages we wanted', 1]
['end = len-1;', 1]
['_h ^= _h >> 13;    \\', 1]
['subscriber_t              *dbg_prev;', 1]
['msg.eventsource_event or ""', 1]
['#if (DEBUG_NGX_RWLOCK)', 1]
['} get_multi_message_data_single_t;', 1]
['self->dequeue_handler_privdata = privdata;', 1]
['* or set an error in the context otherwise. */', 1]
['ngx_fd_t        fd;', 1]
['ch.messages = d->messages;', 1]
['//generate accept key', 1]
['DBG("fdcache close fd %i", fd);', 1]
['bool cmp_write_s16(cmp_ctx_t *ctx, int16_t s);', 1]
['"-- \'subscriber_id\' is an existing id\\n"', 1]
['static ngx_int_t redis_subscriber_unregister(ngx_str_t *channel_id, subscriber_t *sub);', 1]
['* only redisAppendCommand and will always return NULL. */', 1]
['cmp_err(cmp);', 1]
['static void memstore_reap_churned_chanhead(nchan_store_channel_head_t *ch) { //different method for some debug tracing', 1]
['if (!cmp_read_fixext4_marker(ctx, type))', 1]
['if(global_redis_enabled && nchan_store_redis.init_worker(cycle)!=NGX_OK) {', 1]
['d->target_chanhead = target_ch;', 1]
['void (*delRead)(void *privdata);', 1]
['if(count == shdata->max_workers) {', 1]
['if(lock->write_pid != ngx_pid) {', 1]
['totlen = sh->free+sh->len;', 1]
['/* Note that HASH_SORT assumes the hash handle name to be hh.', 1]
['* the descriptor to which this macro is defined for tuning the hash function.', 1]
['printf("\\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\\n", num, (t2-t1)/1000000.0);', 1]
['ngx_int_t                     n;', 1]
['nchan_store_find_channel(channel_id, subscribe_existing_channel_callback, d);', 1]
['@@scripts[scriptname]=IO.read f', 1]
['bc.buf.end = end_boundary + 4;', 1]
["CC:=$(shell sh -c 'type $(CC) >/dev/null 2>/dev/null && echo $(CC) || echo gcc')", 1]
['debug_pool_str.len = p - debug_pool_str.data;', 1]
['sub->type = HTTP_CHUNKED;', 1]
['uint8_t                  write_aborted = 0;', 1]
['//eventsource_event', 1]
['if (list->tail != NULL)', 1]
['if (cond(_elt)) {                                                      \\', 1]
['int pvariant;', 1]
['dbg(list_key, " is empty")', 1]
['arguments `argvlen`. For convenience, `argvlen` may be set to `NULL` and the function will', 1]
['nchan_ignore_obsolete_setting,', 1]
['static ngx_int_t nchan_store_async_get_message(ngx_str_t *channel_id, nchan_msg_id_t *msg_id, callback_pt callback, void *privdata);', 1]
['obj->as.map_size = be16(obj->as.u16);', 1]
['ngx_http_post_subrequest_t    *psr;', 1]
['"12ed3f03a385412690792c4544e4bbb393c2674f",', 1]
['#define IPC_DOES_CHANNEL_EXIST      15', 1]
['void sdsclear(sds s) {', 1]
['STR8_MARKER            = 0xD9,', 1]
['subscriber_pool_t     *spl;', 1]
['iter->entry = iter->nextEntry;', 1]
['e.request = r;', 1]
['if((ch = nchan_memstore_find_chanhead(channel_id))) {', 1]
['} redisCallback;', 1]
['reply = redisCommand(c,"LPUSH mylist element-%s", buf);', 1]
['INTEGER_WIDTH_TEST("lu", unsigned long);', 1]
['msg->rsv = next;', 1]
["//just copy the buffer contents. it's inefficient but I don't care at the moment.", 1]
['} cmp_object_t;', 1]
['uintptr_t i=(uintptr_t) privdata;', 1]
['nchan_channel_t channel;', 1]
['psrd->ch_id = ch_id;', 1]
['* that it matters.', 1]
['//  DBG("got a worse response %V (n:%i), keep prev.", msgid_to_str(&msg->id), sd->n);', 1]
['char *buf;', 1]
['#include <stdlib.h>   /* exit() */', 1]
['//d->hcln = put_current_subscribers_in_limbo(head);', 1]
['static void multipart_ensure_headers_sent(full_subscriber_t *fsub) {', 1]
['info: "The maximum number of messages to store per channel. A channel\'s message buffer will retain a maximum of this many most recent messages."', 1]
['//subscriber types', 1]
['assert(originator_slot != memstore_slot());', 1]
['if(proc->wbuf.overflow_first == NULL) {', 1]
['/* remove an item from a given bucket */', 1]
['} ipc_process_t;', 1]
['buf = request_chain->buf;', 1]
['DBG("that was a reload just now");', 1]
['memcpy(sh->buf, init, initlen);', 1]
['if(!write_aborted) {', 1]
['if(newspool->non_internal_sub_count > 0 && spl->bulk_post_subscribe_handler != NULL) {', 1]
['ngx_int_t           i;', 1]
['case \'\\t\': s = sdscatlen(s,"\\\\t",2); break;', 1]
['ngx_int_t internal_subscriber_set_enqueue_handler(subscriber_t *sub, callback_pt handler);', 1]
['* pattern that is unsubscribed will receive a message. This means we', 1]
['len = len < (sizeof(r->errstr)-1) ? len : (sizeof(r->errstr)-1);', 1]
['buf->pos += limit;', 1]
['CMP_TYPE_SINT8,           /* 18 */', 1]
['LENGTH_WRITING_ERROR,', 1]
['ngx_int_t            code;', 1]
['uint32_t _mur_h1 = 0xf88D5353;                                       \\', 1]
['rp->timer.data = rp;', 1]
['last_msgid = &zero_msgid;', 1]
['while(cur != NULL && now > cur->msg->expires) {', 1]
['chains[1].buf = buf;', 1]
['if (!cmp_write_fixext4_marker(ctx, type))', 1]
['rsv->next = NULL;', 1]
['if (tmp_pool != NULL) {', 1]
['clnf = cln->data;', 1]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,"getsockopt(SO_ERROR)");', 1]
['def to_s', 1]
['if(pd->ch.messages < ch->messages) {', 1]
['struct ipc_writebuf_overflow_s {', 1]
['bool cmp_object_as_uinteger(cmp_object_t *obj, uint64_t *u);', 1]
['assert(sub->dbg_prev == NULL);', 1]
['bkt = hashv & (num_bkts-1);                                                  \\', 1]
['conf->channel_event_string = prev->channel_event_string;', 1]
['/* initial number of buckets */', 1]
['callback_pt             notify;', 1]
['len = content_length;', 1]
['scriptname=File.basename(f, ".lua").to_sym', 1]
['content_type = &cur->msg->content_type;', 1]
['}; // subscriber_pool_t', 1]
['//DBG("try to squeeze in overflow between %i and %i", first, last);', 1]
['if(old_largetags) {', 1]
['cd->allocd=0;', 1]
['void redisAsyncHandleWrite(redisAsyncContext *ac) {', 1]
['uint8_t                      use_redis;', 1]
['ngx_int_t nchan_response_channel_ptr_info(nchan_channel_t *channel, ngx_http_request_t *r, ngx_int_t status_code) {', 1]
['ngx_int_t                       last_expected_process = ngx_last_process;', 1]
['lcode = *(ngx_http_script_len_code_pt *) e.ip;', 1]
["*cur++='-';", 1]
['store_message_t             *shmsg_link;', 1]
['//init loop', 1]
['ngx_str_t                     *multipart_boundary;', 1]
['if(cf->longpoll_multimsg) {', 1]
['FIXEXT16_MARKER        = 0xD8,', 1]
['nchan_pub_upstream_data_t     *psrd;', 1]
['void ngx_rwlock_reserve_write(ngx_rwlock_t *lock);', 1]
['if (de != NULL) {', 1]
['ngx_str_t *val = cf->args->elts;', 1]
['if (!ctx->read(ctx, &obj->as.s8, sizeof(int8_t))) {', 1]
['channel_spooler_t    *spl = spool->spooler;', 1]
['bool cmp_read_fixext16_marker(cmp_ctx_t *ctx, int8_t *type) {', 1]
['return ctx->write(ctx, &s, sizeof(int16_t));', 1]
['full_subscriber_t      *fsub;', 1]
['buf->end=last;', 1]
['hmset(key.message, msg)', 1]
['void sdsupdatelen(sds s);', 1]
['if ((ht)->type->valDup) \\', 1]
['obj->as.s64 = be64(obj->as.s64);', 1]
['ngx_int_t nchan_detect_websocket_request(ngx_http_request_t *r) {', 1]
['if (seplen < 1 || len < 0) return NULL;', 1]
['return (void *)((char *)thing + rp->prev_ptr_offset);', 1]
['nchan_msg_id_t                  latest_msgid;', 1]
['#define is_bigendian() ((*(char *)&_i) == 0)', 1]
['[:loc_conf, :websocket_ping_interval],', 1]
['ngx_table_elt_t * nchan_add_response_header(ngx_http_request_t *r, const ngx_str_t *header_name, const ngx_str_t *header_value);', 1]
['"  local ch = redis.call(\'hmget\', key_channel, \'ttl\', \'time_last_seen\', \'subscribers\', \'fake_subscribers\')\\n"', 1]
['int redisReaderFeed(redisReader *r, const char *buf, size_t len);', 1]
['static nchan_msg_id_t           zero_msgid = NCHAN_ZERO_MSGID;', 1]
['* Writes a string to the backend; according to the MessagePack spec, this must', 1]
['ngx_int_t                    n;', 1]
['static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {', 1]
['struct channel_spooler_s {', 1]
['//no such thing here. reply.', 1]
['U32_MARKER             = 0xCE,', 1]
['ngx_memzero(&bc[2].buf, sizeof(ngx_buf_t));', 1]
['#define INTERVALPOLL_STRINGS "poll", "interval-poll", "intervalpoll", "http"', 1]
['str.len = 6;', 1]
['redisReadTask rstack[9];', 1]
['raise e', 1]
['/* curarg is put in argv so it can be overwritten. */', 1]
['str->data=(u_char *)&str[1];', 1]
['static void init_shdata_procslots(int slot, int n) {', 1]
['buf->file->log = ngx_cycle->log;', 1]
['#include "async.h"', 1]
['struct timeval             tv;', 1]
['memstore_ensure_chanhead_is_ready(d->chanhead, 1);', 1]
['struct nchan_reloading_channel_s {', 1]
['if((msg = ngx_pcalloc(r->pool, sizeof(*msg))) == NULL) {', 1]
['* reply that is sent when a new connection exceeds the maximum', 1]
['ngx_memzero(&buf, sizeof(buf)); //do we really need this?...', 1]
['static ngx_int_t nchan_prev_message_id_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['static ngx_int_t websocket_release(subscriber_t *self, uint8_t nodestroy);', 1]
['if ((rc = ws_recv(c, rev, &buf, 4)) != NGX_OK) {', 1]
['else if (type_marker == BIN8_MARKER) {', 1]
['|| lastid->time == -1', 1]
['vector[*argc] = current;', 1]
['tags1 = max1 <= NCHAN_FIXED_MULTITAG_MAX ? id1->tag.fixed : id1->tag.allocd;', 1]
['//sweet, no newlines!', 1]
['* HASH_SRT was added to allow the hash handle name to be passed in. */', 1]
['//nchan_msg_id_t             unid;', 1]
['struct timeval                 start_tv;', 1]
['* otherwise. When NULL is returned in a blocking context, the error field', 1]
['redisAsyncContext *', 1]
['params->port = ngx_atoi(cur, ret-cur);', 1]
['return cmp_write_fixext4_marker(ctx, tp);', 1]
['@time=t', 1]
['/* again ... */', 1]
['if(dummy_config_ptr == NULL) {', 1]
['if((ctx=rds_ctx())!=NULL)', 1]
['iter->entry = iter->ht->table[iter->index];', 1]
['ngx_int_t ngx_http_complex_value_noalloc(ngx_http_request_t *r, ngx_http_complex_value_t *val, ngx_str_t *value, size_t maxlen);', 1]
['handle_chanhead_gc_queue(0);', 1]
['/* search the separator */', 1]
["case 'a': c = '\\a'; break;", 1]
['$(MAKE) CFLAGS="-fprofile-arcs -ftest-coverage" LDFLAGS="-fprofile-arcs"', 1]
['"        return {404, \\"\\", \\"\\", \\"\\", \\"\\", subs_count}\\n"', 1]
['#define DECLTYPE(x) (__typeof(x))', 1]
['dep:', 1]
['ngx_int_t memstore_redis_subscriber_destroy(subscriber_t *sub);', 1]
['if ((rc = ws_recv(c, rev, &buf, frame->payload_len)) != NGX_OK) {', 1]
['ac->ev.addWrite = redisLibeventAddWrite;', 1]
['va_arg(ap,int);', 1]
['static const ngx_str_t    STATUS_403=ngx_string("403 Forbidden");', 1]
['fsub->sub.lbl = ngx_calloc(r->uri.len+1, ngx_cycle->log);', 1]
['void                      *privdata;', 1]
['int elements; /* number of elements in multibulk container */', 1]
['ngx_conf_merge_value(conf->max_channel_subscribers, prev->max_channel_subscribers, 0);', 1]
['frame->last = frame->payload;', 1]
['uint16_t        status;// NCHAN_MESSAGE_RECEIVED or NCHAN_MESSAGE_QUEUED;', 1]
['int err;', 1]
['//     test("redisBufferWrite against empty write buffer: ");', 1]
['if (ht->size == 0) return NULL;', 1]
['//output: current_fake_subscribers', 1]
['time_t            t2 = id2->time;', 1]
['"        return {200, ttl, tonumber(msg.time) or \\"\\", tonumber(msg.tag) or \\"\\", tonumber(msg.prev_time) or \\"\\", tonumber(msg.prev_tag) or \\"\\", msg.data or \\"\\", msg.content_type or \\"\\", msg.eventsource_event or \\"\\", subs_count}\\n"', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "IPC:" fmt, ##args)', 1]
['ngx_int_t memstore_ipc_send_does_channel_exist(ngx_int_t dst, ngx_str_t *chid, callback_pt callback, void* privdata);', 1]
['static void redis_subscriber_callback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['dbg("MESSAGE NOT FOUND")', 1]
['spool_fetch_msg(newspool);', 1]
['static nchan_store_channel_head_t *chanhead_redis_create(ngx_str_t *channel_id) {', 1]
['* Read from the socket until a single reply could be parsed', 1]
['ERR("can\'t allocate spoolcollector overflow");', 1]
['redisCallback *head, *tail;', 1]
['sds sdscpylen(sds s, const char *t, size_t len) {', 1]
['ngx_str_t *nchan_get_channel_id(ngx_http_request_t *r, pub_or_sub_t what, ngx_int_t fail_hard);', 1]
['static nchan_request_ctx_t *get_main_request_ctx(ngx_http_request_t *r){', 1]
['nchan_msg_t                msg;', 1]
['dictSetHashKey(ht, entry, key);', 1]
['redis_publish_callback_data_t  *d=NULL;', 1]
['str.len = buf->end - buf->start;', 1]
['unsigned                        tagactive:16;', 1]
['unsigned                already_dequeued:1;', 1]
['if (r->len-r->pos >= bytes) {', 1]
['"--  \'active_ttl\' is channel ttl with non-zero subscribers. -1 to persist, >0 ttl in sec\\n"', 1]
['void              shm_locked_free(shmem_t *shm, void *p);', 1]
['gcov:', 1]
['class Msg', 1]
['/* Create an empty (zero length) sds string. Even in this case the string', 1]
['* quotes or closed quotes followed by non space characters', 1]
['if(!fsub->upstream_stuff) {', 1]
['nchan_storage_engine [:main, :srv, :loc],', 1]
['nchan_add_variables,           /* preconfiguration */', 1]
['legacy: "push_subscriber",', 1]
['unsigned                    running:1;', 1]
['/* Hooks that are called when the library expects to start', 1]
['if (argc >= 2 && !strcmp(argv[0],"-h")) {', 1]
['static void nchan_thingcache_gc_timer_handler(ngx_event_t *ev) {', 1]
['if (elements == -1) {', 1]
['sr->method_name = *method_name;', 1]
['ipc_alert_t        *alert;', 1]
['"  local bulk = {}\\n"', 1]
['msg->id.tag.fixed[0] = msgtag;', 1]
['ipc_process_t         process[NGX_MAX_PROCESSES];', 1]
['unsigned char *_sfh_key=(unsigned char*)(key);                                 \\', 1]
['sdsfree(sname);', 1]
['ngx_int_t            rbtree_destroy_node(rbtree_seed_t *, ngx_rbtree_node_t *);', 1]
['test("Format command with invalid printf format: ");', 1]
['void ngx_rwlock_reserve_read(ngx_rwlock_t *lock);', 1]
["source 'https://rubygems.org'", 1]
['assert(m->id.tagcount == 1);', 1]
['newtokens = realloc(tokens,sizeof(sds)*slots);', 1]
['uint64_t    msgtag;', 1]
['pd->ch.subscribers += ch->subscribers;', 1]
['data->sub->fn->respond_status(data->sub, NGX_HTTP_FORBIDDEN, NULL);', 1]
['if (msgstart != MAP_FAILED) {', 1]
['ngx_http_request_body_t    *body;', 1]
['char *p, *eptr;', 1]
['ERR("abort! %s", errmsg ? errmsg : "unknown error");', 1]
['if (!write_type_marker(ctx, S16_MARKER))', 1]
['ERR("just-published messages is no longer the last message for some reason... This is unexpected.");', 1]
['ngx_rbtree_node_t   *rbtree_create_node(rbtree_seed_t *, size_t);', 1]
['sub->last_msgid = latest_msgid;', 1]
['ngx_slab_pool_t    *shpool = SHPOOL(shm);', 1]
['* so dictExpand just creates an hash table. */', 1]
['if(msg->rsv == NULL) {', 1]
['ac->data = NULL;', 1]
["case ':':", 1]
['nchan_store_chanhead_publish_message_generic(chead, msg, msg_in_shm, cf, publish_multi_callback, pd);', 1]
['static void nchan_generate_random_boundary(u_char *buf, int sz) {', 1]
['It takes the number of arguments `argc`, an array of strings `argv` and the lengths of the', 1]
['struct timeval          tv;', 1]
['if (!write_type_marker(ctx, FIXEXT1_MARKER))', 1]
['workers = shdata->active_workers < shdata->max_workers ? shdata->active_workers : shdata->max_workers;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: cannot read file with request body");', 1]
['ngx_int_t chanhead_gc_add(nchan_store_channel_head_t *ch, const char *reason) {', 1]
['len = redisFormatCommand(&cmd,"SET %b %b","foo",(size_t)3,"b\\0r",(size_t)3);', 1]
['"  if msg then\\n"', 1]
['redisAsyncCommand(c, redis_subscriber_callback, NULL, "SUBSCRIBE %s", rdt.subscriber_channel);', 1]
['int bound = 0;', 1]
['static void set_buf_to_str(ngx_buf_t *buf, const ngx_str_t *str) {', 1]
['redis_nginx_force_close_context(redisAsyncContext **context)', 1]
['case REDIS_REPLY_NIL:', 1]
['ngx_memset(msg, 0xFA, sizeof(*msg)); //debug stuff', 1]
['urs = &uniq_rsp_seed;', 1]
['nchan_llist_timed_t         *chanhead_cleanlink;', 1]
['nchan_msg_id_t           zeroid = NCHAN_ZERO_MSGID;', 1]
['ngx_str_t                  tmpid;', 1]
["* This is for uthash developer only; it compiles away if HASH_DEBUG isn't defined.", 1]
['//start the clock', 1]
['len = snprintf(buf,size,"\\"\\\\%c\\"",byte);', 1]
['cbuf->file = (ngx_file_t *) (cbuf+1) + ((buf->temporary || buf->memory) ? ngx_buf_size(buf) : 0);', 1]
['if (s[j] == from[i]) {', 1]
['bool cmp_write_decimal(cmp_ctx_t *ctx, double d) {', 1]
['typedef struct redisReader {', 1]
['DBG("start SPOOLER %p", *spl);', 1]
["/* Returns CMP's version */", 1]
['int                        rc;', 1]
['ws_pub_head.data = NULL;', 1]
['/* Reallocate the sds string so that it has no free space at the end. The', 1]
['u_char   *last = last_char - delim_sz;', 1]
['[:loc_conf, :use_redis],', 1]
['n = ngx_read_file(chain->buf->file, buf->start, len, 0);', 1]
['if((d=ngx_calloc(sizeof(*d), ngx_cycle->log))==NULL) { //todo: allocate in request pool?...', 1]
['/* Expand the hashtable if needed */', 1]
['ngx_buf_t   *b = REQUEST_PCALLOC(r, b);', 1]
['seed->allocd_nodes--;', 1]
['if(f->timeout_ev.timer_set) {', 1]
['### Usage', 1]
["* Writes an unsigned char's value to the backend as a boolean.  This is useful", 1]
['msg->prev = ch->msg_last;', 1]
['nchan_msg_id_t       msgid;', 1]
['//too large', 1]
['if (isprint(byte))', 1]
['{ "x-json", 6, &NCHAN_CHANNEL_INFO_JSON },', 1]
['#define WEBSOCKET_OPCODE_PING               0x9', 1]
['static void websocket_perform_handshake(full_subscriber_t *fsub) {', 1]
['if ((ctx)->ev.delWrite) (ctx)->ev.delWrite((ctx)->ev.data); \\', 1]
['* the reply (or replies in pub/sub).', 1]
['void (*keyDestructor)(void *privdata, void *key);', 1]
['"-- sets all fields for a hash from a dictionary\\n"', 1]
['HASH_FSCK(hh,head);                                                        \\', 1]
['ngx_buf_t   *buf=(ngx_buf_t *)ctx->buf;', 1]
['* to redisProcessCallbacks(). Otherwise, we can only disconnect immediately', 1]
['ngx_http_get_variable_pt    handler;', 1]
['hdr_buf->pos=hdr_buf->start;', 1]
['is expected on the socket. To pipeline commands, the only things that needs to be done is', 1]
['ngx_init_set_membuf(&bc.buf, resp_buf, ngx_snprintf(resp_buf, 256, ":%i: %V\\n", status_code, status_line ? status_line : &empty_line));', 1]
['m->nobuffer_msg_reaper.strategy = ROTATE;', 1]
['dictEntry **table;', 1]
['"  if sub_count == 0 then\\n"', 1]
["if (_p[0] == 'h') {", 1]
['createNilObject,', 1]
['bool cmp_write_fixext1_marker(cmp_ctx_t *ctx, int8_t type) {', 1]
['ngx_int_t memstore_ipc_send_memstore_subscriber_keepalive(ngx_int_t dst, ngx_str_t *chid, subscriber_t *sub, nchan_store_channel_head_t *ch, callback_pt callback, void *privdata) {', 1]
['unsigned long i = DICT_HT_INITIAL_SIZE;', 1]
['* (item count) in each bucket is reduced. Thus by expanding buckets', 1]
['if(ctx == NULL || ctx->publisher_type == NULL) {', 1]
['static char *nchan_publisher_directive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['head->last_subscribed_local = t;', 1]
['#define HASH_OOPS(...) do { fprintf(stderr,__VA_ARGS__); exit(-1); } while (0)', 1]
['d->chinfo.last_seen = chinfo->last_seen;', 1]
['u_char       *split, *last;', 1]
['static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply, redisCallback *dstcb) {', 1]
['nchan_channel_t chinfo;', 1]
['for(_src_bkt=0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) {     \\', 1]
['ngx_int_t websocket_subscriber_destroy(subscriber_t *sub);', 1]
['if (!write_type_marker(ctx, EXT32_MARKER))', 1]
['/* If the hash table is empty expand it to the intial size,', 1]
['ngx_int_t            (*respond_status)(channel_spooler_t *self, ngx_int_t status_code, const ngx_str_t *status_line);', 1]
['--we await a message', 1]
['#define uthash_malloc(sz) malloc(sz)      /* malloc fcn                      */', 1]
['static size_t ngx_buf_writer(cmp_ctx_t *ctx, const void *data, size_t count) {', 1]
['const ngx_str_t *status_line = NULL;', 1]
['"  redis.call(\'PUBLISH\', channel_key, pubmsg)\\n"', 1]
['store_channel_head_shm_t    *shared_channel_data;', 1]
["uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')", 1]
['bool cmp_read_ext16_marker(cmp_ctx_t *ctx, int8_t *type, uint16_t *size);', 1]
['"return nearly_departed",', 1]
['* can correctly be interpolated. */', 1]
['FIXEXT1_MARKER         = 0xD4,', 1]
['//DBG("free smsg %p",s msg);', 1]
['} nchan_variable_t;', 1]
['rc = ngx_http_output_filter(r, in);', 1]
['ngx_connection_t           *c;', 1]
['ngx_del_timer(&d->timeout_ev);', 1]
[':ngx_conf_set_size_slot,', 1]
['* hash, so to calculate ceil(n/b) with integers we could write', 1]
['nchan_publisher_directive_parse(cf, cmd, conf, 0);', 1]
['if(r->stream) {', 1]
['static redisAsyncContext * rds_ctx(void){', 1]
['*b = 1;', 1]
['void redisAsyncHandleRead(redisAsyncContext *ac) {', 1]
['_elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh);                       \\', 1]
['bool cmp_read_ext_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size) {', 1]
['bool cmp_read_s32(cmp_ctx_t *ctx, int32_t *i) {', 1]
['sub_create = eventsource_subscriber_create;', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "NCHAN MSG_ID:" fmt, ##args)', 1]
['ngx_memzero(&e, sizeof(ngx_http_script_engine_t));', 1]
['* way, like in the following example:', 1]
['obj = (void*)REDIS_REPLY_STRING;', 1]
['#define MUR_FMIX(_h) \\', 1]
['cur=Msg.new(id)', 1]
['ngx_int_t           count = 0;', 1]
['return sh->free;', 1]
['uint32_t  map_size;', 1]
['ngx_int_t            rbtree_shutdown(rbtree_seed_t *);', 1]
['ngx_atomic_fetch_add(&ch->shared->total_message_count, 1);', 1]
['/* Free the old value and set the new one */', 1]
['/* Our hash table capability is a power of two */', 1]
['chunked_fn->respond_status = chunked_respond_status;', 1]
['"if time and time ~= 0 and tag then\\n"', 1]
['* function with the context. */', 1]
['struct recycloc_llist_s {', 1]
['&& CHECK_REPLY_STR(els[offset+5])   //message', 1]
['nchan_publisher_post_request(r, content_type, content_length, r->request_body->bufs, channel_id, cf);', 1]
['DBG("%p fetch msg %V for channel %V", spool, msgid_to_str(&spool->id), spool->spooler->chid);', 1]
['const char *hostname = (argc > 1) ? argv[1] : "127.0.0.1";', 1]
['} channel_existence_data_t;', 1]
['} publish_multi_data_t;', 1]
['void(const redisAsyncContext *c, int status);', 1]
['buf->end = buf->last = cur;', 1]
['static ngx_int_t longpoll_respond_status(subscriber_t *self, ngx_int_t status_code, const ngx_str_t *status_line) {', 1]
['HASH_DEL_IN_BKT(hh,(head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del);        \\', 1]
['} publish_callback_data;', 1]
['ngx_del_timer(&fsub->data.timeout_ev);', 1]
['if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1){', 1]
['static ngx_str_t *msg_to_str(nchan_msg_t *msg) {', 1]
['if (redisBufferRead(c) == REDIS_ERR) {', 1]
['"  channel=      \'channel:\'..id, --hash\\n"', 1]
['msg->eventsource_event.data=cur;', 1]
['static redisContext *select_database(redisContext *c) {', 1]
['return ngx_alloc(size, ngx_cycle->log);', 1]
['bool cmp_object_as_long(cmp_object_t *obj, int64_t *d);', 1]
['#define MUR_THREE_ONE(p) ((((*WP(p))&0x00ffffff) << 8) | (((*(WP(p)+1))&0xff000000) >> 24))', 1]
['(sizeof(UT_hash_table))                                 +            \\', 1]
['//subscribe again?...', 1]
['if((bc = ngx_palloc(pool, sizeof(*bc) + sz)) == NULL) {', 1]
['(strcmp(c->errstr,"Name or service not known") == 0 ||', 1]
['ch->msg_first = msg->next;', 1]
['found_msg_id=channel.current_message', 1]
['bool cmp_write_str_marker_v4(cmp_ctx_t *ctx, uint32_t size) {', 1]
['DBG("invalid qval. reject.");', 1]
['void nchan_update_multi_msgid(nchan_msg_id_t *oldid, nchan_msg_id_t *newid);', 1]
['self->generation++;', 1]
['ngx_memzero(&boundary[i], sizeof(ngx_buf_t));', 1]
['uint32_t _mur_c1 = 0xcc9e2d51;                                       \\', 1]
['void                *cur = rp->first, *next, *prev;', 1]
['head->last_msgid.tag.fixed[0]=0;', 1]
['ngx_int_t rbtree_remove_node(rbtree_seed_t *seed, ngx_rbtree_node_t *node) {', 1]
['sds *sdssplitargs(const char *line, int *argc);', 1]
['const uint8_t *_mur_tail;                                            \\', 1]
['#define CHECK_REPLY_STR(reply) ((reply)->type == REDIS_REPLY_STRING)', 1]
['static ngx_int_t validate_chanhead_messages(nchan_store_channel_head_t *ch) {', 1]
['test_cond("sdsrange(...,1,100)",', 1]
['//char* (*scripts)[]=(char* (*)[])&store_rds_lua_scripts;', 1]
['cur->next = &ws_pub_head;', 1]
['databuf.last_buf = 0;', 1]
['if (obj->type == CMP_TYPE_FLOAT) {', 1]
['sha1_str.data=buf_sha1;', 1]
['ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno, "pipe() failed while initializing nchan IPC");', 1]
['head->max_messages = (ngx_int_t) -1;', 1]
['sdsrange(y,1,-1);', 1]
['"    redis.call(\'echo\', table.concat(arg))\\n"', 1]
['return (subscriber_pool_t *)rbtree_data_from_node(node);', 1]
['subscriber_t *subdebug_head = NULL;', 1]
['static ngx_inline void set_multimsg_msg(get_multi_message_data_t *d, get_multi_message_data_single_t *sd, nchan_msg_t *msg, nchan_msg_status_t status) {', 1]
['#define NCHAN_COMPLEX_VALUE_ARRAY_MAX 8', 1]
['static ngx_str_t    magic = ngx_string("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");', 1]
['#ifdef HASH_USING_NO_STRICT_ALIASING', 1]
['[IPC_PUBLISH_MESSAGE] =             (ipc_handler_pt )receive_publish_message,', 1]
['(add)->hh.tbl = (head)->hh.tbl;                                                 \\', 1]
['memset(&hints,0,sizeof(hints));', 1]
['//pool, please', 1]
['static redisAsyncContext * rds_sub_ctx(void);', 1]
['if(cur == rp->last)  rp->last = prev;', 1]
['assert_equal m[1], msg, "retrieved message doesn\'t match"', 1]
['As decltype is only available in newer compilers (VS2010 or gcc 4.3+', 1]
['CMP_TYPE_SINT16,          /* 19 */', 1]
['DBG("can\'t pop last item off of fakeprocess stack");', 1]
['ngx_conf_merge_value(conf->channel_timeout, prev->channel_timeout, NCHAN_DEFAULT_CHANNEL_TIMEOUT);', 1]
['DYLIBSUFFIX=dylib', 1]
['rec->name=name;', 1]
['srdata.overflow = NULL;', 1]
['u_char rsv1:1;', 1]
['#include <util/nchan_msgid.h>', 1]
['fsub->upstream_stuff = psr_stuff;', 1]
['d->d.resp.shm_msg = NULL;', 1]
['char *subscriber_unregister;', 1]
['/* The Paul Hsieh hash function */', 1]
['uint16_t        msg_tag;', 1]
['r->rstack[r->ridx].type = -1;', 1]
['LENGTH_READING_ERROR,', 1]
['ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES', 1]
['ac->ev.delWrite = redisLibevDelWrite;', 1]
['redisAsyncContext *ac = (redisAsyncContext *) connection->data;', 1]
['/* Destroy an entire hash table */', 1]
['int hex_digit_to_int(char c) {', 1]
['#define __DICT_H', 1]
['/* Re-initialize the table */', 1]
['return cmp_write_fixmap(ctx, size);', 1]
['cf.max_messages = rlch->max_messages;', 1]
['(head)->hh.tbl->hho)) : NULL);                    \\', 1]
['i = j;', 1]
['kill `cat /tmp/hiredis-test-redis.pid`', 1]
['return nchan_set_complex_value_array(cf, cmd, conf, &((nchan_loc_conf_t *)conf)->last_message_id);', 1]
['wev->timedout = 0;', 1]
['/* Proceed when obj was created. */', 1]
['for (i = 0; i < 500; i++)', 1]
['#include "assert.h"', 1]
['if (ngx_list_init(&r->headers_in.headers, r->pool, 20, sizeof(ngx_table_elt_t)) != NGX_OK) {', 1]
['chain->buf->file->fd = NGX_INVALID_FILE;', 1]
['tags_oldest = head->oldest_msgid.tag.allocd;', 1]
['d->multi_chanhead->multi_waiting++;', 1]
['"local arg, cur = {...}, nil\\n"', 1]
['int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen) {', 1]
['spooled_subscriber_t   *cur;', 1]
['//#define NCHAN_BENCHMARK 1', 1]
['"-- create_channel_ttl - make new channel if it\'s absent, with ttl set to this. 0 to disable.\\n"', 1]
['ngx_file_t             *msg_file;', 1]
['return cmp_write_s16(ctx, d);', 1]
['msg=Msg.new(arg.first, arg.last)', 1]
['tags1 = id1->tag.allocd;', 1]
['/* get a token */', 1]
['./hiredis-test -h 127.0.0.1 -p $(REDIS_PORT) -s /tmp/hiredis-test-redis.sock || \\', 1]
['static void redis_get_message_callback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['static ngx_int_t longpoll_set_timeout_callback(subscriber_t *self, subscriber_callback_pt cb, void *privdata) {', 1]
['cur->data = (void *)sub;', 1]
['_hs_list = _hs_e;                                          \\', 1]
['@time= _empty_is_nil arg[:time]', 1]
['* Increase the read buffer size from 2k to 16k.', 1]
['unsigned                         connected:1;', 1]
['loop = aeCreateEventLoop(64);', 1]
['*thing_next_ptr(rp, thing) = NULL;', 1]
['spool = get_spool(self, &latest_msg_id);', 1]
['cur+=3;', 1]
['msgstart = mmap(NULL, msglen, PROT_READ, MAP_SHARED, fd, 0);', 1]
['bool cmp_write_bin32_marker(cmp_ctx_t *ctx, uint32_t size) {', 1]
['ngx_str_t    smallmsg;', 1]
['data->n--;', 1]
['printf("\\nTesting against inherited fd (%s):\\n", cfg.unix.path);', 1]
['"  table.insert(ch, redis.call(\'llen\', \\"channel:messages:\\"..id))\\n"', 1]
['*f = obj->as.flt;', 1]
['x = sdsnew("foo");', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "rwlock %p tried to release nonexistent write lock, lock=%i.", lock, lock->lock);', 1]
['if(chid == NULL) {', 1]
['sub->dbg_next = subdebug_head;', 1]
['* and redistributing the items into the new buckets. Ideally the', 1]
['"      return {418, \\"\\", \\"\\", \\"\\", \\"\\", subs_count}\\n"', 1]
['reply = (redisCommand(c,"EXEC"));', 1]
['if(t1 < t2){', 1]
['static ngx_int_t websocket_send_frame(full_subscriber_t *fsub, const u_char opcode, off_t len) {', 1]
['"  --leave some crumbs behind showing this channel was just deleted\\n"', 1]
['#define redisReplyReaderGetReply redisReaderGetReply', 1]
['struct nchan_llist_timed_s     *next;', 1]
['case 10: hashv += ( (unsigned)_hj_key[9] << 16 );                           \\', 1]
['while(*p && isspace(*p)) p++;', 1]
['size_t len; /* Buffer length */', 1]
['ch->shared = NULL;', 1]
['All pending callbacks are called with a `NULL` reply when the context encountered an error.', 1]
['chanhead_gc_withdraw(head);', 1]
['obj->type = CMP_TYPE_STR16;', 1]
['assert(d->n >= 1);', 1]
['ngx_int_t nchan_subscriber_authorize_subscribe(subscriber_t *sub, ngx_str_t *ch_id);', 1]
['bool cmp_read_short(cmp_ctx_t *ctx, int16_t *s) {', 1]
['//nchan_store_memory.delete_channel(d->chid, NULL, NULL);', 1]
['ngx_atomic_fetch_add(&ch->shared->sub_count, n);', 1]
['remsg.prev_id.tag.allocd = prevtags;', 1]
['bool cmp_write_ext8_marker(cmp_ctx_t *ctx, int8_t type, uint8_t size) {', 1]
['if (type == AF_INET) {', 1]
['}; //subscriber_t', 1]
['test("Binary reply length is correct: ");', 1]
['S16_MARKER             = 0xD1,', 1]
['bool cmp_write_ext16_marker(cmp_ctx_t *ctx, int8_t type, uint16_t size);', 1]
['ngx_str_t * (*message_content_type)(nchan_msg_t *msg, ngx_pool_t *pool);', 1]
['size_t               len = 0, content_type_len = 0, es_event_len = 0;', 1]
['sds sdscatrepr(sds s, const char *p, size_t len) {', 1]
['static ngx_int_t chanhead_gc_add(nchan_store_channel_head_t *head, const char *reason) {', 1]
['`Last-Modified` and `If-Modified-Since` headers.', 1]
['test_cond(ret == REDIS_OK &&', 1]
['ngx_http_script_engine_t      e;', 1]
['static u_char* copy_preallocated_str_to_cur(ngx_str_t *dst, ngx_str_t *src, u_char *cur) {', 1]
['static ngx_int_t longpoll_multimsg_add(full_subscriber_t *fsub, nchan_msg_t *msg, char **err) {', 1]
['redisAsyncHandleRead(p->context);', 1]
['p = nextArgument(cmd,&cstr,&clen);', 1]
['e = (redisAeEvents*)malloc(sizeof(*e));', 1]
['case 418: //not yet available', 1]
['#define HASH_BLOOM_BITSET(bv,idx) (bv[(idx)/8] |= (1U << ((idx)%8)))', 1]
['bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c) {', 1]
['//#define IPC_DATA_SIZE 80', 1]
['nchan_store_subscribe_continued(channel_status, NULL, data);', 1]
['obj->as.bin_size = be32(obj->as.u32);', 1]
['nchan_msg_t  msg;', 1]
['hashv += hashv >> 17;                                                        \\', 1]
['while(n < rp->count && notready <= max_notready) {', 1]
['/* Execute pending callbacks with NULL reply. */', 1]
['return cmp_write_fixext4(ctx, tp, data);', 1]
['* additional characters, the longer string is considered to be greater than', 1]
['obj->as.u64 = be64(obj->as.u64);', 1]
['subscribers = channel->subscribers;', 1]
['assert(msg == NULL);', 1]
['ngx_uint_t         active_nodes;', 1]
['assert(reply->element[2]->type == REDIS_REPLY_INTEGER);', 1]
['DBG("time to reload? shdata: %p, rlch: %p", shdata, shdata == NULL ? NULL : shdata->rlch);', 1]
['DBG("node not found");', 1]
['POSITIVE_FIXNUM_MARKER = 0x00,', 1]
["//scratch that, let's inherit those vars", 1]
['ngx_conf_merge_str_value(conf->eventsource_event, prev->eventsource_event, "");', 1]
['ngx_str_t                  *id_out;', 1]
['subsequent replies. The return value for this function is either `REDIS_OK` or `REDIS_ERR`, where', 1]
['assert(nonnegs == 1);', 1]
['req_msgid[i].tag.fixed[0] = 0;', 1]
['j = j+seplen-1; /* skip the separator */', 1]
['return cmp_write_uinteger(ctx, d);', 1]
['const  ngx_str_t NCHAN_VARY_HEADER_VALUE = ngx_string("If-None-Match, If-Modified-Since");', 1]
['remsg.prev_id.tagactive = d->n;', 1]
['rbtree_walk_callback_pt callback = NULL;', 1]
['"  key.message=key.message:format(msg_id, id)\\n"', 1]
['UT_hash_bucket *buckets;', 1]
['while ((cur_last = nchan_strsplit(&cur, delim, last)) != NULL) {', 1]
['cur->type = REDIS_REPLY_ERROR;', 1]
['#define HTTP_MULTIPART_STRINGS_N 4', 1]
['} else {                                                                 \\', 1]
['msg.prev_time = lasttime', 1]
['&& CHECK_REPLY_STR(reply->element[2])) {', 1]
['ngx_memcpy(alert.data, data, data_size);', 1]
['//ERR(" --  update with               (%V) --", msgid_to_str(new_last_id));', 1]
['switch (rp->strategy) {', 1]
['chanhead->multi_waiting++;', 1]
['alt_err.len=0;', 1]
['dictEntry *entry, auxentry;', 1]
['thing = &whole->t;', 1]
['redisAsyncCommand(rds_ctx(), &redisChannelInfoCallback, d, "EVALSHA %s 0 %b", store_rds_lua_hashes.delete, STR(channel_id));', 1]
['ngx_int_t nchan_cleverly_output_headers_only_for_later_response(ngx_http_request_t *r);', 1]
['* scratch pointer rather than through the repointed (users) symbol.', 1]
['static bool read_byte(cmp_ctx_t *ctx, uint8_t *x) {', 1]
["else if (c == '[') {", 1]
['msec          = -1;', 1]
['&& CHECK_REPLY_INT_OR_STR(els[offset+1])   //id - time', 1]
['if(fsub->data.timeout_ev.timer_set) {', 1]
['c->read->handler = ipc_read_handler;', 1]
['str.len = 0;', 1]
['reply = redisCommand(context, "SET key:%s %s", myid, value);', 1]
['node->parent = NULL;', 1]
['pos += len;', 1]
['//content-type maybe', 1]
['+ ( (unsigned)_hj_key[2] << 16 )                                         \\', 1]
['if (!write_type_marker(ctx, FIXEXT2_MARKER))', 1]
['__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);', 1]
['} subscriber_fn_t;', 1]
['publish_response_data    rd;', 1]
['void cmp_init(cmp_ctx_t *ctx, void *buf, cmp_reader read, cmp_writer write) {', 1]
['proc->pipe[1]=NGX_INVALID_FILE;', 1]
['last = ngx_copy(last, &WEBSOCKET_PAYLOAD_LEN_16_BYTE, sizeof(WEBSOCKET_PAYLOAD_LEN_16_BYTE));', 1]
['cur += id[i].len;', 1]
['close_msg = (ngx_str_t *)(status_line ? status_line : &STATUS_410);', 1]
['i = h % workers;', 1]
['memcpy(s, t, len);', 1]
['"  if msg_id and channel.current_message == msg_id\\n"', 1]
['/* Free all the elements */', 1]
['chanhead_messages_gc_custom(ch, 0);', 1]
['assert(array_sz == 4);', 1]
['default: "0 (unlimited)",', 1]
['r->rstack[r->ridx].idx = 0;', 1]
['u_char mask:1;', 1]
['"  return nil\\n"', 1]
['compiler:', 1]
['buf->last = buf->pos;', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "THINGCACHE: " fmt, ##args)', 1]
['/* Writes an array to the backend. */', 1]
['if(rdt.chanhead_cleanup_head==NULL) {', 1]
['//ngx_int_t eventsource_subscriber_destroy(subscriber_t *sub);', 1]
['rd.msg_tag = ch->last_published_msg_id.tag.fixed[0];', 1]
['if(array_sz != 0) {', 1]
['int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen);', 1]
['ngx_table_elt_t                 *h, *header;', 1]
['local create_channel_ttl=tonumber(ARGV[5]) or 0', 1]
['ngx_log_debug0(NGX_LOG_ERR, log, 0, "nchan IPC: read() returned zero");', 1]
['bool cmp_write_fixext4_marker(cmp_ctx_t *ctx, int8_t type) {', 1]
['spl = get_spool(spl, &id);', 1]
['bool cmp_write_fixext2_marker(cmp_ctx_t *ctx, int8_t type) {', 1]
['r->pos += bytelen;', 1]
['#define HASH_SAX(key,keylen,num_bkts,hashv,bkt)                                  \\', 1]
['ngx_int_t max = sizeof(seed->actives);', 1]
['/* Create a new sds string starting from a null termined C string. */', 1]
['#define HASH_FSCK(hh,head)                                                       \\', 1]
['static void change_sub_count(nchan_store_channel_head_t *ch, ngx_int_t n) {', 1]
['obj = (void*)REDIS_REPLY_INTEGER;', 1]
['if ((buf->last - buf->start) < len) {', 1]
['ERR("nchan: unexpected msgpack alert from redis");', 1]
['/* The regular connect functions will always set the flag REDIS_CONNECTED.', 1]
['/* calculate the element whose hash handle address is hhe */', 1]
['"  new_channel=true\\n"', 1]
['static void *fd_cache = NULL;', 1]
['} nchan_conf_publisher_types_t;', 1]
['if (df == d)', 1]
['//msgtime', 1]
['m=[]', 1]
['printf("%u) %s\\n", j, reply->element[j]->str);', 1]
['last_seen = channel->last_seen;', 1]
['new_channel = true', 1]
['ngx_rbtree_node_t              *node = root;', 1]
['c->flags &= ~REDIS_IN_CALLBACK;', 1]
['ngx_buf_t                     *fakebody_buf;', 1]
['if (!(ngx_quit || ngx_terminate || ngx_exiting || rdt.chanhead_cleanup_head==NULL)) {', 1]
['/* This function should be called when the socket is readable.', 1]
["/* Destructively modify the sds string 's' to hold the specified binary", 1]
['//nothing.', 1]
['test("Can handle nested multi bulk replies: ");', 1]
['&internal_set_dequeue_callback,', 1]
['bool cmp_object_is_uint(cmp_object_t *obj);', 1]
['switch(rc) {', 1]
['&internal_release,', 1]
['seed->active_nodes++;', 1]
['#include <util/nchan_channel_info.h>', 1]
['if(newid->tagcount == 1) {', 1]
['&subscriber_name,', 1]
["assert(pt[0]=='<');", 1]
['//ngx_int_t                     create_channel_ttl = cf->subscribe_only_existing_channel==1 ? 0 : cf->channel_timeout;', 1]
['cb = malloc(sizeof(*cb));', 1]
['bool cmp_write_sfix(cmp_ctx_t *ctx, int8_t c);', 1]
['(tbl->ineff_expands+1) : 0;                                              \\', 1]
['&& msgid_tag_compare(&spool->id, &data->min) >= 0 )', 1]
['if (obj.type != CMP_TYPE_NEGATIVE_FIXNUM) {', 1]
['const char *p = line;', 1]
['err = &alt_err;', 1]
['if((ctx->multipart_boundary = ngx_palloc(r->pool, sizeof(ngx_str_t) + 32)) == NULL) {', 1]
['if(conf->last_message_id.n == 0) {', 1]
['close_msg = (ngx_str_t *)(status_line ? status_line : &STATUS_500);', 1]
['int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...);', 1]
['buf->file = file;', 1]
['return cmp_write_u64(ctx, u);', 1]
['void              *(*id)(void *node);', 1]
['while ((chain != NULL) && (chain->buf != NULL)) {', 1]
['data = ngx_alloc(sizeof(*data), ngx_cycle->log); //correctness over efficiency (at first).', 1]
['assert(removed);', 1]
['ngx_str_t           *shm_chid;', 1]
['//     test_cond(__test_callback_flags == ((2 << 8) | 4));', 1]
['#include <adapters/libevent.h>', 1]
['if (chead->shared) {', 1]
['void redisAsyncHandleRead(redisAsyncContext *ac);', 1]
['rc = memstore_ipc_send_publish_message(d->originator, d->chid, msg, &cf, empty_callback, NULL);', 1]
['retmsg.temp_allocd = 0;', 1]
['spooled_subscriber_t       *first;', 1]
['DBG("received subscribe request for channel %V", d->shm_chid);', 1]
['shm_free_immutable_string(shm, chid);', 1]
['test_cond("sdscmp(foo,foa)", sdscmp(x,y) > 0)', 1]
['if(spool_add_subscriber(spool, sub, 1) != NGX_OK) {', 1]
['HASH_TO_BKT( _he_thh->hashv, tbl->num_buckets*2, _he_bkt);            \\', 1]
['ngx_int_t memstore_channel_owner(ngx_str_t *id) {', 1]
['self->non_internal_sub_count++;', 1]
["//there's definitely enough space at the end for 2 more bytes", 1]
['DBG("fdcache fd %i", fd);', 1]
['sds sdsfromlonglong(long long value) {', 1]
['const char *cmp_error_messages[ERROR_MAX + 1] = {', 1]
['ngx_memcpy(urnode->id.data, id.data, id.len);', 1]
["* the bucket's chain exceeds this length, bucket expansion is triggered).", 1]
['static ipc_t           *ipc = NULL;', 1]
['ngx_int_t memstore_ipc_send_publish_status(ngx_int_t dst, ngx_str_t *chid, ngx_int_t status_code, const ngx_str_t *status_line, callback_pt callback, void *privdata) {', 1]
['_hj_j +=    (_hj_key[4] + ( (unsigned)_hj_key[5] << 8 )                      \\', 1]
['* **`REDIS_REPLY_NIL`**:', 1]
['ac->ev.data = connection;', 1]
['ngx_int_t              (*release)(struct subscriber_s *, uint8_t nodestroy);', 1]
['if (!ctx->read(ctx, &obj->as.u64, sizeof(uint64_t))) {', 1]
['"queued messages: %ui" CRLF', 1]
['HASH_FCN(keyptr,keylen, (head)->hh.tbl->num_buckets, _hf_hashv, _hf_bkt);   \\', 1]
['/* Expand or create the hashtable */', 1]
['case ROTATE:', 1]
['*d = obj.as.u16;', 1]
['ngx_rbtree_delete(&seed->tree, node);', 1]
['conf->storage_engine = prev->storage_engine ? prev->storage_engine : default_storage_engine;', 1]
['static void nchan_exit_master(ngx_cycle_t *cycle) {', 1]
['ngx_uint_t         messages = 0;', 1]
['ERR("can\'t create recycloc: page_size %i > ngx_pagesize %i", page_size, ngx_pagesize);', 1]
['r->rstack[r->ridx].parent = cur;', 1]
['if (!cmp_read_ext_marker(ctx, type, size))', 1]
['tc->thing_tail = cur->prev;', 1]
['e->fd = c->fd;', 1]
['static uint32_t spool_rbtree_bucketer(void *vid) {', 1]
['upgrading is that hiredis >= 0.9.0 uses a `redisContext*` to keep state, in contrast to', 1]
['size_t               s, n, cn, ln;', 1]
['ac->c.fd = -1;', 1]
['static const subscriber_t new_longpoll_sub = {', 1]
['if(tags1[i] != tags2[i]) return 0;', 1]
['ngx_int_t              (*set_timeout_callback)(subscriber_t *self, subscriber_callback_pt cb, void *privdata);', 1]
['u_char     *cur_last, *last;', 1]
['ERR("invalid message or message absent after get_msg_from_key");', 1]
['ngx_int_t memstore_fakeprocess_pop(void);', 1]
['nchan_commands,                /* module directives */', 1]
['if((channel_id = nchan_get_channel_id(r, PUB, 1))==NULL) {', 1]
['head.count++;                                                                   \\', 1]
['"]]\\n"', 1]
['* If two strings share exactly the same prefix, but one of the two has', 1]
['"if redis.call(\'EXISTS\', chan_key) == 1 then\\n"', 1]
['typedef struct redisReadTask {', 1]
['return nchan_set_complex_value_array(cf, cmd, conf, &((nchan_loc_conf_t *)conf)->pubsub_chid);', 1]
['&internal_sub_fn,', 1]
['ht->used++;', 1]
['head->status = STUBBED;', 1]
['while (_thh) {                                                           \\', 1]
['struct nchan_llist_timed_s     *prev;', 1]
['_dst_hh->prev = _last_elt;                                           \\', 1]
['spool = (subscriber_pool_t *)rbtree_data_from_node(cur);', 1]
['rsv_found = 1;', 1]
['ngx_memcpy(mid->tag.fixed, tags, sizeof(mid->tag.fixed));', 1]
['ngx_int_t nchan_pubsub_handler(ngx_http_request_t *r) {', 1]
['/* Writes a map to the backend. */', 1]
['return memstore_fakeprocess_push(rand() % MAX_FAKE_WORKERS);', 1]
["messages=     'channel:messages:'..id, --list", 1]
['oldid->tagactive = newid->tagactive;', 1]
['[IPC_SUBSCRIBER_KEEPALIVE_REPLY] =  (ipc_handler_pt )receive_subscriber_keepalive_reply,', 1]
['ngx_uint_t  key;', 1]
['d->channel_exists = (head != NULL);', 1]
['init_header_buf(buf);', 1]
['&& (addhh)->tbl->noexpand != 1) {                                           \\', 1]
['typedef struct redisLibevEvents {', 1]
['* socketpairs, we make our own pipes array.', 1]
["require 'minitest'", 1]
['sds sdsempty(void) {', 1]
['* the current string, and finally needs to set the new length.', 1]
['} else if (end >= (signed)len) {', 1]
['nchan_output_filter(fsub->sub.request, websocket_close_frame_chain(fsub, code, err));', 1]
['|                     Payload Data continued ...                |', 1]
['if arg.length==1', 1]
['#else                   /* GNU, Sun and other compilers */', 1]
['boundary[i].flush = 1;', 1]
['ngx_int_t   err;', 1]
['static       subscriber_fn_t  multipart_fn_data;', 1]
['#define NO_DECLTYPE', 1]
['for(rem=len; (cur = ngx_strnstr(cur, "text/", rem))!=NULL; cur += sizeof("text/")-1) {', 1]
['msg_id=msg', 1]
['hashv += hashv >> 1;                                                 \\', 1]
['*u = obj.as.u16;', 1]
['case 1:  _hj_i += _hj_key[0];                                               \\', 1]
['nchan_request_ctx_t *ctx;', 1]
['while (_he_thh) {                                                        \\', 1]
['"--delete all the messages right now mister!\\n"', 1]
['r->rstack[0].idx = -1;', 1]
['case 5:  _hj_j += _hj_key[4];                                               \\', 1]
['/* based on code from push stream module, written by', 1]
['fd_cache = nchan_thingcache_init("fd_cache", fd_open, fd_close, 5);', 1]
['case 7:  _hj_j += ( (unsigned)_hj_key[6] << 16 );                           \\', 1]
['ngx_int_t update_subscriber_last_msg_id(subscriber_t *sub, nchan_msg_t *msg);', 1]
['*u = obj->as.u32;', 1]
['ngx_int_t       i, slot;', 1]
['void *prev, *next;', 1]
['"local pubmsg = \\"status:\\"..code\\n"', 1]
['#define DISABLED_STRINGS_N 3', 1]
['if (connection->read->active && redis_nginx_fd_is_valid(connection->fd)) {', 1]
['//#define NCHAN_MSG_LEAK_DEBUG 1', 1]
['memcpy(cmd+pos,curargv[j],sdslen(curargv[j]));', 1]
['strcmp(c->errstr,"nodename nor servname provided, or not known") == 0 ||', 1]
['test_cond("Create a string and obtain the length",', 1]
['(addhh)->hh_next = head.hh_head;                                                \\', 1]
['ngx_http_complex_value(r, cf->channel_event_string, &evstr);', 1]
['u_char                           subscriber_channel[255];', 1]
['nread = read(c->fd,buf,sizeof(buf));', 1]
['/* Find pointer to \\r\\n. */', 1]
['if(mmapped && munmap(msgstart, msglen) == -1) {', 1]
['#define NGX_POOL_SUMMARY_SIZE   (12 * 4 + sizeof("size: num: cnum: lnum: [SUMMARY]\\n") - 1)', 1]
['databuf.file_last = flast;', 1]
['c->timedout = 1;', 1]
['subscriber_t          *sub;', 1]
['r->postponed = NULL;', 1]
['//#include <valgrind/memcheck.h>', 1]
['tc->destroy(&((thing_t *)cur->data)->id, ((thing_t *)cur->data)->data);', 1]
['if (c && c->fd >= 0) {', 1]
['flags &= ~O_NONBLOCK;', 1]
['offsetof(nchan_loc_conf_t, channel_event_string),', 1]
['"local subs_count = tonumber(channel.subscribers)\\n"', 1]
['if (!write_type_marker(ctx, BIN8_MARKER))', 1]
['hints.ai_family = AF_INET;', 1]
['cur = &(r->rstack[r->ridx]);', 1]
['assert(ret == REDIS_OK && reply == NULL);', 1]
["c->errstr[len] = '\\0';", 1]
['h->lowcase_key= (u_char *)"content-length";', 1]
['if (r->element[j] != NULL)', 1]
['r->headers_out.content_type.len = content_type.len;', 1]
['callback_pt                  callback;', 1]
['msg.id.tagcount = 1;', 1]
['nchan_store_channel_head_t   *ch = NULL;', 1]
['void *reply; /* Temporary reply pointer */', 1]
['if ((size_t) n < sizeof(*alert)) {', 1]
['freeaddrinfo(bservinfo);', 1]
['__redisReaderSetError(r,REDIS_ERR_PROTOCOL,', 1]
['if(str.len > 0 && rc == NGX_OK) {', 1]
['struct dictEntry *next;', 1]
['Dir[ "#{File.dirname(__FILE__)}/scripts/*.lua" ].each do |f|', 1]
['local del_msgpack =cmsgpack.pack({"alert", "delete channel", id})', 1]
["nchan_store_publish_message_generic(d->shm_chid, d->shm_msg, 1, &cf, publish_message_generic_callback, cd); //so long as callback is not evented, we're okay with that privdata", 1]
['ch->churn_time = ngx_time() + NCHAN_CHANHEAD_EXPIRE_SEC;', 1]
['static ngx_str_t *chanhead_msg_to_str(store_message_t *msg) {', 1]
['//initialize our little IPC', 1]
['DBG("IPC: send publish status to %i ch %V", dst, chid);', 1]
['//and some wobsockety values', 1]
['head->foreign_owner_ipc_sub = d->d.subscriber;', 1]
['/* Field width */', 1]
['TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR', 1]
['ws_pub_head.time = 0;', 1]
['case SUB_RECEIVE_MESSAGE:', 1]
['* of sds strings is returned. *count will be set', 1]
["local key_msg=    'channel:msg:%s:'..id --not finished yet", 1]
['l2 = sdslen(s2);', 1]
['if(ctx == NULL || ctx->channel_event_name == NULL) {', 1]
['nchan_reaper_stop(&mpt->chanhead_churner);', 1]
["(c >= 'A' && c <= 'F');", 1]
['bool cmp_read_nil(cmp_ctx_t *ctx);', 1]
['d->name = "publish";', 1]
['//msg prev_id', 1]
['//multi messages', 1]
['rd.callback_privdata = cd->d->callback_privdata;', 1]
['if(conf->channel_events_channel_id == NULL) {', 1]
['write_aborted = 1;', 1]
['#define HASH_REPLACE(hh,head,fieldname,keylen_in,add,replaced)                   \\', 1]
['//ngx_http_posted_request_t   *pr;', 1]
['unsigned                     reserved:1;', 1]
['cur_out += (ret - cur) + 1;', 1]
['head->shared->last_seen = t;', 1]
['return dictExpand(ht, ht->size*2);', 1]
['ngx_int_t                   n;', 1]
['"    msg.content_type or \\"\\",\\n"', 1]
['&longpoll_fn,', 1]
['bool cmp_write_bin32(cmp_ctx_t *ctx, const void *data, uint32_t size) {', 1]
['*s1 = cur + delim_sz;', 1]
['buf.end = buf.last;', 1]
['bool cmp_read_u8(cmp_ctx_t *ctx, uint8_t *c);', 1]
['#include <util/nchan_reaper.h>', 1]
['DBG("filaname too long: %V", filename);', 1]
['void *redisvCommand(redisContext *c, const char *format, va_list ap);', 1]
['ngx_memcpy(&r->headers_out.status_line, &CREATED_LINE, sizeof(ngx_str_t));', 1]
['/* Remove the part of the string from left and from right composed just of', 1]
['#define NCHAN_WS_UPSTREAM_TMP_POOL_SIZE (4*1024)', 1]
['d->d.subscriber = NULL;', 1]
['ngx_uint_t                 reserved;', 1]
['seed->actives[i]=NULL;', 1]
['hashv ^= (hashv >> 11);                                                        \\', 1]
['ctx = ngx_http_get_module_ctx(rcur, nchan_module);', 1]
['chanhead->status = READY;', 1]
["//nothing more to do, we're finished here", 1]
['user, or `REDIS_ERR` when the disconnection was caused by an error. When it is `REDIS_ERR`, the `err`', 1]
['sent << publish(Msg.new(id, data: "foo", ttl: 30))', 1]
['ch = nchan_memstore_get_chanhead(chid, &cf);', 1]
['self->responded_count++;', 1]
['//just some random aborted subscriber', 1]
['d->getting = 0;', 1]
['DBG("init %s %p", name, tc);', 1]
['subscriber_t              *dbg_next;', 1]
['if (obj->type == CMP_TYPE_BOOLEAN) {', 1]
['if (write_byte(ctx, marker))', 1]
['ipc_try_close_fd(&proc->pipe[1]);', 1]
['case NCHAN_SUBSCRIBER_CONCURRENCY_LASTIN:', 1]
['const  ngx_str_t NCHAN_HEADER_ALLOW = ngx_string("Allow");', 1]
['void *               (*create)(ngx_str_t *id);', 1]
['lcf->subscriber_start_at_oldest_message=NGX_CONF_UNSET;', 1]
['ngx_str_t                      *if_none_match;', 1]
['bool cmp_read_float(cmp_ctx_t *ctx, float *f) {', 1]
['DBG("SUBSCRIBING to channel:pubsub:%V", channel_id);', 1]
['#include "memstore_redis.h"', 1]
['static int dictExpand(dict *ht, unsigned long size);', 1]
['test_cond("sdsrange(...,1,1)",', 1]
['assert(d->msg->id.tagcount == 1);', 1]
["case '9': return 9;", 1]
['* This flag means no new commands can come in and the connection', 1]
['if ((delptr)->hh.prev) {                                                 \\', 1]
['if (!cmp_read_ext32_marker(ctx, type, size))', 1]
['static: $(STLIBNAME)', 1]
['if(d->shm_channel_info != NULL) {', 1]
['buf = nchan_chain_to_single_buffer(r->pool, request_body_chain, content_length);', 1]
['sds sdsnewlen(const void *init, size_t initlen) {', 1]
['assert(sh->free >= incr);', 1]
['ngx_conf_merge_value(conf->msg_in_etag_only, prev->msg_in_etag_only, 0);', 1]
['else if (type_marker <= 0xBF) {', 1]
['static ngx_int_t spool_nextmsg(subscriber_pool_t *spool, nchan_msg_id_t *new_last_id) {', 1]
['vsnprintf(buf, buflen, fmt, cpy);', 1]
['"msgkey",', 1]
['typedef struct redisCallback {', 1]
['//now 2 newlines at the end', 1]
['void                        (*bulk_dequeue_handler)(channel_spooler_t *, subscriber_type_t, ngx_int_t, void *); //called after dequeueing 1 or many subs', 1]
['if (sh->buf != sp) memmove(sh->buf, sp, len);', 1]
['size_t l1, l2, minlen;', 1]
['subt->poll=1;', 1]
['ngx_http_complex_value_t        *publisher_upstream_request_url_ccv;', 1]
["/* Helper function for sdssplitargs() that returns non zero if 'c'", 1]
['bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u);', 1]
['ngx_buf_t               *mbuf = NULL, *buf=NULL;', 1]
['nchan_memstore_publish_generic(d->multi_chanhead, NULL, NGX_HTTP_GONE, &NCHAN_HTTP_STATUS_410);', 1]
['return sdscpylen(s, t, strlen(t));', 1]
['* of the string is obtained with strlen(). */', 1]
['#define REDIS_CONNECTED 0x2', 1]
['void              shm_verify_immutable_string(shmem_t *shm, ngx_str_t *str);', 1]
['redisGetReply(context,&reply); // reply for SET', 1]
['fsub->data.cln = NULL;', 1]
['char                        *name;', 1]
['cur->fake_slot = i;', 1]
['d->shm_channel_info= chan_info;', 1]
['if (obj.type != CMP_TYPE_FLOAT) {', 1]
['head->oldest_msgid.tagcount = 1;', 1]
['shdata->msgdebug_head = next;', 1]
['ngx_int_t                       subscribe_only_existing_channel;', 1]
['if(! ngx_atomic_cmp_set(&smsg->msg->refcount, 0, MSG_REFCOUNT_INVALID)) {', 1]
['ngx_memcpy(&remsg, msg, sizeof(*msg));', 1]
['ERR("can\'t create shared message for channel %V", &chead->id);', 1]
['nchan_msg_id_t *nchan_subscriber_get_msg_id(ngx_http_request_t *r);', 1]
['fsub->data.cln->handler = (ngx_http_cleanup_pt )sudden_abort_handler;', 1]
['else if (t1 < t2) {', 1]
['@tag= _empty_is_nil arg[:tag]', 1]
['DBG("%p status %i", self, status_code);', 1]
['ngx_free(tc);', 1]
['bool cmp_write_ext_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size);', 1]
['nchan_free_msg_id(&ch->latest_msgid);', 1]
['&longpoll_set_timeout_callback,', 1]
['* be encoded using UTF-8, but CMP leaves that job up to the programmer.', 1]
['evcf->max_messages = NGX_MAX_INT_T_VALUE;', 1]
['len = redisFormatCommand(&cmd,"SET foo bar");', 1]
["pvariant = (tolower(stype[0]) == 'p') ? 1 : 0;", 1]
['size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */', 1]
['* Note that sdscatrepr() is able to convert back a string into', 1]
['fwd_buf_to_str(mpb, sz, &msg->eventsource_event);', 1]
['## Asynchronous API', 1]
['#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)             \\', 1]
['uint64_t          n;', 1]
['overflow->next = NULL;', 1]
['* Reads a boolean as an unsigned char from the backend; this is useful if your', 1]
['stat->size, stat->num, stat->cnum, stat->lnum,', 1]
['if(chid_conf->n == 0) {', 1]
['/* ------------------------- private functions ------------------------------ */', 1]
['ERR("Sending of IPC alert delayed by %i sec", ngx_time() - alert->time_sent);', 1]
['subscriber_t *http_multipart_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id) {', 1]
['obj->type = CMP_TYPE_STR32;', 1]
['redisContext *redisConnectFd(int fd) {', 1]
['DBG("withdraw %s %p", rp->name, thing);', 1]
['f->dequeue(NGX_OK, NULL, f->privdata);', 1]
['//buffer is _copied_', 1]
['fsub->data.cln->handler = (ngx_http_cleanup_pt )request_cleanup_handler;', 1]
['test_inherit_fd = 0;', 1]
['static void set_buffer(ngx_buf_t *buf, u_char *start, u_char *last, ssize_t len) {', 1]
['else if (type_marker <= 0x8F) {', 1]
['dbg("new channel")', 1]
['ngx_uint_t                      i;', 1]
['fsub->data.awaiting_destruction = 1;', 1]
['rp->count = 0;', 1]
['if(cmp_to_msg(&cmp, &msg, &buf) == false) {', 1]
['r->integer = value;', 1]
['ngx_str_t                    ids[NCHAN_MULTITAG_MAX];', 1]
['head->oldest_msgid.tag.fixed[0] = 0;', 1]
['"      local msg=tohash(redis.call(\'HGETALL\', msg_id))\\n"', 1]
['subscriber_t *memstore_ipc_subscriber_create(ngx_int_t originator_slot, ngx_str_t *chid, uint8_t use_redis, void* foreign_chanhead) { //, nchan_channel_head_t *local_chanhead) {', 1]
['unsigned                     subbed:1;', 1]
['/* Writes binary data to the backend */', 1]
['extern const ngx_str_t NCHAN_HEADER_ALLOW_METHODS;', 1]
['assert(d->multi_chanhead->multi_waiting > 0);', 1]
['if (end < 0) {', 1]
['msg->id.tag.fixed[0] = 0;', 1]
['node = rbtree_create_node(urs, sizeof(*urnode) + id.len + msglen);', 1]
['ngx_int_t           i, procslot_found = 0;', 1]
['if (len == 0) return;', 1]
['req_msgid[i].time --;', 1]
['* the read(2) for the reply on QUIT will set the error to EOF.', 1]
['//debug', 1]
['else if (type_marker == S8_MARKER) {', 1]
['else tags = msg_id->tag.allocd;', 1]
['ngx_log_error(NGX_LOG_WARN, r->connection->log, 0, "nchan: can\'t allocate space for channel id");', 1]
['return ctx->write(ctx, &f, sizeof(float));', 1]
['int redis_nginx_fd_is_valid(int fd) {', 1]
['struct << str.join("\\n")', 1]
['"local max_stored_msgs = tonumber(redis.call(\'HGET\', key.channel, \'max_stored_messages\')) or -1\\n"', 1]
['switch(redis_array_to_channel(cur, &ch)) {', 1]
['chunked_fn->respond_message = chunked_respond_message;', 1]
['"    \\"msgkey\\",\\n"', 1]
['_hs_looping=0;                                                     \\', 1]
['cl->prev->next=cl->next;', 1]
['if (str != NULL) {', 1]
['test_cond(redisAppendFormattedCommand(c, cmd, len) == REDIS_OK);', 1]
['"-- result_code can be: 200 - ok, 404 - not found, 410 - gone, 418 - not yet available\\n"', 1]
['if(ch->sub_count > 0) {', 1]
['v->data = data;', 1]
['else if(nchan_strmatch(val, HTTP_CHUNKED_STRINGS_N, HTTP_CHUNKED_STRINGS)) {', 1]
['zone->data = (void *) 1;', 1]
['int16_t t1, t2;', 1]
['ev_io rev, wev;', 1]
['LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON', 1]
['DBG("IPC: received get_message request for channel %V privdata %p", d->shm_chid, d->privdata);', 1]
['"add_fakesub",', 1]
['(head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                        \\', 1]
['/* Reads an object from the backend */', 1]
['* escapes in the form "\\n\\r\\a...." or "\\x<hex-number>".', 1]
['if(smsg->msg->refcount > 0) {', 1]
['union subdata_u {', 1]
["if no_msgid_order ~= 'FIFO' then", 1]
['obj->as.boolean = false;', 1]
['typedef struct subscriber_pool_s subscriber_pool_t;', 1]
['bc[2].buf.last_in_chain = 1;', 1]
['"  cur = redis.call(\'HINCRBY\', chan_key, \'fake_subscribers\', num)\\n"', 1]
['channel_copy->last_seen = chead->shared->last_seen;', 1]
['t1 = (active < id1->tagcount) ? tags1[active] : -1;', 1]
['cur=cur->prev;', 1]
['rdt.connected = 0;', 1]
['head->redis_sub = memstore_redis_subscriber_create(head);', 1]
['struct store_message_s {', 1]
['if (!cmp_write_bin16_marker(ctx, size))', 1]
['subscriber_t               *sub;', 1]
['if ((ctx)->ev.cleanup) (ctx)->ev.cleanup((ctx)->ev.data); \\', 1]
['proc->active = 1;', 1]
['*      ceil(n/b) = (n>>lb) + ( (n & (b-1)) ? 1:0)', 1]
['r->ridx = 0;', 1]
['retmsg.shared = 0;', 1]
['} memstore_data_t;', 1]
['DBG("%p memstore-redis subsriber enqueued ok", d->sub);', 1]
['cur->type = REDIS_REPLY_ARRAY;', 1]
['if ((temp_pool = ngx_create_pool(4096, r->connection->log)) == NULL) {', 1]
['if(cl->next!=NULL)', 1]
['_hs_insize = 1;                                                            \\', 1]
['head->channel.last_published_msg_id.tagactive=0;', 1]
['#define CHECK_REPLY_INT(reply) ((reply)->type == REDIS_REPLY_INTEGER)', 1]
['ngx_int_t memstore_ipc_send_get_channel_info(ngx_int_t dst, ngx_str_t *chid, callback_pt callback, void* privdata) {', 1]
['When a function call is not successful, depending on the function either `NULL` or `REDIS_ERR` is', 1]
['memstore_ipc_send_get_channel_info(owner, channel_id, callback, privdata);', 1]
['if #msg.data < 5*1024 then', 1]
['//set up the boundaries', 1]
['/* If this is an unsubscribe message, remove it. */', 1]
['ngx_int_t nchan_set_msgid_http_response_headers(ngx_http_request_t *r, nchan_msg_id_t *msgid);', 1]
['ngx_conf_log_error(NGX_LOG_WARN, cf, 0, "ignoring obsolete nchan config directive \'%V\'.", &cmd->name);', 1]
['len = sdslen(s);', 1]
['static memstore_data_t  mdata[MAX_FAKE_WORKERS];', 1]
['#define CHANNEL_HASH_ADD(chanhead)      HASH_ADD_KEYPTR( hh, rdt.subhash, (chanhead->id).data, (chanhead->id).len, chanhead)', 1]
['//CORS origin match failed! return a 403 forbidden', 1]
['code = *(ngx_http_script_code_pt *) e.ip;', 1]
['#define CLOSE_POLICY_VIOLATION       1008', 1]
['static ngx_int_t nchan_store_subscribe_sub_reserved_check(ngx_int_t channel_status, void* _, subscribe_data_t *d);', 1]
['"    elseif no_msgid_order == \'FILO\' then --oldest message\\n"', 1]
['* value, than to do an O(n) bucket expansion too often.', 1]
['ssub->prev = NULL;', 1]
['//file descriptor cache', 1]
['static int disconnect(redisContext *c, int keep_fd) {', 1]
['tc->gc_timer.log=ngx_cycle->log;', 1]
['bc[1].buf.end = bc[1].buf.last;', 1]
['ngx_memcpy(fakebody_buf->start, buf->start, sz);', 1]
['r->headers_out.status_line.data=status_line->data;', 1]
['ac->ev.cleanup  = redisLibuvCleanup;', 1]
['To consume the synchronous API, there are only a few function calls that need to be introduced:', 1]
['int len; /* Length of string */', 1]
['while (r->ridx >= 0)', 1]
['/* The async API might try to disconnect cleanly and flush the output', 1]
['See the `adapters/` directory for bindings to *libev* and *libevent*.', 1]
['time_t                          time_elapsed = ngx_time() - last_seen;', 1]
['buf->last = buf->pos + dst_str.len;', 1]
['bool cmp_read_uinteger(cmp_ctx_t *ctx, uint64_t *d) {', 1]
['bool cmp_read_ufix(cmp_ctx_t *ctx, uint8_t *c) {', 1]
['static ngx_int_t chanhead_messages_delete(nchan_store_channel_head_t *ch) {', 1]
['void sdsrange(sds s, int start, int end) {', 1]
['const char *host;', 1]
['"Error writing size",', 1]
['uint32_t high_part = ntohl((uint32_t)(value >> 32));', 1]
['ngx_int_t ipc_init(ipc_t *ipc) {', 1]
['sds sdscatrepr(sds s, const char *p, size_t len);', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SHMEM(%i):" fmt, memstore_slot(), ##args)', 1]
['&websocket_respond_status,', 1]
["if (s[pos+1] == '\\n') {", 1]
['#include <ae.h>', 1]
['obj = r->fn->createString(cur,p,len);', 1]
['const  ngx_str_t NCHAN_ANYSTRING= ngx_string("*");', 1]
['"  dbg(\\"channel \\", id, \\" already gone\\")\\n"', 1]
['if(shdata->reloading == 0) {', 1]
['}                                                 \\', 1]
['assert(rsv_found);', 1]
['//construct channel', 1]
['ngx_int_t         rc;', 1]
['test_cond(strcasecmp(reply->str,"OK") == 0 &&', 1]
['ngx_int_t              rc;', 1]
['DBG("message GC results: started with %i, walked %i, deleted %i msgs", started_count, tried_count, deleted_count);', 1]
['(head)->hh.prev = NULL;                                                      \\', 1]
['char *find_channel;', 1]
['redisContext *redisConnect(const char *ip, int port) {', 1]
['init_spool(spl, spool, id);', 1]
['ngx_uint_t           messages = 0;', 1]
['case 2: _mur_k1 ^= _mur_tail[1] << 8;                              \\', 1]
['free(c);', 1]
["**Important:** the current version of hiredis (0.10.0) free's replies when the", 1]
['if(min->time <= cur->time) {', 1]
['ch.last_published_msg_id.time=d->msg_time;', 1]
['srdata.multi = msg->id.tagcount;', 1]
['DBG("%p enqueue", self);', 1]
['offsetof(nchan_loc_conf_t, channel_id_split_delimiter),', 1]
["channel=      'channel:'..id, --hash", 1]
['str.data=(u_char *)"{NULL}";', 1]
['DBG("prev best response: %V (n:%i) %p", d->msg ? msgid_to_str(&d->msg->id) : &empty_id_str, d->n, d->msg);', 1]
['rdt.cleanup_timer.log=ngx_cycle->log;', 1]
['/* Reads an unsigned integer that fits inside an unsigned short */', 1]
['ELMT_FROM_HH((head)->hh.tbl,_hs_tail) : NULL);              \\', 1]
['return cmp_write_fixext1(ctx, tp, data);', 1]
['static ngx_buf_t *set_buf(ngx_buf_t *buf, u_char *start, off_t len){', 1]
['if (!cmp_write_fixext1_marker(ctx, type))', 1]
['[IPC_PUBLISH_MESSAGE_REPLY] =       (ipc_handler_pt )receive_publish_message_reply,', 1]
['if(slot == NCHAN_INVALID_SLOT) {', 1]
['sds sdscatsds(sds s, const sds t) {', 1]
['r->headers_out.content_type.len=msg->content_type.len;', 1]
['#define NCHAN_CHANHEAD_EXPIRE_SEC 5', 1]
['static void nchan_store_chanhead_cleanup_timer_handler(ngx_event_t *);', 1]
['static ngx_int_t memstore_reap_message( nchan_msg_t *msg ) {', 1]
['#define NCHAN_CHANHEAD_EXPIRE_SEC 1', 1]
['can be either `REDIS_OK` or `REDIS_ERR`, where the latter means something went', 1]
['#define CHECK_REPLY_STRVAL(reply, v) ( CHECK_REPLY_STR(reply) && ngx_strcmp((reply)->str, v) == 0 )', 1]
['//dd("subrequest body: %p", sr->request_body);', 1]
['ngx_int_t                       longpoll_multimsg;', 1]
['struct sdshdr *sh, *newsh;', 1]
['__redisRunCallback(ac,&cb,reply);', 1]
['return cmp_write_array16(ctx, size);', 1]
['"subscriber_unregister",', 1]
['redisReaderFree(c->reader);', 1]
['* may delete the entry we are returning. */', 1]
['if(src->tagcount > NCHAN_FIXED_MULTITAG_MAX) {', 1]
['/* Add bytes needed to hold multi bulk count */', 1]
['rdt.chanhead_cleanup_tail = NULL;', 1]
['//delete all messages', 1]
["/* Reads the extended type's marker from the backend */", 1]
['void sdsfreesplitres(sds *tokens, int count) {', 1]
['unsigned _hf_bkt,_hf_hashv;                                                    \\', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "NCHAN:" fmt, ##args)', 1]
['static channel_spooler_fn_t  spooler_fn = {', 1]
['last->next = cur;', 1]
['"  dbg(\\"channel present\\")\\n"', 1]
['float                      max_notready_ratio;', 1]
['chead->max_messages = cf->max_messages;', 1]
['chmsg->prev = NULL;', 1]
['freeReplyObject(redisCommand(c,"MULTI"));', 1]
['*f = obj.as.flt;', 1]
['commands are no longer accepted and the connection is only terminated when all pending commands', 1]
['ngx_int_t internal_subscriber_set_respond_status_handler(subscriber_t *sub, callback_pt handler);', 1]
['that is called when the reply is received. Reply callbacks should have the following prototype:', 1]
['else if(pool == NULL && (content_type = ngx_alloc(sizeof(*content_type) + msg->content_type.len, ngx_cycle->log))==NULL) {', 1]
['static ngx_chain_t *websocket_frame_header_chain(full_subscriber_t *fsub, const u_char opcode, off_t len);', 1]
['/* Free the table and the allocated cache structure */', 1]
['def hashes; @@hashes; end', 1]
["next_message= 'channel:msg:%s:'..id, --hash", 1]
['if (request_chain->next != NULL) {', 1]
['static ngx_int_t ipc_read_socket(ngx_socket_t s, ipc_alert_t *alert, ngx_log_t *log) {', 1]
['printf("\\nTesting against TCP connection (%s:%d):\\n", cfg.tcp.host, cfg.tcp.port);', 1]
['if(reply != NULL && reply->type == REDIS_REPLY_ERROR) {', 1]
['/* This function selects items from one hash into another hash.', 1]
['&& CHECK_REPLY_STRVAL(reply->element[0], "subscribe")', 1]
['/* Helper function for sdssplitargs() that converts a hex digit into an', 1]
['"    nearly_departed[i]=tonumber(nearly_departed[i]) or 0\\n"', 1]
['assert(rp->last != NULL && rp->first != NULL);', 1]
["case '2': return 2;", 1]
['if(ch->slot != ch->owner) {', 1]
["//let's get out of this hellish loop", 1]
['argument `reply` point to the created `redisReply` variable. For instance, if', 1]
['if (_len) *_len = len;', 1]
['test("Throughput:\\n");', 1]
['sh->len = reallen;', 1]
['if(lastid->time == 0', 1]
['static ngx_int_t nchan_set_content_length_header(ngx_http_request_t *r, off_t len, u_char *p) {', 1]
['_bkt_count = 0;                                                      \\', 1]
['if(d->n == 0) {', 1]
['int redisvFormatCommand(char **target, const char *format, va_list ap);', 1]
['seed->compare = compare;', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "WEBSOCKET_PUBLISHER:" fmt, ##arg)', 1]
['#define _EL_CLEANUP(ctx) do { \\', 1]
['if (!cmp_read_fixext8_marker(ctx, type))', 1]
['an error state. The field `errstr` will contain a string with a description of', 1]
['sdsrange(c->obuf,nwritten,-1);', 1]
['redisAsyncCommand(rds_ctx(), &redis_subscriber_register_callback, sdata, "EVALSHA %s 0 %b - %i %s", store_rds_lua_hashes.subscriber_register, STR(&chanhead->id), -1, concurrency);', 1]
['((internal_subscriber_t *)sub)->enqueue = handler;', 1]
['{ ngx_string("nchan_message_max_buffer_length"), //alt for nchan_message_buffer_length', 1]
['sh = (void*)(s-sizeof *sh);', 1]
['//redisAsyncCommand(rds_sub_ctx(), NULL, NULL, "UNSUBSCRIBE channel:%b:pubsub", str(&(channel->id)));', 1]
['nchan_channel_t              chaninfo;', 1]
["if (_p[0] == 'l') {", 1]
['&& CHECK_REPLY_INT_OR_STR(els[offset+4])   //prev_id - tag', 1]
['s = sdsMakeRoomFor(s,len);', 1]
['unsigned _hs_i;                                                                \\', 1]
['if(head->foreign_owner_ipc_sub == NULL && head->status != WAITING) {', 1]
['subscriber_pool_t         *spools[SPOOLER_RESPOND_SPOOLARRAY_SIZE];', 1]
['nchan_reaper_add(&mpt->chanhead_reaper, ch);', 1]
['"{\\"messages\\": %ui, "', 1]
['return found;', 1]
['static ngx_int_t nchan_store_subscribe_continued(ngx_int_t channel_status, void* _, subscribe_data_t *d);', 1]
['typedef enum {LONGPOLL, HTTP_CHUNKED, HTTP_MULTIPART, INTERVALPOLL, EVENTSOURCE, WEBSOCKET, INTERNAL, SUBSCRIBER_TYPES} subscriber_type_t;', 1]
['bool cmp_write_bool(cmp_ctx_t *ctx, bool b) {', 1]
['e.ip = val->values;', 1]
['return ctx->write(ctx, &d, sizeof(double));', 1]
['static ngx_int_t publish_callback(ngx_int_t status, void *rptr, ngx_http_request_t *r) {', 1]
['eventsource_fn->respond_message= es_respond_message;', 1]
['* so that next append operations will not require allocations up to the', 1]
['if(time != NGX_ERROR) {', 1]
['case 1: hashv += *_sfh_key;                                                  \\', 1]
['size_t                     rem;', 1]
['close_code = CLOSE_POLICY_VIOLATION;', 1]
['if(es_event_len > 0) {', 1]
['bool cmp_read_ext8_marker(cmp_ctx_t *ctx, int8_t *type, uint8_t *size) {', 1]
['subscriber_pool_t *spool;', 1]
["/* Let's check what we have inside the list */", 1]
['struct recycloc_s {', 1]
['SUB_ENQUEUE, SUB_DEQUEUE, SUB_RECEIVE_MESSAGE, SUB_RECEIVE_STATUS,', 1]
['+ ( (unsigned)_hj_key[11] << 24 ) );                                     \\', 1]
['c = redisConnect((char*)"localhost", 1);', 1]
['test_cond(strncmp(cmd,"*2\\r\\n$12\\r\\nkey:0123.000\\r\\n$9\\r\\nstr:hello\\r\\n",len) == 0 && \\', 1]
['d->last_msgid = head->channel.last_published_msg_id;', 1]
['nchan_store_channel_head_t *nchan_memstore_get_chanhead_no_ipc_sub(ngx_str_t *channel_id, nchan_loc_conf_t *cf);', 1]
['_prev = (char*)(_thh);                                            \\', 1]
['else if(CHECK_REPLY_NIL(r)) {', 1]
['bool cmp_read_fixext2_marker(cmp_ctx_t *ctx, int8_t *type);', 1]
['ngx_int_t         tag1;', 1]
['//set channel', 1]
['redisReader *redisReaderCreate(void) {', 1]
['bool cmp_read_ext16(cmp_ctx_t *ctx, int8_t *type, uint16_t *size, void *data);', 1]
['_thh = _thh->hh_next;                                             \\', 1]
['#define _EL_ADD_READ(ctx) do { \\', 1]
['connection->write->log = connection->log;', 1]
['* you want to increment (set), and then decrement (free), and not the', 1]
['//DBG("push fakeprocess %i onto stack", slot);', 1]
['assert(cur != msg);', 1]
['"        local ttl = redis.call(\'TTL\', msg_id)\\n"', 1]
['};                                                                             \\', 1]
['return ctx->write(ctx, &l, sizeof(uint64_t));', 1]
['return cmp_write_float(ctx, f);', 1]
['CMP_TYPE_FIXMAP,          /*  1 */', 1]
['if(r) {', 1]
['bool cmp_object_is_bin(cmp_object_t *obj);', 1]
['rp->name = name;', 1]
['/* Always schedule reads after writes */', 1]
['cn += stat->cnum;', 1]
['if((msg = msg_from_redis_get_message_reply(reply, 0, ngx_store_alloc)) == NULL) {', 1]
['subscriber_t                   *foreign_owner_ipc_sub; //points to NULL or inaacceessible memory.', 1]
['__redisSetError(c,REDIS_ERR_EOF,"Server closed the connection");', 1]
['DBG("memstore init_module pid %i. ipc: %p, procslot_offset: %i", ngx_pid, ipc, memstore_procslot_offset);', 1]
['str << "  char *#{name};\\n"', 1]
['ngx_memcpy(data, buf->pos, limit);', 1]
['(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;', 1]
['static void __redisReaderSetError(redisReader *r, int type, const char *str) {', 1]
['"find_channel",', 1]
['CONN_FD', 1]
['bc[1].buf.start = headerbuf;', 1]
['ngx_int_t memstore_ready_chanhead_unless_stub(nchan_store_channel_head_t *head) {', 1]
['bool cmp_object_as_char(cmp_object_t *obj, int8_t *c) {', 1]
['self->bulk_post_subscribe_handler(self, 1, self->bulk_post_subscribe_privdata);', 1]
['#include <poll.h>', 1]
['int16_t        *allocd;', 1]
['if(fsub->data.finalize_request) {', 1]
['ipc_alert(nchan_memstore_get_ipc(), sender, IPC_SUBSCRIBER_KEEPALIVE_REPLY, d, sizeof(*d));', 1]
['elsif arg.length==2', 1]
['memstore_reap_message(smsg->msg);', 1]
['strcasecmp(reply->str,"ok") == 0)', 1]
['if(ctx == NULL  || (ctx->prev_msg_id.time == 0 && ctx->prev_msg_id.tagcount == 0)) {', 1]
['nchan_loc_conf_t               cf;', 1]
['nchan_msg_id_t             min;', 1]
['return mpt->fake_slot;', 1]
['tags2 = max2 <= NCHAN_FIXED_MULTITAG_MAX ? id2->tag.fixed : id2->tag.allocd;', 1]
['# Binaries:', 1]
['if(ctx == NULL) {', 1]
['nchan_message_buffer_length [:main, :srv, :loc],', 1]
['[IPC_GET_CHANNEL_INFO_REPLY]=       (ipc_handler_pt )receive_get_channel_info_reply,', 1]
['test("Memory cleanup in reply parser: ");', 1]
['#include <hiredis/async.h>', 1]
["redis.call('HSET', key.last_message, 'next', msg.id)", 1]
['bool cmp_object_to_str(cmp_ctx_t *ctx, cmp_object_t *obj, char *data, uint32_t buf_size) {', 1]
['#define HASH_DELETE(hh,head,delptr)                                              \\', 1]
['memstore_fakeprocess_push(SUB_FAKE_WORKER);', 1]
['cur->spooler.fn->respond_status(&cur->spooler, NGX_HTTP_GONE, &NCHAN_HTTP_STATUS_410);', 1]
['* === Main API', 1]
['* The caller should free the resulting array of sds strings with', 1]
['subscriber_t *(*sub_create)(ngx_http_request_t *r, nchan_msg_id_t *msg_id) = NULL;', 1]
['static void memstore_pub_debug_start() {', 1]
['/* Set error. */', 1]
['/* Perform the carry for the later subtraction by updating y. */', 1]
['} UT_hash_bucket;', 1]
['ctx->sub = &fsub->sub;', 1]
['if (!write_type_marker(ctx, MAP16_MARKER))', 1]
['redisAsyncCommand(rds_ctx(), &redis_subscriber_register_callback, sdata, "EVALSHA %s 0 %b %i %i %s", store_rds_lua_hashes.subscriber_register, STR(&chanhead->id), 0 /*TODO: current sub\'s ID*/, -1, concurrency);', 1]
['key.next_message=key.next_message:format(msg.next)', 1]
['publish_status_data_t  data = {str_shm_copy(chid), status_code, status_line, callback, privdata};', 1]
['if (major >= 2 && minor > 0) {', 1]
['*priority = start;', 1]
['ngx_int_t nchan_memstore_handle_get_message_reply(nchan_msg_t *msg, nchan_msg_status_t findmsg_status, void *data) {', 1]
['multi[i].sub = NULL;', 1]
['//#define DEBUG_MEMZERO(var) ngx_memzero(var, sizeof(*(var)))', 1]
['ngx_atomic_t                last_seen;', 1]
['channel_spooler_t *spl;', 1]
['return nchan_store_chanhead_publish_message_generic(chead, msg, msg_in_shm, cf, callback, privdata);', 1]
['if (isprint(*p))', 1]
['data_prefix_buf = &data_prefix_real_buf;', 1]
['ngx_int_t memstore_ipc_send_memstore_subscriber_keepalive(ngx_int_t dst, ngx_str_t *chid, subscriber_t *sub, nchan_store_channel_head_t *ch, callback_pt callback, void *privdata);', 1]
['f = befloat(f);', 1]
['} else if ( (_hs_qsize == 0) || !(_hs_q) ) {                   \\', 1]
['static void init_mpt(memstore_data_t *m) {', 1]
['double_newline_buf.end = double_newline_buf.start + 4;', 1]
['ngx_memzero(&rdt.subscriber_id, sizeof(rdt.subscriber_id));', 1]
['ngx_int_t memstore_ipc_send_get_channel_info(ngx_int_t dst, ngx_str_t *chid, callback_pt callback, void* privdata);', 1]
['local sub_count = 0', 1]
['#    - broadcast: any number of concurrent subscriber requests may be held.', 1]
['d->cb(findmsg_status, msg, d->cb_privdata);', 1]
['ngx_memzero(numsubs, sizeof(numsubs));', 1]
['if (!(c->flags & REDIS_IN_CALLBACK) && ac->replies.head == NULL)', 1]
['/* Execute callbacks for invalid commands */', 1]
["cur=getmsg Msg.new(id), sub: 'foobar'", 1]
['u_char              idbuf[1024];', 1]
['#define WEBSOCKET_OPCODE_TEXT               0x1', 1]
['subscriber_pool_t           current_msg_spool;', 1]
['redisContext *redisConnectFd(int fd);', 1]
['*i = obj.as.s8;', 1]
['int                        tick_usec;', 1]
['#include <subscribers/eventsource.h>', 1]
['#define HASH_CNT(hh,head) ((head)?((head)->hh.tbl->num_items):0)', 1]
['r->pool = psrd->tmp_pool;', 1]
['bool cmp_write_u64(cmp_ctx_t *ctx, uint64_t l) {', 1]
['"hmset(key.message, msg)\\n"', 1]
['/* Internal helper function to try and get a reply from the reader,', 1]
['cur=n', 1]
['return websocket_frame_header(buf, WEBSOCKET_TEXT_LAST_FRAME_BYTE, len);', 1]
['//ngx_http_core_main_conf_t  *cmcf;', 1]
['"  subscribers=  \'channel:subscribers:\'..id,\\n"', 1]
['if (ctx->write(ctx, data, 2))', 1]
['"local no_msgid_order=ARGV[4]\\n"', 1]
['if(thing == rp->last)  rp->last  = prev;', 1]
['$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< $(STLIBNAME)', 1]
['* and the length in bytes as a size_t. Examples:', 1]
['if(rdt.cleanup_timer.timer_set) {', 1]
['ERR("gc_add chanhead %V: already added", &head->id);', 1]
['/* Helper function to make the disconnect happen and clean up. */', 1]
['return d;', 1]
['static const uint32_t mp_version = 5;', 1]
['//zombie publisher', 1]
['u_char  c, *last;', 1]
['sha1_str.len=20;', 1]
['int sdscmp(const sds s1, const sds s2);', 1]
['typedef ngx_int_t (*rbtree_walk_callback_pt)(rbtree_seed_t *, void *, void *);', 1]
['for (i = 0; i < NGX_POOL_STATS_MAX; i++) {', 1]
['/* Helper function to free the context. */', 1]
['return {err="Subscriber count for channel " .. id .. " less than zero: " .. sub_count}', 1]
['ngx_http_variable_t           *v;', 1]
['_prev = NULL;                                                            \\', 1]
['ngx_int_t nchan_reaper_start(nchan_reaper_t *rp, char *name, int prev, int next, ngx_int_t (*ready)(void *, uint8_t force), void (*reap)(void *), int tick_sec);', 1]
['nchan_reaper_start(&m->chanhead_reaper,', 1]
['*d = obj->as.u16;', 1]
['_sfh_len >>= 2;                                                                \\', 1]
['r->headers_out.content_length_n = size;', 1]
['ngx_rbtree_node_t              *root = seed->tree.root;', 1]
['snprintf(_port, 6, "%d", port);', 1]
['ngx_destroy_pool(tmp_pool);', 1]
['dbg("no msg id given, ord="..no_msgid_order)', 1]
['[IPC_GET_MESSAGE_REPLY] =           (ipc_handler_pt )receive_get_message_reply,', 1]
['static void nchan_store_chanhead_cleanup_timer_handler(ngx_event_t *ev) {', 1]
['kb in order to avoid wasting memory in unused buffers', 1]
['if((file = ngx_pcalloc(r->pool, sizeof(*file))) == NULL) {', 1]
['if(if_none_match==NULL) {', 1]
['* Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the', 1]
['#define REDIS_OK 0', 1]
['if(data) { //zone being passed after restart', 1]
["-- redis doesn't do includes. It could be generated pre-insertion into redis,", 1]
['//no lock needed, no one else knows about this chanhead yet.', 1]
['bool cmp_read_pfix(cmp_ctx_t *ctx, uint8_t *c);', 1]
['publish_callback_data        *cd;', 1]
['event_add(&e->wev,NULL);', 1]
['ngx_int_t                       fake_slot;', 1]
['test("Returns error when the port is not open: ");', 1]
['static void redis_subscriber_register_callback(redisAsyncContext *c, void *vr, void *privdata) {', 1]
['"  last_message= nil,\\n"', 1]
['//find all spools between msg->prev_id and msg->id', 1]
['-- sets all fields for a hash from a dictionary', 1]
['nchan_expand_msg_id_multi_tag(&retmsg.id, 0, n, -1);', 1]
['if not channel.ttl then', 1]
['ngx_memcpy(&bc[0].buf, data_prefix_buf, sizeof(*data_prefix_buf));', 1]
['if (!write_type_marker(ctx, S32_MARKER))', 1]
['static int _dictClear(dict *ht) {', 1]
["cur[1]='/';", 1]
['const char *path;', 1]
['ngx_chain_t              *chain = NULL;', 1]
['*d = obj->as.s64;', 1]
['ngx_int_t longpoll_enqueue(subscriber_t *self) {', 1]
['chanhead_gc_add(head, "add owner chanhead after publish");', 1]
['if_none_match = nchan_subscriber_get_etag(r);', 1]
['hiredis-example-libevent: examples/example-libevent.c adapters/libevent.h $(STLIBNAME)', 1]
['if (r->fn && r->fn->createInteger)', 1]
['ctx->publisher_type = &pub_name;', 1]
['ERR("Unable to add request cleanup for longpoll subscriber");', 1]
['ngx_slab_free(SHPOOL(shm), p);', 1]
['if(ngx_strncasecmp(val->data, match, val->len)==0) {', 1]
['ngx_int_t ipc_close(ipc_t *ipc, ngx_cycle_t *cycle) {', 1]
['bool cmp_write_true(cmp_ctx_t *ctx);', 1]
['DBG("%p respond req %p status %i", self, r, status_code);', 1]
['redisAsyncCommand(ac, redis_nginx_ping_callback, NULL, PING_DATABASE_COMMAND);', 1]
['[IPC_PUBLISH_STATUS] =              (ipc_handler_pt )receive_publish_status,', 1]
['rp->last = thing;', 1]
['//DBG("======= updating multi_msgid ======");', 1]
['spooler_prepare_to_stop,', 1]
['len = redisFormatCommand(&cmd,"key:%08p %b",(void*)1234,"foo",(size_t)3);', 1]
['obj->as.ext.size = 1;', 1]
['static nchan_llist_timed_t *fakeprocess_top = NULL;', 1]
["if((ret = ngx_strlchr(cur, last, ':')) == NULL) {", 1]
["if (*_p != '\\0' && *_p == '+') _p++;", 1]
['chaninfo_copy.messages = ch->shared->stored_message_count;', 1]
['//generate the headers', 1]
['if(chmsg == NULL && use_redis) {', 1]
['prev_ptr = thing_prev_ptr(rp, cur);', 1]
['size_t msgtag_to_strptr(nchan_msg_id_t *id, char *ch);', 1]
['static ngx_int_t nchan_store_subscribe_continued(redis_subscribe_data_t *d) {', 1]
['offsetof(nchan_loc_conf_t, eventsource_event),', 1]
['store_message_t *chanhead_find_next_message(nchan_store_channel_head_t *ch, nchan_msg_id_t *msgid, nchan_msg_status_t *status);', 1]
['sub->fn->respond_status(sub, NGX_HTTP_NO_CONTENT, NULL);', 1]
['hashv = 0xfeedbeef;                                                            \\', 1]
['bool cmp_object_is_short(cmp_object_t *obj) {', 1]
['psr->handler = websocket_publisher_upstream_handler;', 1]
['static ngx_flag_t is_utf8(u_char *, size_t);', 1]
['ngx_memcpy(thing->id.data, id->data, id->len);', 1]
['nchan_store_multi_t         *multi = NULL;', 1]
['* The use of _hd_hh_del below deserves special explanation.', 1]
['case \'\\t\': len = snprintf(buf,size,"\\"\\\\t\\""); break;', 1]
['bool cmp_read_ext32(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data) {', 1]
['size_t    debug_sz = m->lbl.len;', 1]
['Hiredis comes with an asynchronous API that works easily with any event library.', 1]
['rv = REDIS_OK;', 1]
['return he;', 1]
['_he_thh;                                                         \\', 1]
['h->value.len = header_value->len;', 1]
['info: "Channel id for publisher location."', 1]
['assert(d->sub->reserved == 0);', 1]
['nchan_channel_timeout [:main, :srv, :loc],', 1]
["//ok, it's just the first-per-second message of a channel from a multi-channel", 1]
['fsub->respond_message = empty_callback;', 1]
['rdt.chanhead_cleanup_head=cl->next;', 1]
['sds sdsnewlen(const void *init, size_t initlen);', 1]
['cur = accept;', 1]
['d->http_response_code = r->headers_out.status;', 1]
['&& CHECK_REPLY_INT(r->element[1])', 1]
['((internal_subscriber_t *)sub)->notify = handler;', 1]
['int redisReaderFeed(redisReader *reader, const char *buf, size_t len);', 1]
['ERR("nchan: unexpected msgpack message from redis");', 1]
["local oldmsgid = redis.call('RPOP', key.messages)", 1]
['static void enqueue_llist_thing(nchan_thing_cache_t *tc, nchan_llist_timed_t *cur) {', 1]
['obj->as.bin_size = obj->as.u8;', 1]
['if(max <= NCHAN_FIXED_MULTITAG_MAX) {', 1]
['if(data->n > SPOOLER_RESPOND_SPOOLARRAY_SIZE) {', 1]
['ngx_int_t nchan_respond_string(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *content_type, const ngx_str_t *body, ngx_int_t finalize) {', 1]
['DBG("multi[%i] of %i msg NOTFOUND", sd->n, d->multi_count);', 1]
['sdsfree((sds)key);', 1]
['prepend_es_response_line(&event_line, &first_link, &sub->cf->eventsource_event, pool);', 1]
['obj->type = CMP_TYPE_MAP32;', 1]
['ngx_int_t websocket_subscriber_destroy(subscriber_t *sub) {', 1]
['chanhead->spooler.fn->add(&chanhead->spooler, d->sub);', 1]
['ngx_int_t rbtree_walk(rbtree_seed_t *seed, rbtree_walk_callback_pt callback, void *data) {', 1]
['fsub->respond_status = empty_callback;', 1]
['if(pd->ch.last_seen < ch->last_seen) {', 1]
['d->channel_id.len = channel_id->len;', 1]
['bool cmp_write_bool(cmp_ctx_t *ctx, bool b);', 1]
['nchan_copy_new_msg_id(&spool->id, &new_id);', 1]
['typedef struct nchan_loc_conf_s nchan_loc_conf_t;', 1]
['ngx_str_t                       redis_url;', 1]
['uint16_t              n;', 1]
['//walk it forwards', 1]
['"  data= ARGV[3],\\n"', 1]
['is_hex_digit(*(p+3)))', 1]
['d->chanhead = chead;', 1]
['CMP_TYPE_UINT16,          /* 15 */', 1]
['typedef void (*ipc_handler_pt)(ngx_int_t, void *);', 1]
['sds sdsempty(void);', 1]
['* the first write event to be fired. This assumes the related event', 1]
['r->header_only = 0;', 1]
['void shm_verify_immutable_string(shmem_t *shm, ngx_str_t *str) {', 1]
['socks = proc->pipe;', 1]
['msg->msg->prev_id.time = 0;', 1]
['static void redisLibeventDelWrite(void *privdata) {', 1]
['if(status_code == NGX_HTTP_NO_CONTENT || status_code == NGX_HTTP_NOT_MODIFIED || status_code == NGX_HTTP_NOT_FOUND ) {', 1]
['PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER', 1]
['if(ch) {', 1]
['{ ngx_string("push_authorized_channels_only"), //legacy for nchan_subscribe_existing_channels_only', 1]
['///DBG("looking at overflow %p next %p", of, of->next);', 1]
['* ngx_http_headers_in_t too? */', 1]
['#define IPC_SUBSCRIBE_REPLY         2', 1]
['DBG("sent subscribe reply for channel %V to %i", d->shm_chid, sender);', 1]
['ERR("can\'t create rbtree node for spool");', 1]
["* end of the string according to 'incr'. Also set the null term", 1]
['if(fp) {', 1]
['typedef struct redisAeEvents {', 1]
['redisAsyncCommand(rds_sub_ctx(), redis_subscriber_callback, head, "SUBSCRIBE channel:pubsub:%b", STR(channel_id));', 1]
['ngx_str_t                 custom_close_msg;', 1]
['ngx_conf_merge_value(conf->use_redis, prev->use_redis, 0);', 1]
['bc->chain.next = *first_chain;', 1]
['if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)', 1]
['hashv ^= hashv << 10;                                                \\', 1]
['#define NCHAN_TYPES_H', 1]
['instantly return if the specified host and port is able to accept a connection.', 1]
['return ctx->write(ctx, &s, sizeof(uint16_t));', 1]
['msg.ttl or 0,', 1]
['int16_t *tags = n <= NCHAN_FIXED_MULTITAG_MAX ? id->tag.fixed : id->tag.allocd;', 1]
['NGX_HTTP_MODULE,               /* module type */', 1]
['if(fsub->ping_ev.timer_set) {', 1]
['/* Called when either the connection is terminated due to an error or per', 1]
['if (!cmp_write_ext32_marker(ctx, tp, sz))', 1]
['// this function adapted from push stream module. thanks Wandenberg Peixoto <wandenberg@gmail.com> and Rog\xc3\xa9rio Carvalho Schneider <stockrt@gmail.com>', 1]
['msg->prev_id.tag.fixed[0] = msgtag;', 1]
['normal Redis context, the above API just exposes it to the user for a direct', 1]
['if(hash==NULL) {', 1]
['static void redisLibevDelRead(void *privdata) {', 1]
['ac->ev.cleanup = redisLibeventCleanup;', 1]
['if(!head->use_redis && !head->multi) {', 1]
['ERR("looks like spooler is already running. make sure spooler->running=0 befire starting.");', 1]
['if (ngx_nonblocking(socks[j]) == -1) {', 1]
['assert(count == 0);', 1]
['{ ngx_string("nchan_publisher_channel_id"),', 1]
['int16_t           i = 0;', 1]
['ssub = ngx_calloc(sizeof(*ssub), ngx_cycle->log);', 1]
['bc[2].buf.end = chunk_end + 2;', 1]
['e.message.gsub!(/:\\s+(user_script):(\\d+):/, ": \\n#{name}.lua:\\\\2:")', 1]
['int root = 0;', 1]
['assert_match /cannot contain ":"/, e.message', 1]
['int touched = 0; /* was the current argument touched? */', 1]
['the `err` field in the context can be used to find out what the cause of this error is.', 1]
['printf("ALL TESTS PASSED\\n");', 1]
['nchan_llist_timed_t    *prev, *next;', 1]
['ERR("can\'t enqueue shared message for channel %V", &chead->id);', 1]
["//no file given, can't allocate from NULL pool", 1]
['//DBG("dequeue sub %p in spool %p", sub, spool);', 1]
['assert(shm_msg->shared == 1);', 1]
['#define NCHAN_MODULE_H', 1]
['typedef struct spooled_subscriber_s spooled_subscriber_t;', 1]
['concurrency = "FILO";', 1]
['nchan_channel_t      *chan_info;', 1]
['offsetof(nchan_store_channel_head_t, gc_next),', 1]
['local id, sub_id, empty_ttl = ARGV[1], ARGV[2], tonumber(ARGV[3]) or 20', 1]
['if(!cf->msg_in_etag_only && r->headers_in.if_modified_since != NULL) {', 1]
['if (buf != NULL && len >= 1) {', 1]
['bool cmp_write_ext8_marker(cmp_ctx_t *ctx, int8_t type, uint8_t size);', 1]
['if(!fsub->shook_hands) {', 1]
['local msgpacked', 1]
['close_msg = (ngx_str_t *)(status_line ? status_line : &STATUS_403);', 1]
['major = strtol(p+strlen(field),&eptr,10);', 1]
['ngx_str_t                  *chid;', 1]
['if found_msg_id == nil then', 1]
['data.d.origin_chanhead = origin_chanhead;', 1]
["redis.call('PUBLISH', channel_pubsub, msgpacked)", 1]
['/* Get the index of the new element, or -1 if', 1]
['return cmp_write_pfix(ctx, u);', 1]
['else if(ngx_strmatch(&msg_type, "ch+msg")) {', 1]
['u_char                 *cur = NULL, *last = NULL;', 1]
['UT_hash_handle               hh;', 1]
['size_t                     sz;', 1]
['void  *id = seed->id(rbtree_data_from_node(node));', 1]
['extern const  ngx_str_t NCHAN_CACHE_CONTROL_VALUE;', 1]
['unsigned _he_bkt_i;                                                          \\', 1]
['"--output: result_code, msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, channel_subscriber_count\\n"', 1]
['* exceeds the ideal chain maxlen. these items pay the penalty for an uneven', 1]
['size_t                  sz = fmt->len + str->len;', 1]
['assert(socks[0] == NGX_INVALID_FILE && socks[1] == NGX_INVALID_FILE);', 1]
['"local time, tag, prev_time, prev_tag, data, content_type, es_event = unpack(redis.call(\'HMGET\', key, \'time\', \'tag\', \'prev_time\', \'prev_tag\', \'data\', \'content_type\', \'eventsource_event\'))\\n"', 1]
['ngx_atomic_int_t                   max_workers;', 1]
['id.len = ngx_sprintf(idbuf, "%V | %V", uri, msgid_to_str(msgid)) - idbuf;', 1]
['The server closed the connection which resulted in an empty read.', 1]
['databuf.file_last = fcur;', 1]
['.c.o:', 1]
['nchan_main_conf_t      *mcf = ngx_pcalloc(cf->pool, sizeof(*mcf));', 1]
['static nchan_store_channel_head_t *chanhead_memstore_create(ngx_str_t *channel_id, nchan_loc_conf_t *cf) {', 1]
['nchan_msg_t                       *msgs;', 1]
['qval_fp = ngx_atofp(cur, last - cur, 2);', 1]
['Therefore, unlike the synchronous API, there is only a single way to send commands.', 1]
['nchan_loc_conf_t               *cf;', 1]
['struct nchan_longpoll_multimsg_s {', 1]
['ngx_int_t                       max_channel_id_length;', 1]
['if(n <= NCHAN_FIXED_MULTITAG_MAX) tags = msg_id->tag.fixed;', 1]
['proc->wbuf.first = i;', 1]
['const  ngx_str_t NCHAN_HEADER_EVENTSOURCE_EVENT = ngx_string("X-EventSource-Event");', 1]
['ERR("%i messages still present in reaper at exit  (slot %i)", mpt->msg_reaper.count, ngx_process_slot);', 1]
['spooled_subscriber_t         *prev;', 1]
['struct sdshdr *sh = (void*) (s-sizeof *sh);', 1]
['time_t            time;', 1]
['x = sdsnewlen("foo",2);', 1]
['nchan_pub_subrequest_data_t  *d = data;', 1]
['ngx_http_set_ctx(r, ctx, nchan_module);', 1]
['However when working with very big payloads destroying the buffer may slow', 1]
['ngx_atomic_t                internal_sub_count;', 1]
['* However, setting expand_mult to a non-zero value delays bucket expansion', 1]
['cur->data = (void *) thing;', 1]
['typedef void (redisCallbackFn)(struct redisAsyncContext*, void*, void*);', 1]
['head->latest_msgid.tagcount = 1;', 1]
['task->type == REDIS_REPLY_STATUS ||', 1]
['fsub->publish_channel_id = nchan_get_channel_id(r, PUB, 0);', 1]
['ngx_del_timer(wev);', 1]
['nchan_reaper_stop(&mpt->nobuffer_msg_reaper);', 1]
['"Specified binary data length is too long (> 0xFFFFFFFF)",', 1]
['spool->first = NULL;', 1]
['const  ngx_str_t NCHAN_HEADER_IF_NONE_MATCH = ngx_string("If-None-Match");', 1]
['ngx_atomic_int_t                   old_max_workers;', 1]
['* Returns the result as an sds string. */', 1]
['#define CLOSE_INTERNAL_SERVER_ERROR  1011', 1]
['b = nchan_channel_info_buf(accept_header, messages, subscribers, last_seen, msgid, &content_type);', 1]
['* output buffer and register the provided callback. */', 1]
['The function `redisReaderCreate` creates a `redisReader` structure that holds a', 1]
['else if(d->msg == NULL && d->msg_status != MSG_EXPECTED) {', 1]
['int redisCheckSocketError(redisContext *c) {', 1]
['reply = redisCommand(c,"SET %s %s", "foo", "hello world");', 1]
['- gcc', 1]
['obj->type = CMP_TYPE_DOUBLE;', 1]
['int done = 0;', 1]
['if(ch->msg_last && ch->msg_last->msg->id.time == msg->msg->id.time) {', 1]
['bc[2].buf.pos = chunk_end;', 1]
['#define HASH_BLOOM_MAKE(tbl)                                                     \\', 1]
['h->value.data = header_value->data;', 1]
['nchan_thing_cache_t    *tc = (nchan_thing_cache_t *)ev->data;', 1]
['if (current == NULL) current = sdsempty();', 1]
['uint64_t payload_len;', 1]
['#now for the real tests', 1]
['bool cmp_object_is_int(cmp_object_t *obj) {', 1]
['my_procslot_index = i;', 1]
['INTEGER_WIDTH_TEST("hhd", char);', 1]
['rc = seed->compare(id, seed->id(rbtree_data_from_node(temp)));', 1]
['ngx_str_t               id_line = ngx_string("id: %V\\n");', 1]
['|F|R|R|R| opcode|M| Payload len |    Extended payload length    |', 1]
['} else if ((                                                   \\', 1]
['nchan_free_msg_id(&spool->id);', 1]
['////////// GET CHANNEL INFO ////////////////', 1]
['"  time= time,\\n"', 1]
['return cmp_write_str8(ctx, data, size);', 1]
['float f = (float)d;', 1]
['REDIS_DB=1', 1]
['if(shdata->max_workers != workers) {', 1]
['(((buf)->file!=NULL) ? (sizeof(*(buf)->file) + (buf)->file->name.len + 1) : 0))', 1]
['rc = nchan_output_filter(fsub->sub.request, first_link);', 1]
['buffer with unparsed data and state for the protocol parser.', 1]
['uint16_t  u16;', 1]
['INTEGER_WIDTH_TEST("u", unsigned int);', 1]
['"msg.prev=channel.current_message\\n"', 1]
['//switch to destination', 1]
['if ((ctx)->ev.addWrite) (ctx)->ev.addWrite((ctx)->ev.data); \\', 1]
['uint8_t multi_count = data->multi;', 1]
['/* Parse command line options. */', 1]
['ngx_memcpy(&channel_info_content_type, &NCHAN_CONTENT_TYPE_TEXT_PLAIN, sizeof(NCHAN_CONTENT_TYPE_TEXT_PLAIN));', 1]
["* MurmurHash uses the faster approach only on CPU's where we know it's safe.", 1]
['-- but then error messages become less useful, complicating debugging. If you', 1]
['channel.max_stored_messages =tonumber(channel.max_stored_messages)', 1]
['// static void __test_reply_callback(redisContext *c, redisReply *reply, void *privdata) {', 1]
['#define HASH_BKT_CAPACITY_THRESH 10      /* expand when bucket count reaches */', 1]
['static ngx_int_t websocket_set_dequeue_callback(subscriber_t *self, subscriber_callback_pt cb, void *privdata) {', 1]
['dictRelease(ac->sub.patterns);', 1]
['"  exists = true\\n"', 1]
["s[curlen+len] = '\\0';", 1]
['if ( _hs_tail ) {                                              \\', 1]
['DBG("wants to close");', 1]
['s = s / (1024 * 1024);', 1]
['static ngx_str_t            channel_id_var_name = ngx_string("push_channel_id");', 1]
['if (ngx_add_event(connection->write, NGX_WRITE_EVENT, NGX_CLEAR_EVENT) == NGX_ERROR) {', 1]
['static ngx_int_t nchan_memstore_chanhead_ready_to_reap_slowly(nchan_store_channel_head_t *ch, uint8_t force) {', 1]
['ngx_conf_merge_bitmask_value(conf->sub.websocket, prev->sub.websocket, 0);', 1]
['} ws_frame_t;', 1]
['const  ngx_str_t NCHAN_CACHE_CONTROL_VALUE = ngx_string("no-cache");', 1]
['assert(subdebug_head->dbg_prev == NULL);', 1]
['//worker processes of the world, unite.', 1]
['if (reply->type == REDIS_REPLY_INTEGER && reply->integer == 0) {', 1]
['static ngx_str_t * nchan_store_etag_from_message(nchan_msg_t *msg, ngx_pool_t *pool){', 1]
['msg->msg->prev_id = msg->prev->msg->id;', 1]
['* So we clean the reference to this fd on redisAsyncContext and on ngx_connection, avoiding close a socket in use.', 1]
['if (ngx_add_event(connection->read, NGX_READ_EVENT, NGX_CLEAR_EVENT) == NGX_ERROR) {', 1]
['#define MSG_REFCOUNT_INVALID -9000', 1]
['} internal_subscriber_t;', 1]
['//DBG("set next");', 1]
['subscribe_data_t           *d = (subscribe_data_t *)data;', 1]
['void                         *foreign_chanhead;', 1]
['u_char                    resp_buf[256];', 1]
['"local subscribers=\'channel:subscribers:\'..id\\n"', 1]
['DBG("IPC read channel");', 1]
['msg->content_type.data=cur;', 1]
['ERR("can\'t find chanhead for id %V", d->shm_chid);', 1]
['data->spools[data->n] = spool;', 1]
['daemonize yes', 1]
['/* Writes an unsigned integer to the backend */', 1]
['_EL_DEL_WRITE(ac);', 1]
['/* u_char    *pt=(u_char *)str-1;', 1]
['if((sub = websocket_subscriber_create(r, msg_id)) == NULL) {', 1]
['subscriber_t               *ipc_sub = NULL;', 1]
['if concurrency == "FIFO" then', 1]
['return (void *)(uintptr_t)fd;', 1]
['publish_msg->expires = ngx_time() + NCHAN_NOBUFFER_MSG_EXPIRE_SEC;', 1]
['static const subscriber_t new_longpoll_sub;', 1]
['* s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");', 1]
['test_reply_reader();', 1]
['nchan_store_redis.init_module(cycle);', 1]
['obj->type = CMP_TYPE_FIXEXT1;', 1]
['bool cmp_write_map16(cmp_ctx_t *ctx, uint16_t size) {', 1]
['//check if we need to ask for a message', 1]
['} redis_channel_callback_data_t;', 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_UNSUBSCRIBED, &data, sizeof(data));', 1]
['bool cmp_object_is_long(cmp_object_t *obj) {', 1]
['"get_message",', 1]
['if(id1->tagcount == 1) {', 1]
['uint32_t low_part = htonl((uint32_t)(value & 0xFFFFFFFFLL));', 1]
['* following programming-language REPL-alike form:', 1]
['#    :nchan_set_subscriber_concurrency,', 1]
['variables using environment variables or via arguments to the "make" tool.', 1]
['sz = group.len + 1 + tmpid.len;', 1]
['bc[2].chain.next = NULL;', 1]
['ac->onDisconnect = fn;', 1]
['static bool cmp_to_msg(cmp_ctx_t *cmp, nchan_msg_t *msg, ngx_buf_t *buf) {', 1]
['tbl->ideal_chain_maxlen =                                                    \\', 1]
['*dst_cv = cv;', 1]
['((void*)((char*)(_hs_p->next) +                   \\', 1]
['"      return {200, ttl, tonumber(ntime) or \\"\\", tonumber(ntag) or \\"\\", tonumber(prev_time) or \\"\\", tonumber(prev_tag) or \\"\\", ndata or \\"\\", ncontenttype or \\"\\", neventsource_event or \\"\\", subs_count}\\n"', 1]
['nchan_loc_conf_t              fake_conf;', 1]
['rchain->next = NULL;', 1]
['return Msg.new ch_id, time: msg_time, tag: msg_tag, data: msg_data, content_type: msg_content_type', 1]
['ngx_http_complex_value_t  *cv = cf->channel_events_channel_id;', 1]
['nchan_store_redis_fakesub_add(&head->id, -count);', 1]
['It is minimalistic because it just adds minimal support for the protocol, but', 1]
['assert( msg->prev_id.tagcount == 1 );', 1]
['[:loc_conf, :channel_event_string],', 1]
['nchan_publisher_post_request(r, content_type, content_length, request_chain, d->ch_id, cf);', 1]
['//verify_unique_response(&fsub->data.request->uri, &self->last_msgid, msg, self);', 1]
["else if (c == ',') {", 1]
['return cmp_write_fixext2(ctx, tp, data);', 1]
['ch->messages = r->element[3]->integer;', 1]
['t = sdscatvprintf(s,fmt,ap);', 1]
['ngx_int_t active_before = seed->active_nodes, allocd_before = seed->active_nodes;', 1]
["//don't gc it just yet.", 1]
['channel_spooler_t *start_spooler(channel_spooler_t *spl, ngx_str_t *chid, chanhead_pubsub_status_t *channel_status, nchan_store_t *store);', 1]
['"  if new_channel then\\n"', 1]
['if (source != NULL) {', 1]
['--set new message id', 1]
['ngx_int_t          (*compare)(void *, void *);', 1]
['return processMultiBulkItem(r);', 1]
['#define DEBUG_SHM_ALLOC 0', 1]
['f->timeout_handler = cb;', 1]
['if(ch->redis_sub) {', 1]
['if (obj.as.u64 <= 9223372036854775807) {', 1]
['} channel_info_data_t;', 1]
['} nchan_conf_subscriber_types_t;', 1]
['//add_fakesub', 1]
['ngx_int_t              (*respond_status)(struct subscriber_s *, ngx_int_t, const ngx_str_t *);', 1]
['total_sz += debug_sz;', 1]
['priority = cur+sizeof("text/")-1;', 1]
['if(head->owner == head->slot && !head->in_churn_queue) {', 1]
['argv[2] = "bar";', 1]
['/* Internal helper function to detect socket status the first time a read or', 1]
['test("Don\'t do empty allocation for empty multi bulk: ");', 1]
['static ngx_int_t spool_add_subscriber(subscriber_pool_t *self, subscriber_t *sub, uint8_t enqueue) {', 1]
['*u = obj.as.u32;', 1]
['ngx_uint_t                  numsubs[SUBSCRIBER_TYPES];', 1]
[':nchan_subscriber_last_message_id,', 1]
['and/or other materials provided with the distribution.', 1]
['DBG("Chanhead churn withdraw %p %V", ch, &ch->id);', 1]
['if (obj.type != CMP_TYPE_EXT16) {', 1]
['sub_create = http_multipart_subscriber_create;', 1]
['bool cmp_write_ext(cmp_ctx_t *ctx, int8_t type, uint32_t size,', 1]
['path="#{File.dirname(__FILE__)}/redis_lua_commands.h"', 1]
['return etag;', 1]
['chanhead_pubsub_status_t        status;', 1]
['static ngx_int_t spool_respond_general(subscriber_pool_t *self, nchan_msg_t *msg, ngx_int_t status_code, const ngx_str_t *status_line) {', 1]
['(head)->hh.tbl->num_items++;                                                    \\', 1]
['static bool write_type_marker(cmp_ctx_t *ctx, uint8_t marker) {', 1]
['else if(cf->sub.http_multipart && nchan_detect_multipart_subscriber_request(r)) {', 1]
['len_net = htons(len);', 1]
['uint8_t   i;', 1]
['[:main_conf, :redis_url],', 1]
['if(cur == msg->rsv) {', 1]
['case NGX_HTTP_NOT_MODIFIED: //timeout?', 1]
['ngx_delete_file(chain->buf->file->name.data);', 1]
['DBG("fetchmsg callback for spool %p msg FOUND %p %V", spool, msg, msgid_to_str(&msg->id));', 1]
['Because the connection that will be created is non-blocking, the kernel is not able to', 1]
['ngx_int_t                       use_redis;', 1]
['nchan_channel_t                ch;', 1]
['ngx_chain_t * nchan_create_output_chain(ngx_buf_t *buf, ngx_pool_t *pool, ngx_log_t *log) {', 1]
['if(mbuf->file!=NULL) {', 1]
['assert(spool->first == NULL);', 1]
['sh = malloc(sizeof *sh+initlen+1);', 1]
['An asynchronous connection can be terminated using:', 1]
['ngx_free(dst->tag.allocd);', 1]
['cur = msg_buf->start;', 1]
['id->tag.allocd = NULL;', 1]
['_hj_k = (unsigned)(keylen);                                                      \\', 1]
['* Note: it is possible to use a negative increment in order to', 1]
['DYLIB_MINOR_NAME=$(LIBNAME).$(DYLIBSUFFIX).$(HIREDIS_MAJOR).$(HIREDIS_MINOR)', 1]
['{ ngx_string("nchan_authorize_request"),', 1]
['e->loop = NULL;', 1]
['ngx_buf_t                 *rbuffer;', 1]
['static nchan_msg_t * msg_from_redis_get_message_reply(redisReply *r, uint16_t offset, void *(*allocator)(size_t size)) {', 1]
['DBG("%p release for req %p. reservations: %i", self, fsub->sub.request, self->reserved);', 1]
['if (ctx->read(ctx, data, 2))', 1]
['if (!cmp_read_fixext16_marker(ctx, type))', 1]
['DBG("tried publishing status %i to chanhead %p (subs: %i)", status_code, head, head->sub_count);', 1]
['if(!tc->destroy(&((thing_t *)cur->data)->id, ((thing_t *)cur->data)->data)) {', 1]
["//don't care if this is 'inefficient', it only happens once per worker per load", 1]
['fsub->upstream_stuff = NULL;', 1]
['if(err) *err = "can\'t set msgid headers";', 1]
['d->n = -1;', 1]
['ngx_int_t nchan_respond_membuf(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *content_type, ngx_buf_t *body, ngx_int_t finalize) {', 1]
['ERR("nchan: thought there\'d be a channel id around for msgkey");', 1]
['for (i = 0; i < 9; i++) {', 1]
['for i = 1, #ch do', 1]
['assert(pool);', 1]
['r = sr->parent;', 1]
["redis.call('del', v)", 1]
['* After this function is called, you may use redisContextReadReply to', 1]
['data.channel_info = NULL;', 1]
['for(cur = shdata->msgdebug_head; cur != NULL; cur = cur->dbg_next) {', 1]
['def test_publish_invalid_content_type', 1]
['channel={}', 1]
['if(buf->mmap) { //just the mmap, please', 1]
['bool cmp_object_as_int(cmp_object_t *obj, int32_t *i);', 1]
['ctx->multipart_boundary->len = 32;', 1]
['sds *newtokens;', 1]
['buf.last_buf = 1;', 1]
['* input string is empty, or NULL if the input contains unbalanced', 1]
['* oldlen = sdslen(s);', 1]
['nchan_websocket_publisher_llist_init();', 1]
['if (fcntl(c->fd, F_SETFL, flags) == -1) {', 1]
['if(my_procslot_index == NCHAN_INVALID_SLOT) {', 1]
['/* Low level functions exposed to the user API */', 1]
['ngx_memcpy(file, buf->file, sizeof(*file));', 1]
['if (u <= 0xFFFFFFFF)', 1]
['DBG("already unsubscribed...");', 1]
['-- This script has gotten big and ugly, but there are a few good reasons', 1]
['return iter;', 1]
['EXT8_MARKER            = 0xC7,', 1]
['*context = ac;', 1]
['key.message=key.message:format(msg_id, id)', 1]
['freeaddrinfo(servinfo);', 1]
['void ngx_rwlock_release_read(ngx_rwlock_t *lock);', 1]
['"--check old entries\\n"', 1]
['void sdstolower(sds s);', 1]
['len = accept_header->len;', 1]
['if (content_type->data != NULL) {', 1]
['ngx_int_t                   rc = NGX_OK;', 1]
['ac->ev.addRead = redis_nginx_add_read;', 1]
['ngx_rbtree_node_t              *sentinel = seed->tree.sentinel;', 1]
['REDIS_PORT=56379', 1]
['return sdscatlen(s,"\\"",1);', 1]
["//see if there's a qvalue", 1]
['if not exists then', 1]
['ERR("makes no sense...");', 1]
['static void test_free_null(void) {', 1]
['static ngx_int_t nchan_store_subscribe_continued(ngx_int_t channel_status, void* _, subscribe_data_t *d) {', 1]
['multi[i].id = ids[i];', 1]
['ac->replies.tail = NULL;', 1]
['////////// PUBLISH  ////////////////', 1]
["/* Split 's' with separator in 'sep'. An array", 1]
['static ngx_int_t internal_reserve(subscriber_t *self) {', 1]
['return cmp_write_nfix(ctx, c);', 1]
['#ifndef uthash_noexpand_fyi', 1]
['self.to_s==m.to_s', 1]
['chid->n = cf->args->nelts - 1;', 1]
['(ht)->type->keyCompare((ht)->privdata, key1, key2) : \\', 1]
['The standard replies that `redisCommand` are of the type `redisReply`. The', 1]
['link->data = (void *)slot;', 1]
['static       ngx_str_t   sub_name = ngx_string("http-multipart");', 1]
['|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |', 1]
['int redisAsyncCommand(', 1]
['nchan_store_memory.delete_channel(d->chid, NULL, NULL);', 1]
["* Issue #43: Don't crash in an asynchronous context when Redis returns an error", 1]
['static ngx_int_t spool_transfer_subscribers(subscriber_pool_t *spool, subscriber_pool_t *newspool, uint8_t update_subscriber_last_msgid) {', 1]
['} else if (nread == 0) {', 1]
['if(cf->sub.websocket) {', 1]
['r->maxbuf = REDIS_READER_MAX_BUF;', 1]
['local check_concurrency_in = function(i, id)', 1]
['-- to keep it big and ugly. It needs to do a lot of stuff atomically, and', 1]
['$(CC) -o $@ $(REAL_LDFLAGS) $< $(STLIBNAME)', 1]
['lcf->sub.eventsource=0;', 1]
['ERR("can\'t create unbuffered message for channel %V", &chead->id);', 1]
['ngx_memzero(&double_newline_buf, sizeof(double_newline_buf));', 1]
['## Synchronous API', 1]
['if (!write_type_marker(ctx, FIXEXT4_MARKER))', 1]
['ht->sizemask = 0;', 1]
['#define HASH_SELECT(hh_dst, dst, hh_src, src, cond)                              \\', 1]
['spl->current_msg_spool.msg_status = MSG_EXPECTED;', 1]
['ch = (nchan_store_channel_head_t *)cur->data;', 1]
['nchan_channel_t                chaninfo_copy;', 1]
['{ ngx_string("nchan_subscriber_timeout"),', 1]
['if next(channel) == nil then', 1]
['else if (type_marker <= 0x9F) {', 1]
['ngx_str_t                    id; //channel id', 1]
['spooler_set_dequeue_handler,', 1]
['for(cur = rlch->msgs; cur != NULL; cur = cur->reload_next) {', 1]
['/* Shift callback for invalid commands. */', 1]
['ngx_memcpy(&fsub->sub, &new_internal_sub, sizeof(new_internal_sub));', 1]
['OBJ=net.o hiredis.o sds.o async.o', 1]
['ngx_int_t memstore_ipc_send_unsubscribe(ngx_int_t dst, ngx_str_t *chid, void *subscriber, void* privdata);', 1]
['ipc_alert(nchan_memstore_get_ipc(), dst, IPC_SUBSCRIBER_KEEPALIVE, &data, sizeof(data));', 1]
['nchan_subscribe_existing_channels_only [:main, :srv, :loc],', 1]
['ch->sub_count += n;', 1]
['if ((flags = fcntl(c->fd, F_GETFL)) == -1) {', 1]
['#define _XOPEN_SOURCE', 1]
['if(head->owner == memstore_slot()) {', 1]
['//DBG("messages gc for ch %p %V", ch, &ch->id);', 1]
['bool cmp_write_u32(cmp_ctx_t *ctx, uint32_t i) {', 1]
['switch(c) {', 1]
['* afterward, more than half the items in the hash had nonideal chain', 1]
['ngx_int_t             n=0;', 1]
['//this coould be dangerous!!', 1]
['obj->as.u16 = be16(obj->as.u16);', 1]
['int16_t   *tags1, *tags2;', 1]
['return ONE_FAKE_CHANNEL_OWNER;', 1]
['ngx_memcpy(dst->tag.allocd, src->tag.allocd, sizeof(*src->tag.allocd) * src_n);', 1]
['HASH_OOPS("invalid bucket count %d, actual %d\\n",                 \\', 1]
['recycloc_llist_s *prealloc_start;', 1]
['much higher level than otherwise suggested by its minimal code base and the', 1]
['WEBSOCKET_STRINGS_N + EVENTSOURCE_STRINGS_N + HTTP_CHUNKED_STRINGS_N + HTTP_MULTIPART_STRINGS_N + LONGPOLL_STRINGS_N + INTERVALPOLL_STRINGS_N + DISABLED_STRINGS_N,', 1]
['if (blocking)', 1]
["p = strchr(p,'\\r');", 1]
['return (void *)tc;', 1]
['buf->end = ngx_snprintf(buf->start, content_type->len + 25, "\\r\\nContent-Type: %V\\r\\n\\r\\n", content_type);', 1]
['prv = &(r->rstack[r->ridx-1]);', 1]
['//last-modified', 1]
['offsetof(nchan_store_channel_head_t, churn_prev),', 1]
['while (1) {', 1]
['d->sub = NULL;', 1]
['entry->key = (_key_); \\', 1]
['d->callback(MSG_EXPECTED, NULL, d->privdata);', 1]
['if((multi = ngx_alloc(sizeof(*multi) * n, ngx_cycle->log)) == NULL) {', 1]
['bool cmp_object_is_array(cmp_object_t *obj) {', 1]
['obj->as.dbl = bedouble(obj->as.dbl);', 1]
['ngx_str_t                   name;', 1]
['ngx_int_t (*init_module)(ngx_cycle_t *cycle);', 1]
["local max_stored_msgs = tonumber(redis.call('HGET', key.channel, 'max_stored_messages')) or -1", 1]
['free(r->str);', 1]
["//for debugging, mostly. I don't expect this branch to behit during regular operation", 1]
['rdt.sub_ctx = c;', 1]
['buf->in_file=0;', 1]
['ac->ev.addRead = NULL;', 1]
['sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {', 1]
['if((cur = ngx_alloc(sizeof(*cur), ngx_cycle->log)) == NULL) {', 1]
['/* Continue searching. */', 1]
['hashv = 0xcafebabe;                                                            \\', 1]
['c = redisConnectWithTimeout(hostname, port, timeout);', 1]
['hashv    += get16bits (_sfh_key);                                            \\', 1]
['nchan_msg_t                *msg;', 1]
['void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {', 1]
['"  if not exists then\\n"', 1]
['//store_message_t             *chmsg;', 1]
['legacy: "push_max_channel_id_length",', 1]
['DEBUG?= -g -ggdb', 1]
['urnode->smallmsg.data = urnode->id.data + id.len;', 1]
['r->headers_out.last_modified_time = msgid->time;', 1]
['ngx_str_t                       lbl;', 1]
["case '3': return 3;", 1]
['char buf[64];', 1]
['ipc_sub = memstore_ipc_subscriber_create(sender, &head->id, head->use_redis, d->d.origin_chanhead);', 1]
['ngx_memcpy(&bc[2].buf, msg_buf, sizeof(*msg_buf));', 1]
['} thing_t;', 1]
['msg_id=("%s:%s"):format(time, tag)', 1]
['elseif ttl < 0 then', 1]
['#ifdef __GNUC__', 1]
['assert(ssub->prev != ssub);', 1]
['ngx_str_t                      *content_type;', 1]
['default: 10,', 1]
['"redis.call(\'DEL\', key_channel, messages, subscribers)\\n"', 1]
['lcf->sub.http_chunked=0;', 1]
['head->channel.last_seen = ngx_time();', 1]
['sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {', 1]
['if (r->reply != NULL && r->fn && r->fn->freeObject)', 1]
['ngx_str_t           ws_accept_key, sha1_str;', 1]
['ERR("nchan: unexpected \\"delete channel\\" msgpack message from redis");', 1]
['int                        prev_ptr_offset;', 1]
['close_code = CLOSE_GOING_AWAY;', 1]
['return &((uniq_response_t *)data)->id;', 1]
['ws_version=ngx_atoi(tmp->data, tmp->len);', 1]
['#endif /*NCHAN_RBTREE_UTIL_HEADER*/', 1]
['//the owner is responsible for the chanhead and its interprocess siblings', 1]
['subscribe_data_t   data;', 1]
['DBG("can\'t pop empty fakeprocess stack");', 1]
['head->gc_queued_times = 0;', 1]
['#define REDIS_ERR_EOF 3 /* End of file */', 1]
['* (that would be triggered by additions to this particular bucket)', 1]
['ngx_init_set_membuf(&bc->buf, cur, ngx_snprintf(cur, sz, (char *)fmt->data, str));', 1]
['case 8:  _hj_j += ( (unsigned)_hj_key[7] << 24 );                           \\', 1]
['else if (type_marker == S64_MARKER) {', 1]
['ngx_http_finalize_request(r, c->error ? NGX_HTTP_CLIENT_CLOSED_REQUEST : NGX_OK);', 1]
['aeMain(loop);', 1]
['pos += sprintf(cmd+pos,"$%zu\\r\\n",sdslen(curargv[j]));', 1]
['if (val->lengths == NULL) {', 1]
['int16_t  *tags1 = id1->tagcount <= NCHAN_FIXED_MULTITAG_MAX ? id1->tag.fixed : id1->tag.allocd;', 1]
['finalize:', 1]
['* get a reply before pub/sub messages arrive. */', 1]
['c->reader = redisReaderCreate();', 1]
["nearly_departed = redis.call('hmget', key_channel, 'ttl', 'time_last_seen', 'subscribers')", 1]
['#define CLOSE_EXTENSION_MISSING      1010', 1]
['TYPE_MARKER_WRITING_ERROR,', 1]
['#include <sys/select.h>', 1]
['if(rdt.chanhead_cleanup_head==cl)', 1]
['fsub->holding = 0;', 1]
['ngx_conf_merge_sec_value(conf->websocket_ping_interval, prev->websocket_ping_interval, NCHAN_DEFAULT_WEBSOCKET_PING_INTERVAL);', 1]
['/* It already exists, get the entry */', 1]
['if (cmp == 0) return l1-l2;', 1]
['ngx_int_t nchan_detect_multipart_subscriber_request(ngx_http_request_t *r);', 1]
['rc = ngx_http_read_client_request_body(r, nchan_publisher_body_handler);', 1]
['if (chain->next == NULL) {', 1]
['} subscriber_data_t;', 1]
['else if (type_marker == DOUBLE_MARKER) {', 1]
['/*.dylib', 1]
['case 9:  hashv += ( (unsigned)_hj_key[8] << 8 );                            \\', 1]
['chain = chain->next;', 1]
['*d = obj->as.u8;', 1]
['nchan_store_channel_head_t *nchan_memstore_get_chanhead(ngx_str_t *channel_id, nchan_loc_conf_t *cf);', 1]
['if (privdata) {', 1]
['redis_nginx_init();', 1]
['nchan_reaper_t      *rp = ev->data;', 1]
['prevde->next = de->next;', 1]
['nchan_store_channel_head_t *cur, *tmp;', 1]
['(head)->hh.tbl->hho))->prev =                                \\', 1]
['size_t  len;', 1]
['if (c == NULL) {', 1]
['} nchan_content_subtype_t;', 1]
['assert(inserted);', 1]
['static subscriber_pool_t *get_spool(channel_spooler_t *spl, nchan_msg_id_t *id) {', 1]
['lcf->subscribe_only_existing_channel=NGX_CONF_UNSET;', 1]
['if (d >= (-2147483647 - 1))', 1]
['self->sub_count++;', 1]
['test_cond("Create a string with specified length",', 1]
['ngx_int_t              count = ch->channel.messages;', 1]
['msub = head->multi[i].sub;', 1]
['cur = copy_preallocated_str_to_cur(&msg->eventsource_event, &m->eventsource_event, cur);', 1]
['{ ngx_string("nchan_subscriber_last_message_id"),', 1]
['char _port[6];  /* strlen("65535"); */', 1]
['c = redisConnectUnix(config.unix.path);', 1]
['ch->redis_sub->fn->dequeue(ch->redis_sub);', 1]
['"-- no_msgid_order: \'FILO\' for oldest message, \'FIFO\' for most recent\\n"', 1]
['/* Use this function to handle a read event on the descriptor. It will try', 1]
['TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A', 1]
['static int dictExpand(dict *ht, unsigned long size) {', 1]
['switch(direction) {', 1]
['hiredis-example: examples/example.c $(STLIBNAME)', 1]
['ERR("tried adding WAITING chanhead %p %V to chanhead_gc. why?", ch, &ch->id);', 1]
['"Error reading ext type",', 1]
['oldtags[i] = newtags[i];', 1]
['redisContext *redisConnectBindNonBlock(const char *ip, int port, const char *source_addr);', 1]
['if (s == NULL) return;', 1]
['oldtags = oldid->tag.fixed;', 1]
['if (totlen < len) {', 1]
['el; (el)=(tmp),(*(char**)(&(tmp)))=(char*)((tmp)?(tmp)->hh.next:NULL))', 1]
['if(!cmp_read_uinteger(cmp, (uint64_t *)&msg->prev_id.time)) {', 1]
['if(sdata->generation == sdata->chanhead->generation) {', 1]
['subscriber_t *websocket_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id) {', 1]
['//     redisCommandWithCallback(c,__test_reply_callback,(void*)3,"PING");', 1]
['static ngx_int_t is_multi_id(ngx_str_t *id) {', 1]
['uint64_t len;', 1]
['static ngx_int_t multipart_respond_status(subscriber_t *sub, ngx_int_t status_code, const ngx_str_t *status_line){', 1]
['if(ch->owner == ch->slot) {', 1]
['static ngx_int_t log_redis_reply(char *name, ngx_msec_t t) {', 1]
['d->sub->fn->dequeue(d->sub);', 1]
['//what should the buffers look like?', 1]
['if(*fd != NGX_INVALID_FILE) {', 1]
['if not next(msg) then --empty', 1]
['spool_bubbleup_dequeue_handler(spool, sub, spool->spooler);', 1]
['ngx_str_t *shm_copy_immutable_string(shmem_t *shm, ngx_str_t *str_in) {', 1]
['if (ctx->error > ERROR_NONE && ctx->error < ERROR_MAX)', 1]
['//nchan_store_publish_generic(channel_id, msg, 0, NULL);', 1]
['chains[0].buf = cur == first ? &boundary[0] : &boundary[1];', 1]
['entry->key = (ht)->type->keyDup((ht)->privdata, _key_); \\', 1]
['* s = sdscatprintf(s,"%d+%d = %d",a,b,a+b).', 1]
['//nchan_msg_id_t             unprevid;', 1]
['publish_callback_data   *cd = (publish_callback_data *)privdata;', 1]
['DECLTYPE_ASSIGN(head,(delptr)->hh.next);                             \\', 1]
['} else {                                                             \\', 1]
['memcpy(r->errstr,str,len);', 1]
['recycloc_t *recycloc_init(const char *name, recycloc_t *ptr, size_t data_size, size_t prealloc_count) {', 1]
['ngx_int_t nchan_pubsub_handler(ngx_http_request_t *r);', 1]
['r->count--;', 1]
['unsigned                           use_redis:1;', 1]
['write(HASH_EMIT_KEYS, &_klen, sizeof(_klen));                                \\', 1]
['#define HASH_BLOOM_TEST(tbl,hashv)                                               \\', 1]
['buf = &stuff->buf;', 1]
['The parser limits the level of nesting for multi bulk payloads to 7. If the', 1]
['//content-type is already set by default', 1]
['bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size);', 1]
['return abort_response(&fsub->sub, err);', 1]
['if(seed->actives[i] == NULL) {', 1]
['ch->channel.messages--;', 1]
['test_cond(strncmp(cmd,"*3\\r\\n$3\\r\\nSET\\r\\n$1\\r\\n%\\r\\n$1\\r\\n%\\r\\n",len) == 0 &&', 1]
['if(mbuf->in_file && mbuf->file != NULL) {', 1]
['tag2 = i < max2 ? tags2[i] : -1;', 1]
['ngx_int_t nchan_store_redis_fakesub_add(ngx_str_t *channel_id, ngx_int_t count) {', 1]
['#define uthash_noexpand_fyi(tbl)          /* can be defined to log noexpand  */', 1]
['case SUB_ENQUEUE:', 1]
['redisAsyncContext *ctx;', 1]
['subscriber_t *eventsource_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id);', 1]
['channel_spooler_t *create_spooler() {', 1]
['ngx_http_complex_value_t       *channel_events_channel_id;', 1]
['nchan_update_multi_msgid(&new_id, new_last_id);', 1]
['d->chid = &chanhead->id;', 1]
['int sdscmp(const sds s1, const sds s2) {', 1]
['x = sdscatprintf(sdsempty(),"%d",123);', 1]
['event_add(&e->rev,NULL);', 1]
['context->reader->maxbuf = 0;', 1]
['ngx_int_t nchan_msg_buf_open_fd_if_needed(ngx_buf_t *buf, ngx_file_t *file, ngx_http_request_t *r) {', 1]
['return nchan_publisher_directive_parse(cf, cmd, conf, 1);', 1]
['if(self->add_handler != NULL) {', 1]
['if (obj.as.u8 <= 127) {', 1]
['static ngx_str_t         POST_REQUEST_STRING = {4, (u_char *)"POST "};', 1]
['{ ngx_string("nchan_publisher"),', 1]
['/* Size: long long */', 1]
['ngx_int_t                               rc;', 1]
['code=CLOSE_NORMAL;', 1]
['va_end(args);', 1]
['if(fname == NULL) {', 1]
['DBG("hodl request %p", fsub->sub.request);', 1]
['DBG("%p (%V) memstore subscriber dequeue: notify owner", d->sub, d->chid);', 1]
['/* On 2.0, QUIT will cause the connection to be closed immediately and', 1]
['INVALID_TYPE_ERROR,', 1]
['_dictInit(&n, ht->type, ht->privdata);', 1]
['ngx_log_error(NGX_LOG_INFO, c->log, ngx_socket_errno, "push stream module: failed to restore read events");', 1]
['nchan_channel_t             *channel_copy = &channel_copy_data;', 1]
['// finds and return the info hash of a channel, or nil of channel not found', 1]
['/* m/e with multi bulk reply *before* other reply.', 1]
['//DBG("cur: (chid: %V)  %V %V", &ch->id, msgid_to_str(&cur->msg->id), chanhead_msg_to_str(cur));', 1]
['static aeEventLoop *loop;', 1]
['if ((rv = getaddrinfo(source_addr, NULL, &hints, &bservinfo)) != 0) {', 1]
['HASH_OOPS("invalid hh item count %d, actual %d\\n",                   \\', 1]
['/* Enable connection KeepAlive. */', 1]
['snprintf(sbuf,sizeof(sbuf),', 1]
['spool->pool = NULL;', 1]
['*format = subtypes[i].format;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "munmap was a problem");', 1]
['The function `redisGetReply` is exported as part of the Hiredis API and can be used when a reply', 1]
['memcpy(target,cb,sizeof(*cb));', 1]
['void             *data;', 1]
['int                  n = 0;', 1]
['bool cmp_object_is_char(cmp_object_t *obj);', 1]
['DBG("spool %p (%V) (subs: %i) respond with msg %p or code %i", self, msgid_to_str(&self->id), self->sub_count, msg, status_code);', 1]
['case RBTREE_WALK_RIGHT:', 1]
['return ngx_process_slot;', 1]
['/* Issue a command to Redis. In a blocking context, it is identical to calling', 1]
['ngx_int_t           ret;', 1]
['_dst_hh->hashv = _src_hh->hashv;                                     \\', 1]
['} redisReadTask;', 1]
['int argc, const char **argv, const size_t *argvlen);', 1]
['d->foreign_chanhead = foreign_chanhead;', 1]
['DBG("ensure chanhead ready: subscribe request for %V from %i to %i", &head->id, memstore_slot(), owner);', 1]
['#ifndef MEMSTORE_PRIVATE_HEADER', 1]
['reply = redisCommand(c,"SET %b %b", "bar", (size_t) 3, "hello", (size_t) 5);', 1]
['void *_last_elt=NULL, *_elt;                                                   \\', 1]
['printf("SET (binary API): %s\\n", reply->str);', 1]
['oldfree = sh->free;', 1]
['struct spool_collect_overflow_s {', 1]
['subscriber_t sub;', 1]
['* is sure that after calling this function can overwrite up to addlen', 1]
['* requires length arguments. sdssplit() is just the', 1]
['if(cl->prev!=NULL)', 1]
['buf = &blob->buf;', 1]
['void *shm_calloc(shmem_t *shm, size_t size, const char *label) {', 1]
['#ifndef NCHAN_DEFS_H', 1]
['MUR_ONE_THREE(p))))', 1]
['ac->ev.addWrite = redisLibevAddWrite;', 1]
['ch->spooler.fn->add(&ch->spooler, d->sub);', 1]
['extern const ngx_str_t NCHAN_ALLOW_GET_OPTIONS;', 1]
['ngx_socket_t                   *socks;', 1]
['ngx_str_t *nchan_get_channel_id(ngx_http_request_t *r, pub_or_sub_t what, ngx_int_t fail_hard) {', 1]
['nchan_store_channel_head_t   *multi_chanhead;', 1]
['if (rc != NGX_OK) {', 1]
['len = snprintf(buf,size,"\\"\\\\x%02x\\"",(unsigned char)byte);', 1]
['return ctx->write(ctx, &i, sizeof(int32_t));', 1]
['shm_destroy(shm); //just for this worker...', 1]
['long long v = 0;', 1]
['/* Defined in hiredis.c */', 1]
['*d = obj->as.s32;', 1]
['bool cmp_write_fixext2(cmp_ctx_t *ctx, int8_t type, const void *data) {', 1]
['fsub->data.timeout_handler_data = privdata;', 1]
['unsigned                act_as_intervalpoll:1;', 1]
['void sdsfree(sds s) {', 1]
['ngx_chain_t            *first_link = NULL, *last_link = NULL;', 1]
['uint16_t                  n;', 1]
['return sdscatlen(s, t, sdslen(t));', 1]
['frame->payload_len = ws_ntohll(len);', 1]
['if((chan_info = shm_alloc(nchan_memstore_get_shm(), sizeof(*chan_info), "channel info for delete IPC response")) == NULL) {', 1]
['ngx_int_t                channel_exists;', 1]
['obj->type = CMP_TYPE_BIN8;', 1]
['c->write->handler = ipc_write_handler;', 1]
['rbtree_walk_real(seed, seed->tree.root, seed->tree.sentinel, callback, data);', 1]
['} while (aux == NULL);', 1]
['if(ch->msg_last != msg) { //why does this happen?', 1]
['local code=tonumber(ARGV[2])', 1]
['bool cmp_read_bool_as_u8(cmp_ctx_t *ctx, uint8_t *b);', 1]
['m << Msg.new(id, data: msg2_data, ttl: 100, content_type: "X-fruit/banana")', 1]
['* 3) The free buffer at the end if any.', 1]
['"dbg(\' ####### DELETE #######\')\\n"', 1]
['DBG("%p created with privdata %p", d->multi->sub, d);', 1]
['To explain how Hiredis supports pipelining in a blocking connection, there needs to be', 1]
['msg = chanhead_find_next_message(head, &d->d.req.msgid, &status);', 1]
['redisProcessCallbacks(ac);', 1]
['} uniq_response_t;', 1]
['subscriber_t *websocket_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id);', 1]
['longpoll_multimsg_respond(fsub);', 1]
['if(!cmp_read_int(cmp, &ttl)) {', 1]
['dst->time = src->time;', 1]
['"if store_at_most_n_messages == nil or store_at_most_n_messages == \\"\\" then\\n"', 1]
['while(cur != NULL && cur != firstmoved && notready <= max_notready) {', 1]
['return cmp_write_ext32_marker(ctx, tp, sz);', 1]
['ERR("can\'t allocate publish multi chanhead data");', 1]
['//     test("Calls disconnect callback on redisDisconnect: ");', 1]
['* In this case we also want to close the connection, and have the', 1]
['hdr_buf->end = hdr_buf->last;', 1]
['change_sub_count(d->target_chanhead, (ngx_int_t )data);', 1]
['for(i=1; i < cf->args->nelts && i <= NCHAN_COMPLEX_VALUE_ARRAY_MAX; i++) {', 1]
['dbg("channel ", id, " ttl: ",channel.ttl, ", subscribers: ", channel.subscribers, "(fake: ", channel.fake_subscribers or "nil", "), messages: ", num_messages)', 1]
['offsetof(nchan_loc_conf_t, msg_in_etag_only),', 1]
['#define REDIS_IN_CALLBACK 0x10', 1]
['if(cv==NULL) {', 1]
['ngx_str_t           *channel_id;', 1]
['char                   *name;', 1]
['lock->mutex=0;', 1]
['"  return ch\\n"', 1]
["/* when the reply already contains multiple items, they must be free'd", 1]
['* when there are no pending callbacks. */', 1]
['EXT32_MARKER           = 0xC9,', 1]
['ngx_int_t         write_pid;', 1]
['publisher_upstream_request_url_ccv = cf->publisher_upstream_request_url;', 1]
['{ ngx_string("nchan_subscriber_channel_id"),', 1]
['} channel_spooler_fn_t;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not create the redis context for %s:%d - %s", host, port, ac->errstr);', 1]
['if(!cf->longpoll_multimsg) {', 1]
['if (_dictExpandIfNeeded(ht) == DICT_ERR)', 1]
['d->name = "get_message";', 1]
["return redis.call('HGET', chan_key, 'subscribers') or 0", 1]
['cur->next = NULL;', 1]
['dst->data = cur;', 1]
['end = len+end;', 1]
['assert(msg->shared == 0);', 1]
['else if (type_marker == ARRAY16_MARKER) {', 1]
['if (obj->type == CMP_TYPE_DOUBLE)', 1]
['ngx_memcpy(etag->data, tmp_etag->data, tmp_etag->len);', 1]
['uint32_t low_part = ntohl((uint32_t)(value & 0xFFFFFFFFLL));', 1]
['hints.ai_family = AF_INET6;', 1]
['ngx_memzero(&fsub->msg_buf, sizeof(fsub->msg_buf));', 1]
['buf->file_last=0;', 1]
['//     test_cond(__test_callback_flags == 2);', 1]
['ngx_conf_merge_str_value(conf->channel_group, prev->channel_group, "");', 1]
['int reallen = strlen(s);', 1]
['if(spool->generation == 0) {', 1]
['} UT_hash_handle;', 1]
['( kill `cat /tmp/hiredis-test-redis.pid` && false )', 1]
['lcf->authorize_request_url = NULL;', 1]
['int16_t  *tags2 = id2->tagcount <= NCHAN_FIXED_MULTITAG_MAX ? id2->tag.fixed : id2->tag.allocd;', 1]
['static void receive_flood_test(ngx_int_t sender, flood_data_t *d) {', 1]
['static ngx_inline void **thing_prev_ptr(nchan_reaper_t *rp, void *thing) {', 1]
["* s[2] = '\\0';", 1]
['sds sdsjoin(char **argv, int argc, char *sep, size_t seplen);', 1]
['freeReplyObject(redisCommand(c,"LPUSH mylist bar"));', 1]
['ngx_str_t *out;', 1]
['//spl->prev_msg_id.tag=0;', 1]
['int                            channel_id_count;', 1]
['ngx_uint_t                   sub_count;', 1]
['and [libevent](http://monkey.org/~provos/libevent/).', 1]
['static const subscriber_t new_internal_sub = {', 1]
['nchan_llist_timed_t  ll;', 1]
['chains = ngx_palloc(r->pool, sizeof(*chains)*4);', 1]
['DBG("not yet time to reap %V, %i sec left", &ch->id, ch->gc_time - ngx_time());', 1]
["* substring specified by the 'start' and 'end' indexes.", 1]
["sub_id =tonumber(redis.call('INCR', keys.subscriber_id))", 1]
['--check old entries', 1]
['"  channel=      \'channel:\'..id,\\n"', 1]
['switch(byte) {', 1]
['u_char                          cbuf[100];', 1]
['if(i==0) {', 1]
["/* we do not inherit the parent request's variables */", 1]
['FLOAT_WIDTH_TEST(double);', 1]
['if(ch->use_redis) {', 1]
['if (current) sdsfree(current);', 1]
['if(rp->last == NULL) {', 1]
['ngx_pool_t                 *pool;', 1]
['static void redisInitScripts(redisAsyncContext *c){', 1]
['mid_tag = msgid->tag.fixed[0];', 1]
['static void its_reaping_rotating_time(nchan_reaper_t *rp, uint8_t force) {', 1]
["req_msgid[i].tag.fixed[0] = 32767; //eeeeeh this is bad. but it's good enough.", 1]
['static ngx_str_t  sub_name = ngx_string("memstore-ipc");', 1]
['printf("*** %d TESTS FAILED ***\\n", fails);', 1]
['spool_add_subscriber(newspool, sub, 0);', 1]
['if(ngx_memcmp(lbl, cur->lbl, sz) == 0) {', 1]
['&& CHECK_REPLY_INT(r->element[0])', 1]
['f->timeout_handler_data = privdata;', 1]
['(size_t)((((head)->hh.tbl->num_items   * sizeof(UT_hash_handle))   +            \\', 1]
['"subscribers: %ui" CRLF', 1]
['ngx_int_t            (*prepare_to_stop)(channel_spooler_t *self);', 1]
['return processLineItem(r);', 1]
['if (head.count >= ((head.expand_mult+1) * HASH_BKT_CAPACITY_THRESH)             \\', 1]
['(ngx_int_t (*)(void *, uint8_t)) nchan_memstore_chanhead_ready_to_reap_slowly,', 1]
['ERR("REDIS: PUB/SUB already subscribed to %s, chanhead %p (id %V) already READY.", reply->element[1]->str, chanhead, &chanhead->id);', 1]
['assert(c->err == REDIS_ERR_EOF &&', 1]
['r->rstack[r->ridx].elements = -1;', 1]
['u_char                    *cur;', 1]
['redisLibevDelRead(privdata);', 1]
['0                   1                   2                   3', 1]
['cur += group->len;', 1]
['* Try to parse a single reply from the input buffer and return it', 1]
['else if (len < (1 << 16)) {', 1]
['uint32_t           (*hash)(void *);', 1]
['set_buffer(&buf, frame->payload, frame->last, frame->payload_len);', 1]
['static void request_cleanup_handler(subscriber_t *sub) {', 1]
['//stupid overcomplicated websockets and their masks', 1]
['if(!rdt.cleanup_timer.timer_set) {', 1]
['ngx_int_t memstore_ipc_send_get_message(ngx_int_t dst, ngx_str_t *chid, nchan_msg_id_t *msgid, void *privdata) {', 1]
['//  return NGX_OK;', 1]
['/* Connection callback prototypes */', 1]
['HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                          \\', 1]
['s = sdscatprintf(s,"\\\\%c",*p);', 1]
['nchan_complex_value_arr_t       last_message_id;', 1]
['"Invalid type",', 1]
['* The function returns the sds string pointer, that is always the same', 1]
['if(buf->memory) {', 1]
['rc = nchan_process_multi_channel_id(r, chid_conf, cf, &id);', 1]
['//     test("redisBufferWrite against not yet connected fd: ");', 1]
['static void *spool_rbtree_node_id(void *data) {', 1]
['hiredis-example-ae: examples/example-ae.c adapters/ae.h $(STLIBNAME)', 1]
['//ngx_chain_t   *msg_chain = fsub->msg_chain;', 1]
['r->headers_out.content_type.data = msg->content_type.data;', 1]
['//DBG("write aborted at %i iter. first: %i, n: %i", i - first, first, proc->wbuf.n);', 1]
['ngx_memcpy(&conf->pubsub_chid, &prev->pubsub_chid, sizeof(prev->pubsub_chid));', 1]
['static char *nchan_ignore_obsolete_setting(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['* The command replied with a status reply. The status string can be accessed using `reply->str`.', 1]
['"  <last_message_id>%V</last_message_id>" CRLF', 1]
['ngx_memzero(&lcf->pub_chid, sizeof(nchan_complex_value_arr_t));', 1]
['void memstore_fakeprocess_push_random(void) {', 1]
['if(write_aborted) {', 1]
['bool cmp_write_s16(cmp_ctx_t *ctx, int16_t s) {', 1]
["case '1': return 1;", 1]
['table.insert(nearly_departed, num_messages)', 1]
['MAP16_MARKER           = 0xDE,', 1]
['if(evcf == NULL) {', 1]
['test("Set error when an invalid timeout sec value is given to redisConnectWithTimeout: ");', 1]
['REDIS_SERVER=redis-server', 1]
['return sdsnewlen(s, sdslen(s));', 1]
['//maybe there is...', 1]
['nchan_msg_t        *msg;', 1]
['bool cmp_object_is_map(cmp_object_t *obj);', 1]
['psrd->original_cleanup = r->cleanup;', 1]
['"      if not next(msg) then --empty\\n"', 1]
['ERR("missed a message because it probably expired");', 1]
['nchan_copy_msg_id(oldid, newid, NULL);', 1]
['void             *shm_locked_calloc(shmem_t *shm, size_t size, const char *label);', 1]
['*u = obj.as.u8;', 1]
['enum connection_type {', 1]
['cur += sprintf(cur, id->tagactive != i ? inactive : active, t[i]);', 1]
['DBG("fd %i", publish_msg->buf->file->fd);', 1]
['"  msg_id=(\\"%s:%s\\"):format(time, tag)\\n"', 1]
['reply = redisCommand(c,"SET foo bar");', 1]
['else if(i==1) {', 1]
['* number of arguments, an array with arguments and an array with their', 1]
['memset((head)->hh.tbl, 0, sizeof(UT_hash_table));                              \\', 1]
['//remsg = ngx_alloc(sizeof(*remsg), ngx_cycle->log);', 1]
['if(cur->next != NULL) {', 1]
['ngx_uint_t                      max_messages;', 1]
['redisReply                    *cur;', 1]
['_dst_hh = (UT_hash_handle*)(((char*)_elt) + _dst_hho);               \\', 1]
['ngx_int_t            (*set_add_handler)(channel_spooler_t *, void (*cb)(channel_spooler_t *, subscriber_t *, void *), void*);', 1]
['//      * a single pass). */', 1]
['static void redisLibeventAddRead(void *privdata) {', 1]
['/* Writes an extended type to the backend */', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: can\'t handle a buffer in a temp file and in memory ");', 1]
['bool cmp_read_fixext1_marker(cmp_ctx_t *ctx, int8_t *type) {', 1]
['&& CHECK_REPLY_STRVAL(reply->element[0], "message")', 1]
["/* a number of the hash function use uint32_t which isn't defined on win32 */", 1]
['value->len = len;', 1]
['if((chmsg = ngx_alloc(sizeof(*chmsg), ngx_cycle->log)) != NULL) {', 1]
['redis_nginx_del_read(void *privdata)', 1]
['DBG("Destroyed node %p", node);', 1]
['redisReader *reader;', 1]
['if (!cmp_write_ext8_marker(ctx, tp, sz))', 1]
['struct UT_hash_handle *_he_thh, *_he_hh_nxt;                                 \\', 1]
['if (!cmp_read_ext8_marker(ctx, type, size))', 1]
['void *nchan_thingcache_find(void *tcv, ngx_str_t *id) {', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not get a connection for fd #%d", c->fd);', 1]
['if (n == NGX_FILE_ERROR) {', 1]
['if msg.prev then', 1]
['for(cur = ch->msg_first; cur != NULL; cur=cur->next){', 1]
['#endif /* CMP_H__ */', 1]
['void subscriber_debug_add(subscriber_t *);', 1]
['#define HASH_ADD(hh,head,fieldname,keylen_in,add)                                \\', 1]
['nchan_msg_t              msg;', 1]
['extern const ngx_str_t NCHAN_HEADER_PRAGMA;', 1]
['for (i=0; i < id2->tagcount; i++) {', 1]
['store_channel_head_shm_t       *shared;', 1]
['__redisAppendCommand(c,cmd,len);', 1]
['ngx_int_t rbtree_insert_node(rbtree_seed_t *seed, ngx_rbtree_node_t *node) {', 1]
['bool cmp_write_s64(cmp_ctx_t *ctx, int64_t l) {', 1]
['fcur = databuf.file_pos;', 1]
['local key = KEYS[1]', 1]
['} req;', 1]
['//on with the declarations', 1]
['"    local oldmsgid = redis.call(\'RPOP\', key.messages)\\n"', 1]
['#define HASH_BLOOM_BYTELEN 0', 1]
['dictDelete(callbacks,sname);', 1]
['if((buf_copy = ngx_pcalloc(pool, NGX_HTTP_BUF_ALLOC_SIZE(buf)))==NULL) {', 1]
['websocket_respond_status(&fsub->sub, NGX_HTTP_FORBIDDEN, NULL);', 1]
['#define dictGetEntryKey(he) ((he)->key)', 1]
['static void *fd_open(ngx_str_t *filename) {', 1]
['@id', 1]
['dst->data = NULL;', 1]
['ngx_int_t i;', 1]
['static ngx_int_t fd_close(ngx_str_t *id, void *fdv) {', 1]
['if stored_messages > max_stored_msgs then', 1]
['prepend_es_response_line(&id_line, &first_link, msgid_to_str(&sub->last_msgid), pool);', 1]
['table.insert(bulk, v)', 1]
['This should be done only in order to maximize performances when working with', 1]
['len = redisFormatCommand(&cmd,"SET %% %%");', 1]
['bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c);', 1]
['HASH_BLOOM_FREE((head)->hh.tbl);                                             \\', 1]
['nchan_maybe_send_channel_event_message(sub->request, SUB_RECEIVE_MESSAGE);', 1]
['* sdsupdatelen(s);', 1]
['if (d >= -32768)', 1]
['cmp = memcmp(s1,s2,minlen);', 1]
['spool->generation = 0;', 1]
['static void spool_bubbleup_dequeue_handler(subscriber_pool_t *spool, subscriber_t *sub, channel_spooler_t *spl);', 1]
['static dict *dictCreate(dictType *type, void *privDataPtr);', 1]
['set_buf(buf, mpb->pos, sz);', 1]
['type value = 123;                                                                     \\', 1]
['static char *nchan_set_pub_channel_id(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['assert(ret == REDIS_ERR);', 1]
['ngx_int_t           ret = NGX_OK;', 1]
['4', 1]
['return callback(NGX_ERROR, NULL, privdata);', 1]
['#ifndef NCHAN_REAPER_H', 1]
['static ngx_int_t chanhead_churner_withdraw(nchan_store_channel_head_t *ch) {', 1]
['ngx_rbtree_node_t  *left, *right;', 1]
['case NGX_HTTP_OPTIONS:', 1]
['free(s-sizeof(struct sdshdr));', 1]
['as soon as possible in order to prevent allocation of useless memory.', 1]
['static void redisLibuvDelWrite(void *privdata) {', 1]
['if(pd->n == 0) {', 1]
['fsub->data.act_as_intervalpoll = 1;', 1]
['unsigned char byte;', 1]
['else if(nchan_strmatch(val, 1, "redis")) {', 1]
['if(buf_body_size > 0) {', 1]
['* A bulk (string) reply. The value of the reply can be accessed using `reply->str`.', 1]
['/* Add the final element. We are sure there is room in the tokens array. */', 1]
['if (obj.type != CMP_TYPE_UINT8) {', 1]
['*chunked_fn = *sub->fn;', 1]
['ngx_int_t            rbtree_conditional_walk(rbtree_seed_t *seed, rbtree_walk_conditional_callback_pt, void *data);', 1]
['rp->position = NULL;', 1]
['assert(diff.tv_sec < 10);', 1]
['if (obj.type != CMP_TYPE_POSITIVE_FIXNUM) {', 1]
['union nchan_msg_multitag {', 1]
['"173ff5fb759e434296433d6ff2a554ec7a57cbdb",', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "rwlock %p releasing someone else\'s (pid %ui) write lock.", lock, lock->write_pid);', 1]
['ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "nchan: TOTALLY UNEXPECTED error publishing message, status code %i", status);', 1]
['match = va_arg(args, u_char *);', 1]
['aeEventLoop *loop;', 1]
['#define test(_s) { printf("#%02d ", ++tests); printf(_s); }', 1]
['tv.tv_sec=0;', 1]
['"    \\"msg\\",\\n"', 1]
['static ngx_int_t validate_id(ngx_http_request_t *r, ngx_str_t *id, nchan_loc_conf_t *cf) {', 1]
['assert(i >= 0);', 1]
['if(found) {', 1]
['* sdsIncrLen(s, nread);', 1]
['if (c == NULL || c->err) {', 1]
['#define HASH_DEL_IN_BKT(hh,head,hh_del)                                          \\', 1]
['ac->ev.addWrite = redisLibuvAddWrite;', 1]
['nchan_msg_t      *cur;', 1]
['bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s);', 1]
['static void reset_timer(internal_subscriber_t *f) {', 1]
['(head)->hh.tbl->tail = &((head)->hh);                                          \\', 1]
['#define WEBSOCKET_READ_GET_PAYLOAD_STEP     3', 1]
["local channel = tohash(redis.call('HGETALL', key.channel))", 1]
['} redis_subscriber_register_t;', 1]
['fakebody_chain->buf = fakebody_buf;', 1]
['bool cmp_write_str8_marker(cmp_ctx_t *ctx, uint8_t size);', 1]
["*(++cur) = '\\0';", 1]
['/* Make sure error is accessible if there is any */', 1]
['/* Modify the string substituting all the occurrences of the set of', 1]
['((internal_subscriber_t *)sub)->respond_status = handler;', 1]
['//     redisContext *c;', 1]
['void shm_free_immutable_string(shmem_t *shm, ngx_str_t *str) {', 1]
['ipc_process_t            *proc;', 1]
["if redis.call('PUBSUB','NUMSUB', pubsub)[2] > 0 then", 1]
['static memstore_data_t  mdata;', 1]
['* **`REDIS_REPLY_ARRAY`**:', 1]
['void sdstrim(sds s, const char *cset) {', 1]
['*s1 = last_char;', 1]
['"    if redis.call(\'EXISTS\', key.next_message)~=0 then\\n"', 1]
['* separator, NULL is returned.', 1]
['callbackKeyCompare,', 1]
['static void test_blocking_connection(struct config config) {', 1]
['size_t         sz = sizeof(*oldid->tag.allocd) * newid->tagcount;', 1]
['head = NULL;                                                             \\', 1]
['else if (status_code == NGX_HTTP_ACCEPTED) {', 1]
['rc = seed->compare(id, seed->id(rbtree_data_from_node(node)));', 1]
['redisAsyncContext *redisAsyncConnectUnix(const char *path);', 1]
['&& ngx_strncasecmp(header[i].key.data, header_name.data, header[i].key.len) == 0) {', 1]
['bool cmp_write_fixext16(cmp_ctx_t *ctx, int8_t type, const void *data);', 1]
['test_blocking_connection_errors();', 1]
['proc->c = NULL;', 1]
['[IPC_GET_MESSAGE] =                 (ipc_handler_pt )receive_get_message,', 1]
['status, msg_time, msg_tag, msg_data, msg_content_type, subscriber_count = redis.evalsha hashes[:get_message], [], [ch_id, msg_time, msg_tag, traverse_order, 15, sub_channel ]', 1]
['r->fn = &defaultFunctions;', 1]
['bool cmp_write_object(cmp_ctx_t *ctx, cmp_object_t *obj) {', 1]
['ERR("couldn\'t create websocket publisher llink");', 1]
["gem 'redis'", 1]
['rd.msg_time = ch->last_published_msg_id.time;', 1]
['"for i = 1, #arg do\\n"', 1]
['[IPC_TEST_FLOOD]                 =  (ipc_handler_pt )receive_flood_test', 1]
['EXT_TYPE_WRITING_ERROR,', 1]
['rdt.connect_params = parse_redis_url(rdt.connect_url);', 1]
['bool cmp_object_as_uinteger(cmp_object_t *obj, uint64_t *d) {', 1]
['if(!immortal_spool) destroy_spool(spool);', 1]
['extern const ngx_str_t NCHAN_HEADER_ALLOW_HEADERS;', 1]
['node = rbtree_node_from_data(spool);', 1]
['return cmp_write_s64(ctx, d);', 1]
['ERR("can\'t create multi subscriber for channel");', 1]
['"  sub_id =tonumber(redis.call(\'INCR\', keys.subscriber_id))\\n"', 1]
['_l = (_p+1)-c;', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "VARIABLES:" fmt, ##arg)', 1]
['ngx_int_t              (*subscribe)(subscriber_t *, ngx_str_t *);', 1]
['DBG("destroy spool node %p", node);', 1]
['free(val);', 1]
['memcpy(c->errstr,str,len);', 1]
['if (!ctx->read(ctx, &ext_size, sizeof(uint32_t))) {', 1]
['buf->file = &stuff->file;', 1]
['/* For each hash entry on this slot... */', 1]
['number of connections is reached).', 1]
['dictType *type;', 1]
['proc->ipc = ipc;', 1]
['shared_sub_count = head->shared->sub_count;', 1]
['DYLIBNAME=$(LIBNAME).$(DYLIBSUFFIX)', 1]
['ngx_rbtree_t         *tree = &seed->tree;', 1]
['},', 1]
['DBG("%p set dequeue handler to %p", self, cb);', 1]
['struct nchan_reloading_channel_s  *next;', 1]
['* s = sdsnew("Hello World");', 1]
['assert(!immortal_spool);', 1]
['last = p + n;', 1]
['return fsub->privdata;', 1]
['FIXEXT4_MARKER         = 0xD6,', 1]
['x = sdsnewlen("\\a\\n\\0foo\\r",7);', 1]
['bool cmp_read_fixext2(cmp_ctx_t *ctx, int8_t *type, void *data) {', 1]
['start = len+start;', 1]
['l1 = sdslen((const sds)key1);', 1]
['zone->data = d;', 1]
['name_table=[]', 1]
['/* Flag that is set when an async callback is executed. */', 1]
['static ngx_int_t websocket_reserve(subscriber_t *self) {', 1]
['return  1;', 1]
['* succesfully written to the socket. When the buffer is empty after the', 1]
['ws_frame_t              frame;', 1]
['bool cmp_read_fixext16_marker(cmp_ctx_t *ctx, int8_t *type);', 1]
['rem=len - ((size_t)(cur-accept)+sizeof("text/")-1);', 1]
['"local channel = tohash(redis.call(\'HGETALL\', key.channel))\\n"', 1]
['nchan_content_length_hash = nchan_hash_literal("content-length");', 1]
['"  content_type=ARGV[4],\\n"', 1]
['ch->gc_time = ngx_time() + NCHAN_CHANHEAD_EXPIRE_SEC;', 1]
['//make-a-pipe', 1]
['d->multi_chanhead->status = WAITING;', 1]
['sds x = sdsnew("foo"), y;', 1]
['* user wait until the server is ready to take our request.', 1]
['chains[3].buf = &boundary[2];', 1]
['{ ngx_string("nchan_channel_id2"),        nchan_channel_id_variable, 1},', 1]
['buf_filename_size = mbuf->file->name.len + 1; //+1 to ensure NUL-terminated filename string', 1]
['if(head->redis_sub->enqueued) {', 1]
['tags[i]=(val == 0 && sign == -1) ? -1 : val * sign; //shorthand "-" for "-1"', 1]
['/* These macros use decltype or the earlier __typeof GNU extension.', 1]
["//ALL HAIL CLANG'S STATIC ANALYZER", 1]
['if(chanhead != NULL) {', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "IPC-HANDLERS(%i):" fmt, memstore_slot(), ##args)', 1]
['ngx_conf_merge_sec_value(conf->subscriber_timeout, prev->subscriber_timeout, NCHAN_DEFAULT_SUBSCRIBER_TIMEOUT);', 1]
['if (!is_utf8(frame->payload, frame->payload_len)) {', 1]
['static ngx_int_t multipart_respond_message(subscriber_t *sub,  nchan_msg_t *msg) {', 1]
['[:main_conf, :shm_size],', 1]
['u_char *payload;', 1]
['if(d->chinfo.last_seen < chinfo->last_seen) {', 1]
['ipc_register_worker(ipc, cycle);', 1]
['ERR("unsub one not yet implemented");', 1]
['time_t             last_seen = 0;', 1]
['content_type->data=cur;', 1]
['bool cmp_write_fixext8_marker(cmp_ctx_t *ctx, int8_t type);', 1]
['rc = nchan_set_content_length_header(sr, content_length_n, content_len_str);', 1]
['char buf[1024*16];', 1]
['static ipc_t            ipc_data;', 1]
['status_line = &NCHAN_HTTP_STATUS_410;', 1]
['nchan_maybe_send_channel_event_message(sub->request, SUB_ENQUEUE);', 1]
['"  if stored_messages > max_stored_msgs then\\n"', 1]
['ngx_str_t *nchan_request_multipart_boundary(ngx_http_request_t *r, nchan_request_ctx_t *ctx) {', 1]
['CMP_TYPE_FIXEXT4,         /* 24 */', 1]
['"      dbg(list_key, \\" is empty\\")\\n"', 1]
['ev_io_stop(EV_A_ &e->rev);', 1]
['/* Reset an hashtable already initialized with ht_init().', 1]
['static ngx_rbtree_node_t * rbtree_find_node_generic(rbtree_seed_t *seed, void *id, uint32_t hash, ngx_rbtree_node_t **last_parent, ngx_int_t *last_compare) {', 1]
['//get_message', 1]
['if ((he = ht->table[i]) == NULL) continue;', 1]
['redis_publish_callback_data_t *d=(redis_publish_callback_data_t *)privdata;', 1]
['Both functions work like their blocking counterparts. The return value is `REDIS_OK` when the command', 1]
["/* forward the parent request's all other request headers */", 1]
['psrd->original_pool = r->pool;', 1]
['ngx_int_t nchan_respond_cstring(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *content_type, char *body, ngx_int_t finalize);', 1]
['#ifndef NGX_HTTP_SWITCHING_PROTOCOLS', 1]
['HASH_REPLACE(hh,head,ptrfield,sizeof(void *),add,replaced)', 1]
['if ((ctx)->ev.delRead) (ctx)->ev.delRead((ctx)->ev.data); \\', 1]
['if (ht->used > size)', 1]
['ngx_str_t                       allow_origin;', 1]
['if (obj.as.u32 <= 2147483647) {', 1]
['/* Like sdsjoin, but joins an array of SDS strings. */', 1]
['"elseif max_stored_msgs > 0 then\\n"', 1]
['static redisAsyncContext * rds_sub_ctx(void) {', 1]
['DBG("init memstore worker pid:%i slot:%i max workers :%i or %i", ngx_pid, memstore_slot(), shdata->max_workers, workers);', 1]
['ev_io_stop(EV_A_ &e->wev);', 1]
['char buf[];', 1]
['#define REDIS_ERR_OOM 5 /* Out of memory */', 1]
['//error!!', 1]
['copy_preallocated_str_to_cur(&dst_str, &src_str, cur);', 1]
['u_char                         *msgstart;', 1]
['nchan_match_channel_info_subtype(sizeof("text/")-1, cur, rem, &priority, &format, &channel_info_content_type);', 1]
['#define redisReplyReaderGetObject(_r) (((redisReader*)(_r))->reply)', 1]
['--input: keys: [], values: [channel_id, subscriber_id, channel_empty_ttl, active_ttl, concurrency]', 1]
['ngx_http_request_t        *request;', 1]
['ngx_http_complex_value_t           *cv;', 1]
['ngx_chain_t               *rchain = NULL;', 1]
['ngx_uint_t         allocd_nodes;', 1]
['pd->ch.last_published_msg_id = empty_msgid;', 1]
['redisAsyncHandleRead(connection->data);', 1]
['.tcp = {', 1]
['if (redisCheckSocketError(c) != REDIS_OK)', 1]
['rc = NGX_OK;', 1]
['nchan_output_filter(fsub->sub.request, websocket_frame_header_chain(fsub, WEBSOCKET_TEXT_LAST_FRAME_BYTE, ngx_buf_size((&fsub->msg_buf))));', 1]
['if(cf->channel_id_split_delimiter.len > 0) {', 1]
['publish_multi_data_t  *pd = privdata;', 1]
['rc = nchan_memstore_publish_generic(chead, publish_msg, 0, NULL);', 1]
['/* Reads an unsigned integer */', 1]
['cur = ngx_snprintf(cur, 58 + 10*NCHAN_FIXED_MULTITAG_MAX, "\\r\\nEtag: %V\\r\\n", tmp_etag);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "OUTPUT:" fmt, ##arg)', 1]
['ngx_int_t internal_subscriber_set_notify_handler(subscriber_t *sub, callback_pt handler);', 1]
['struct timeval timeout = { 1, 500000 }; // 1.5 seconds', 1]
['bool cmp_write_fixext8_marker(cmp_ctx_t *ctx, int8_t type) {', 1]
['subscriber_t *internal_subscriber_create(ngx_str_t *name, void *privdata) {', 1]
['bool cmp_object_as_str(cmp_object_t *obj, uint32_t *size) {', 1]
['.path = "/tmp/redis.sock"', 1]
['strncasecmp(reader->errstr,"No support for",14) == 0);', 1]
['rp->reap(cur);', 1]
['assert(sh->free >= 0);', 1]
['@tag=t', 1]
['id_out->len = sz;', 1]
['def self.loadscripts', 1]
['memcmp(y,"\\"\\\\a\\\\n\\\\x00foo\\\\r\\"",15) == 0)', 1]
['ngx_sha1_update(&sha1, magic.data, magic.len);', 1]
['DBG("want all msgs");', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "can\'t allocate redis get_message callback data");', 1]
['ngx_int_t                           i, my_procslot_index = NCHAN_INVALID_SLOT;', 1]
['/* Expand the hash table if needed */', 1]
['redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv);', 1]
['return msg_to_str(msg->msg); //WHOA, shared space!', 1]
['ipc_try_close_fd(&proc->pipe[0]);', 1]
['ngx_sha1_t          sha1;', 1]
['/* Functions managing dictionary of callbacks for pub/sub. */', 1]
['redisContextConnectTcp(c,ip,port,&tv);', 1]
['ngx_free(old_largetags);', 1]
['reply after the connection has been made (this happens when the maximum', 1]
['ht->table = NULL;', 1]
['for(rem=len; (cur = ngx_strnstr(cur, "application/", rem))!=NULL; cur += sizeof("application/")-1) {', 1]
['last_chain->next = &chains[3];', 1]
["case '6': return 6;", 1]
['ngx_chain_t             msg_chain;', 1]
["* For other types of CPU's (e.g. Sparc) an unaligned read causes a bus error.", 1]
['* does not exists dictAdd will suceed. */', 1]
['if (obj->as.u64 <= 9223372036854775807) {', 1]
['!memcmp(reply->element[0]->str,"bar",3) &&', 1]
['*d = obj->as.s16;', 1]
['nchan_reaper_add(&mpt->nobuffer_msg_reaper, shmsg_link);', 1]
['chanhead_cleanlink->time=ngx_time();', 1]
['if (r->buf != NULL) {', 1]
['bc[3].buf.pos = boundary;', 1]
['snprintf(buf,sizeof(buf),"Can\'t get addr: %s",gai_strerror(rv));', 1]
['e->rev.data = e;', 1]
['#define IPC_GET_CHANNEL_INFO_REPLY  14', 1]
["subscribers=  'channel:subscribers:'..id,", 1]
['ngx_buf_t                    buf;', 1]
['{ ngx_string("nchan_pubsub_channel_id"), //alt for nchan_channel_id', 1]
['fsub->data.cln = ngx_http_cleanup_add(fsub->sub.request, 0);', 1]
['/* Regression test for issue #45 on GitHub. */', 1]
['unsubscribed_data_t        data = {str_shm_copy(chid), privdata};', 1]
['redis_nginx_del_write(void *privdata)', 1]
['subscriber_t *http_chunked_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id);', 1]
['static void *createNilObject(const redisReadTask *task) {', 1]
['if (!write_type_marker(ctx, DOUBLE_MARKER))', 1]
['callback_pt             dequeue;', 1]
['assert(rp->count == 0 && rp->first == NULL);', 1]
['ngx_http_request_body_t       *fakebody;', 1]
['entry->val = (_val_); \\', 1]
['void              *data;', 1]
['uint32_t ext_size;', 1]
['/* Switch to DB 9 for testing, now that we know we can chat. */', 1]
['"key.message=key.message:format(msg.id)\\n"', 1]
['test_cond(strncmp(cmd,"*3\\r\\n$3\\r\\nSET\\r\\n$0\\r\\n\\r\\n$3\\r\\nfoo\\r\\n",len) == 0 &&', 1]
['/* Add an element, discarding the old if the key already exists.', 1]
['pos++;', 1]
['//Copyright (C) 2015 Alibaba Group Holding Limited', 1]
['return {200, ttl, tonumber(msg.time) or "", tonumber(msg.tag) or "", tonumber(msg.prev_time) or "", tonumber(msg.prev_tag) or "", msg.data or "", msg.content_type or "", msg.eventsource_event or "", subs_count}', 1]
['DBG("%p respond with transformed message %p %V (%p %V %i) %V", d->multi->sub, &remsg, msgid_to_str(&remsg.id), d->multi_chanhead, &d->multi_chanhead->id, d->n, &d->multi->id);', 1]
['#define cmp_read_sinteger  cmp_read_integer', 1]
['if (!((head)->hh.tbl))  { uthash_fatal( "out of memory"); }                    \\', 1]
['if ((HASH_KEYCMP((out)->hh.key,keyptr,keylen_in)) == 0) break;             \\', 1]
['if(f->sub.cf->subscriber_timeout > 0) {', 1]
['DBG("remove spool node %p", node);', 1]
['//last thing in the header. "chunked". accept', 1]
['#define dictCompareHashKeys(ht, key1, key2) \\', 1]
['SecureRandom.hex', 1]
['sr->header_in = r->header_in;', 1]
['ngx_sha1_update(&sha1, ws_key->data, ws_key->len);', 1]
['if(data_prefix_buf == NULL) {', 1]
['CMP_TYPE_FIXEXT1,         /* 22 */', 1]
['if (tokens == NULL) return NULL;', 1]
['bool cmp_write_ext16(cmp_ctx_t *ctx, int8_t type, uint16_t size,', 1]
['dbg("channel current_message present")', 1]
['chan_info->last_published_msg_id = zeroid;', 1]
['if ((head).hh_head == hh_del) {                                              \\', 1]
['assert(rc != NGX_OK);', 1]
['if(password) {', 1]
['if((sub = sub_create(r, msg_id)) == NULL) {', 1]
["if (_p[0] == 'h' && _p[1] == 'h') {", 1]
['"Specified map length is too long (> 0xFFFFFFFF)",', 1]
['info: "Defines a server or location as a publisher endpoint. Requests to a publisher location are treated as messages to be sent to subscribers. See the protocol documentation for a detailed description."', 1]
['ERR("couldn\'t create websocket publisher.");', 1]
['void ngx_rwlock_init(ngx_rwlock_t *lock) {', 1]
['if (type_marker <= 0x7F) {', 1]
['const char            *name;', 1]
['cur->type = REDIS_REPLY_INTEGER;', 1]
['ngx_int_t memstore_ipc_send_unsubscribed(ngx_int_t dst, ngx_str_t *chid, void* privdata) {', 1]
['if (curarg == NULL) goto err;', 1]
['nchan_copy_msg_id(&channel_copy->last_published_msg_id, &chead->latest_msgid, NULL);', 1]
['assert(reply->element[0]->type == REDIS_REPLY_STRING);', 1]
['ngx_flag_t          *fp;', 1]
['((void*)((char*)(_hs_q->next) +                        \\', 1]
['#define PING_DATABASE_COMMAND "PING"', 1]
['// from a previous restart that were never read from being received by', 1]
['(tbl->num_items >> (tbl->log2_num_buckets+1)) +                           \\', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_ALLOW_METHODS, allowed_methods);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:INTERNAL:" fmt, ##arg)', 1]
['redisReader *reader; /* Protocol reader */', 1]
['mmsg->msg = msg;', 1]
['hashv ^= hashv << 4;                                                         \\', 1]
['nchan_subscriber_first_message [:srv, :loc, :if],', 1]
['if (cv == NULL) {', 1]
['psrd->tmp_pool = NULL;', 1]
['if((node = rbtree_create_node(seed, sizeof(*spool))) == NULL) {', 1]
['ngx_str_t                 *id;', 1]
['ngx_rbtree_node_t *cur, *match;', 1]
['d->callback(NGX_OK, &chan, d->privdata);', 1]
['//discard cleanup', 1]
['if(oldid->tagcount > NCHAN_FIXED_MULTITAG_MAX) {', 1]
['slot_callback(s, i);', 1]
['ngx_memzero(evcf, sizeof(*evcf));', 1]
['ctx->channel_event_name = &evt_chan_publish;', 1]
['} redis_connect_params_t;', 1]
['memstore_fakeprocess_push(slot);', 1]
['last_message= nil,', 1]
['sdslen(x) == 4 && memcmp(x,"ciao\\0",5) == 0)', 1]
["*cur++=',';", 1]
['obj->type = CMP_TYPE_EXT16;', 1]
['DBG("%p set timeout handler data to %p", self, privdata);', 1]
['DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR', 1]
['puts "generated #{path}"', 1]
['ipc_open(ipc, cycle, shdata->max_workers, &init_shdata_procslots);', 1]
['int16_t      *tags1, *tags2;', 1]
['if (!cmp_write_fixext8_marker(ctx, type))', 1]
['newarg = sdscatlen(curarg,c,1);', 1]
['static ngx_int_t ensure_handshake(full_subscriber_t *fsub) {', 1]
['assert(ch->slot == slot);', 1]
['* specifically test ordering of reply items to parse. */', 1]
["/* Apply tolower() to every character of the sds string 's'. */", 1]
['ngx_http_script_code_pt       code;', 1]
['[:loc_conf, :allow_origin],', 1]
['!memcmp(reply->element[0]->element[1]->str,"foo",3) &&', 1]
['psr->handler = nchan_publisher_upstream_handler;', 1]
['static unsigned int dictGenHashFunction(const unsigned char *buf, int len);', 1]
['//just get the subscriber_channel_id for now. the publisher one is handled elsewhere', 1]
['////////// SUBSCRIBE ////////////////', 1]
['buf->pos += sz;', 1]
['} nchan_pub_subrequest_stuff_t;', 1]
['case WAITING:', 1]
['if(fsub->data.multimsg_last) {', 1]
['#ifndef __HIREDIS_AE_H__', 1]
['} spooled_subscriber_cleanup_t;', 1]
['msg->next->prev = msg->prev;', 1]
['ngx_atomic_int_t                   reloading;', 1]
['shdata->msgdebug_head = NULL;', 1]
['"  redis.call(\'EXPIRE\', key.subscribers, channel.ttl)\\n"', 1]
['spooler_set_bulk_dequeue_handler,', 1]
['uthash_free((head)->hh.tbl->buckets,                                         \\', 1]
['"  new_channel=false\\n"', 1]
['* connection is closed here. See issue #43.', 1]
['u_char            *cur, *last;', 1]
['static ngx_chain_t *websocket_close_frame_chain(full_subscriber_t *fsub, uint16_t code, ngx_str_t *err) {', 1]
['/* Context for an async connection to Redis */', 1]
['nchan_subscriber_first_message_directive,', 1]
['nchan_store_channel_head_t *chanhead;', 1]
['#define MUR_PLUS3_ALIGNED(p) (((unsigned long)p & 0x3) == 3)', 1]
['bool cmp_read_fixext8_marker(cmp_ctx_t *ctx, int8_t *type);', 1]
['buf->start=str->data;', 1]
['static ngx_int_t remove_spool(subscriber_pool_t *spool);', 1]
['bc[3].chain.buf = &bc[3].buf;', 1]
['ngx_buf_t                  buf;', 1]
['{ ngx_string("nchan_message_id"),         nchan_message_id_variable, 0},', 1]
['void reload_msgs(void) {', 1]
['char                  *lbl;', 1]
['test_cond(strncmp(cmd,"*3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n",len) == 0 &&', 1]
['node->parent = temp;', 1]
['"  channel=tohash(redis.call(\'HGETALL\', key.channel))\\n"', 1]
['static ngx_int_t internal_enqueue(subscriber_t *self) {', 1]
['publish chid: id, data:"whatever this is", ttl: 100', 1]
['if(ssub->sub->type != INTERNAL) {', 1]
['&& CHECK_REPLY_STR(els[offset+6])   //content-type', 1]
['//  ngx_str_t                   charset;', 1]
["buf[len] = '\\0';", 1]
['* user calls sdsMakeRoomFor(), writes something after the end of', 1]
['static uint32_t rbtree_hash_crc32(void *str) {', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_ALLOW_HEADERS, allowed_headers);', 1]
['obj->type = CMP_TYPE_POSITIVE_FIXNUM;', 1]
['ngx_memset(fsub, 0x13, sizeof(*fsub));', 1]
['if (d->wanted_msgid.time != d->msg->id.time) {', 1]
['#define MEMSTORE_PRIVATE_HEADER', 1]
['scripts[File.basename(f, ".lua") .to_sym]=IO.read f', 1]
['DBG("%p set timeout handler to %p", self, cb);', 1]
['$(MAKE) CFLAGS="-m32" LDFLAGS="-m32"', 1]
['void redisProcessCallbacks(redisAsyncContext *ac) {', 1]
['remsg.prev_id.tagcount = mcount;', 1]
['{ ngx_string("nchan_longpoll_multipart_response"),', 1]
['"      local ntime, ntag, prev_time, prev_tag, ndata, ncontenttype, neventsource_event=unpack(redis.call(\'HMGET\', key.next_message, \'time\', \'tag\', \'prev_time\', \'prev_tag\', \'data\', \'content_type\', \'eventsource_event\'))\\n"', 1]
['sub->fn->respond_message(sub, msg);', 1]
['static void websocket_publish_continue(full_subscriber_t *fsub, ngx_buf_t *buf) {', 1]
['v->len = len;', 1]
['if(pool!=NULL && (etag = ngx_palloc(pool, sizeof(*etag) + NGX_INT_T_LEN))==NULL) {', 1]
['DBG("Chanhead gc withdraw %p %V: %s", ch, &ch->id, reason);', 1]
['key = ngx_hash(key, *src);', 1]
['assert(id->tagactive != i);', 1]
['ngx_rbtree_insert(&seed->tree, node);', 1]
['//send a ":hi" comment', 1]
['*h = header[i];', 1]
['off_t           len = filename->len;', 1]
['cur->prev = NULL;', 1]
['* callbacks cannot call new commands. */', 1]
['seed->allocd_nodes = 0;', 1]
['//         assert(redisBufferRead(c) == REDIS_OK);', 1]
['extern const ngx_str_t NCHAN_HEADER_ORIGIN;', 1]
['size_t msgtag_to_strptr(nchan_msg_id_t *id, char *ch) {', 1]
['obj->as.str_size = obj->as.u8;', 1]
['$(MAKE) OPTIMIZATION=""', 1]
['return rv;  // Need to return REDIS_OK if alright', 1]
['ngx_log_error(NGX_LOG_ERR, log, 0, "nchan: can\'t create output chain, file in buffer is invalid");', 1]
['lcf->longpoll_multimsg=NGX_CONF_UNSET;', 1]
['ngx_http_finalize_request(r, nchan_response_channel_ptr_info(ch, r, NGX_HTTP_ACCEPTED));', 1]
['ipc_alert(nchan_memstore_get_ipc(), cd->sender, IPC_PUBLISH_MESSAGE_REPLY, &rd, sizeof(rd));', 1]
['int redisContextConnectTcp(redisContext *c, const char *addr, int port, const struct timeval *timeout);', 1]
['//if this is an subrequest, get nearest parent existing ctx', 1]
['//so it should only be recieving messages', 1]
['void *shm_alloc(shmem_t *shm, size_t size, const char *label) {', 1]
['if (redis_nginx_fd_is_valid(ac->c.fd)) {', 1]
['ngx_conf_merge_bitmask_value(conf->sub.poll, prev->sub.poll, 0);', 1]
['static rbtree_seed_t *urs = NULL;', 1]
['fd = (ngx_fd_t)(uintptr_t )nchan_thingcache_get(fd_cache, filename);', 1]
['redisReply                  *reply = (redisReply *)vr;', 1]
['//the id', 1]
['static ngx_str_t                publisher_name = ngx_string("http");', 1]
["case 'b': case 'B': return 11;", 1]
['* will require a reallocation.', 1]
['sdata->sub->fn->release(sdata->sub, 0);', 1]
['ep = end = s+sdslen(s)-1;', 1]
['static void ping_ev_handler(ngx_event_t *ev) {', 1]
['fd = msg_file->fd;', 1]
['/* invalid UTF-8 */', 1]
['Copyright (C) 2009-2014, Yichun "agentzh" Zhang <agentzh@gmail.com>.', 1]
['thing_t               *things;', 1]
['spooler_respond_message,', 1]
["local ttl = redis.call('TTL', key.next_message)", 1]
['req_msgid[i].tag.fixed[0] = tags[i];', 1]
['frame->payload[i] = frame->payload[i] ^ frame->mask_key[i % 4];', 1]
['static void test_blocking_io_errors(struct config config) {', 1]
['ngx_close_connection(proc->c);', 1]
['static void redisPublishCallback(redisAsyncContext *, void *, void *);', 1]
['* threshold is enforced at its default value, HASH_BKT_CAPACITY_THRESH. (If', 1]
['ERR("%i unbuffered messages still present in reaper at exit  (slot %i)", mpt->nobuffer_msg_reaper.count, ngx_process_slot);', 1]
['*size = obj.as.map_size;', 1]
['ERR("force-reaping msg with refcount %d", smsg->msg->refcount);', 1]
['nchan_publisher_channel_id [:srv, :loc, :if],', 1]
['if (cb.fn != NULL) {', 1]
['if msgid', 1]
['* always has an implicit null term. */', 1]
['rdt.chanhead_cleanup_tail=chanhead_cleanlink;', 1]
['int16_t  *newtags = newid->tagcount <= NCHAN_FIXED_MULTITAG_MAX ? newid->tag.fixed : newid->tag.allocd;', 1]
['2 * tbl->num_buckets * sizeof(struct UT_hash_bucket));              \\', 1]
['void                      *last;', 1]
['/* No more regular callbacks and no errors, the context *must* be subscribed or monitoring. */', 1]
['bc[2].buf.flush = 1;', 1]
['chains[2].buf = buf;', 1]
['if(cmp_read_array(&cmp, &array_sz)) {', 1]
['fsub->data.multimsg_last = NULL;', 1]
['if (setsockopt(c->fd,SOL_SOCKET,SO_SNDTIMEO,&tv,sizeof(tv)) == -1) {', 1]
['if (*p) p++;', 1]
['typedef unsigned char uint8_t;', 1]
['case 403:', 1]
['#ifdef PUB_FAKE_WORKER', 1]
['#define DICT_ERR 1', 1]
['assert(msg->msg->id.tagcount == 1);', 1]
["// Taken from agenzh's echo nginx module", 1]
['buf.last = evstr.data + evstr.len;', 1]
['shm_locked_free(shm, cur);', 1]
['c = ngx_get_connection(proc->pipe[0], cycle->log);', 1]
['cf.buffer_timeout = msg->expires - ngx_time();', 1]
['static ngx_str_t evt_sub_recvsts = ngx_string("subscriber_receive_status");', 1]
['bool cmp_write_map16(cmp_ctx_t *ctx, uint16_t size);', 1]
['buf->pos = start;', 1]
['CMP_TYPE_STR8,            /* 27 */', 1]
['if (((redisReply*)reply)->type == REDIS_REPLY_ERROR) {', 1]
['d->msg = NULL;', 1]
['s = sdsMakeRoomFor(s,len-sh->len);', 1]
['"local id, sub_id, empty_ttl = ARGV[1], ARGV[2], tonumber(ARGV[3]) or 20\\n"', 1]
['#define HASH_SFH(key,keylen,num_bkts,hashv,bkt)                                  \\', 1]
['assert(ngx_strncmp(urnode->smallmsg.data, msg->buf->start, msglen) == 0);', 1]
['r->headers_out.status=NGX_HTTP_OK;', 1]
['return (uint32_t )id->time;', 1]
['while (s < last_expected_process && ngx_processes[s].pid != -1) {', 1]
['if(ngx_strmatch(&alerttype, "delete channel") && array_sz > 2) {', 1]
['ngx_int_t             i, n = 0;', 1]
['msg_id=opt', 1]
['tokens = malloc(sizeof(sds)*slots);', 1]
['comments_table=[]', 1]
['void nchan_expand_msg_id_multi_tag(nchan_msg_id_t *id, uint8_t in_n, uint8_t out_n, int16_t fill);', 1]
['chunked_fn = &chunked_fn_data;', 1]
['_thh->prev, _prev );                                         \\', 1]
['return nchan_set_complex_value_array(cf, cmd, conf, &((nchan_loc_conf_t *)conf)->sub_chid);', 1]
['head->shared->internal_sub_count = 0;', 1]
['return iter->entry;', 1]
['void      (*exit_worker)(ngx_cycle_t *cycle);', 1]
['eventsource_fn->respond_status = es_respond_status;', 1]
['bool cmp_write_str(cmp_ctx_t *ctx, const char *data, uint32_t size);', 1]
['//general request-output functions and the iraq and the asian countries and dated references and the, uh, such', 1]
['whole_thing_t   *whole;', 1]
['ws_pub_head.prev = cur;', 1]
['ngx_buf_t                 *buffer = msg->buf;', 1]
['assert(sub == d->ssub->sub);', 1]
['bool cmp_write_fixstr_marker(cmp_ctx_t *ctx, uint8_t size);', 1]
['void (*cleanup)(void *privdata);', 1]
['ERR("something went wrong, the channel owner is invalid. i: %i h: %ui, workers: %i", i, h, workers);', 1]
['return cmp_write_bin16(ctx, data, size);', 1]
['//TODO: bulk move', 1]
['rp->first = cur;', 1]
['(lastid->time == msg->id.time && lastid->tag.fixed[0] < msg->id.tag.fixed[0])) {', 1]
['U8_MARKER              = 0xCC,', 1]
['head->channel.subscribers = 0;', 1]
['bool cmp_read_ext16(cmp_ctx_t *ctx, int8_t *type, uint16_t *size, void *data) {', 1]
['_sfh_key += 2*sizeof (uint16_t);                                             \\', 1]
['callback = (rbtree_walk_callback_pt )its_time_for_a_spooling;', 1]
['assert(chid->data != NULL);', 1]
['int           i, max;', 1]
['nchan_adjust_subrequest(sr, NGX_HTTP_POST, &POST_REQUEST_STRING, r->request_body, r->headers_in.content_length_n, NULL);', 1]
['self->bulk_dequeue_handler = handler;', 1]
['ngx_int_t                    use_redis = 0;', 1]
['#ifndef NGX_HTTP_ACCEPTED', 1]
['uint16_t                  first;', 1]
['ngx_buf_t              boundary[3]; //first, mid, and last boundary', 1]
['nchan_msg_id_t                 prev_msg_id;', 1]
['case 3:  _hj_i += ( (unsigned)_hj_key[2] << 16 );                           \\', 1]
['static void spooler_bulk_dequeue_handler(channel_spooler_t *spl, subscriber_type_t type, ngx_int_t count, void *privdata) {', 1]
['ac->onDisconnect(ac,REDIS_OK);', 1]
['ngx_int_t nchan_memstore_publish_generic(nchan_store_channel_head_t *head, nchan_msg_t *msg, ngx_int_t status_code, const ngx_str_t *status_line) {', 1]
['void sdsfreesplitres(sds *tokens, int count);', 1]
['unsigned long size;', 1]
['freeReplyObject(r->element[j]);', 1]
['void *shm_locked_calloc(shmem_t *shm, size_t size, const char *label) {', 1]
['void *(*valDup)(void *privdata, const void *obj);', 1]
['static char*  active="[%i],";', 1]
["//TODO: allocate from pool (but not the request's pool)", 1]
['static ngx_int_t nchan_postconfig(ngx_conf_t *cf) {', 1]
['* elements "foo" and "bar".', 1]
['time_t                          buffer_timeout;', 1]
['offsetof(nchan_loc_conf_t, allow_origin),', 1]
['{ ngx_string("nchan_subscribe_existing_channels_only"),', 1]
['return count;', 1]
['r->pos += len+2; /* skip \\r\\n */', 1]
['overflow->next = data->overflow;', 1]
['shdata->max_workers = ccf->worker_processes;', 1]
['sd->d = d;', 1]
['if numsub > 0 then', 1]
['_thh = ( _thh->next ?  (UT_hash_handle*)((char*)(_thh->next) +        \\', 1]
['if(rbtree_insert_node(seed, node) != NGX_OK) {', 1]
['ch->id.len=0;', 1]
['DBG("%p memstore-redis subscriber respond with status", d->sub);', 1]
['type value = 123.0;                                                                   \\', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "rwlock %p reserve read read (%i)", lock, lock->lock);', 1]
['*value = val->value;', 1]
['"  key.last_message=nil\\n"', 1]
['store_message_t        *cur;', 1]
["sub_count=redis.call('hget', keys.channel, 'subscribers')", 1]
['static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {', 1]
['struct subscriber_s {', 1]
['bool cmp_object_as_bool(cmp_object_t *obj, bool *b);', 1]
['DBG("SPOOLER %p not running", *spl);', 1]
['/* Try a GET and two INCR */', 1]
['want[i] = 0;', 1]
['nchan_copy_preallocated_buffer(buf, buf_copy);', 1]
['* len = redisFormatCommand(target, "SET %s %b", mykey, myval, myvallen);', 1]
['nchan_request_ctx_t       *ctx = ngx_http_get_module_ctx(fsub->sub.request, nchan_module);', 1]
['r->headers_out.status_line.len =status_line->len;', 1]
['"  if not msg.next then --this should have been taken care of by the channel.current_message check\\n"', 1]
['//initialize reusable chains and bufs', 1]
['if(redisReply_to_int(els[offset+1], &time_int) == NGX_OK) {', 1]
['[:loc_conf, :max_channel_subscribers],', 1]
['//location config stuff', 1]
['if (!write_type_marker(ctx, EXT16_MARKER))', 1]
['static ngx_int_t websocket_respond_status(subscriber_t *self, ngx_int_t status_code, const ngx_str_t *status_line);', 1]
['static nchan_loc_conf_t              dummy_config;', 1]
['int                             i = 0;', 1]
['--leave some crumbs behind showing this channel was just deleted', 1]
['v = (value < 0) ? -value : value;', 1]
['/* Mark context as connected. */', 1]
['//DBG("======= new: %V", msgid_to_str(newid));', 1]
['switch(r->type) {', 1]
['c->flags &= ~REDIS_CONNECTED;', 1]
['direction = callback(seed, rbtree_data_from_node(node), data);', 1]
['spl->dequeue_handler(spl, sub, spl->dequeue_handler_privdata);', 1]
['if(i==ngx_process_slot) {', 1]
['u_char                *char_boundary_last;', 1]
['last = ngx_copy(last, &WEBSOCKET_PAYLOAD_LEN_64_BYTE, sizeof(WEBSOCKET_PAYLOAD_LEN_64_BYTE));', 1]
['return dup;', 1]
['rdt.subhash = NULL;', 1]
['socklen_t errlen = sizeof(err);', 1]
['#define HASH_BLOOM_ADD(tbl,hashv)', 1]
['DBG("%p (%V) destroy", fsub, d->chid);', 1]
['#define HASH_FIND_INT(head,findint,out)                                          \\', 1]
['* the smaller one. */', 1]
['bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s) {', 1]
['void shmtx_lock(shmem_t *shm) {', 1]
['* === Specific API', 1]
['//DBG("withdraw message %V from ch %p %V", msgid_to_str(&msg->msg->id), ch, &ch->id);', 1]
['#define INTERVALPOLL_STRINGS_N 4', 1]
['&internal_set_timeout_callback,', 1]
['elseif sub_count < 0 then', 1]
['r->rstack[0].privdata = r->privdata;', 1]
['struct nchan_reloading_channel_s  *prev;', 1]
['(ngx_int_t (*)(void *, uint8_t)) nchan_memstore_chanhead_ready_to_reap,', 1]
['ngx_int_t           nchan_worker_processes;', 1]
['bool cmp_read_int(cmp_ctx_t *ctx, int32_t *i);', 1]
['cbuf->file->name.len=buf->file->name.len;', 1]
['for(nsub = self->first; nsub != NULL; nsub = nnext) {', 1]
['file->fd = nchan_fdcache_get(&file->name);', 1]
['#include <util/nchan_channel_id.h>', 1]
['pool = ngx_create_pool(NGX_DEFAULT_LINEBREAK_POOL_SIZE, ngx_cycle->log);', 1]
['typedef void (redisConnectCallback)(const struct redisAsyncContext*, int status);', 1]
['id.time = cf->subscriber_start_at_oldest_message ? 0 : -1;', 1]
['if(ngx_strnstr(accept_header->data, "text/event-stream", accept_header->len)) {', 1]
['nchan_msg_t *prev, *next;', 1]
['ctx->read = read;', 1]
['ngx_memzero(proc->wbuf.alerts, sizeof(proc->wbuf.alerts));', 1]
['msg.data or "",', 1]
['//initialize subscriber queues', 1]
['assert(spool->msg);', 1]
['`redisCommand`. This function takes a format similar to printf. In the simplest form,', 1]
['chain = &bc.chain;', 1]
['if(err) *err = "couldn\'t allocate memory for buf-and-chain while responding with msg";', 1]
['hashv ^= hashv << 11;                                                \\', 1]
['#include <sys/time.h> /* for struct timeval */', 1]
['if(redisReply_to_int(els[offset], &ttl) != NGX_OK) {', 1]
['if (!write_type_marker(ctx, FIXEXT16_MARKER))', 1]
['else { //overflow', 1]
['fsub->data.act_as_intervalpoll = 0;', 1]
['for(j=0; j <= 1; j++) {', 1]
['* reading/writing. These functions should be idempotent. */', 1]
['"  dbg(\\"channel missing\\")\\n"', 1]
['unsigned _he_bkt;                                                            \\', 1]
['if(msg) assert(msg_reserve(msg, "get multi msg") == NGX_OK);', 1]
['b->end = b->last;', 1]
['hashv = hashv * 16777619;                                                  \\', 1]
['if (bin_size > *size) {', 1]
['ngx_connection_t          *c;', 1]
['"Error reading size",', 1]
['size_t        sz = sizeof(*str) + str_in->len;', 1]
['static ngx_int_t redis_subscribe_channel_authcheck_callback(ngx_int_t status, void *ch, void *d) {', 1]
['//we have the chanhead address, but are too afraid to use it.', 1]
['switch (p[0]) {', 1]
['ctx->buf = buf;', 1]
['size_t                         sz;', 1]
['ERR("my procslot not found! I don\'t know what to do!");', 1]
['bool cmp_write_object_v4(cmp_ctx_t *ctx, cmp_object_t *obj) {', 1]
['lock->write_pid=0;', 1]
['slots *= 2;', 1]
['if(!spl->running) {', 1]
['/* Size: long */', 1]
['stream = fdopen(dup(fd), "r");', 1]
['ERR("got pinged");', 1]
['sub->last_msgid = newest_msgid;', 1]
['nchan_loc_conf_t     *cf = ngx_http_get_module_loc_conf(r, nchan_module);', 1]
['else if(pool==NULL && (etag = ngx_alloc(sizeof(*etag) + NGX_INT_T_LEN, ngx_cycle->log))==NULL) {', 1]
["case '+':", 1]
['set_varval(v, ctx->channel_id[data].data, ctx->channel_id[data].len);', 1]
['uthash_free( tbl->buckets, tbl->num_buckets*sizeof(struct UT_hash_bucket) ); \\', 1]
['* %b represents a binary safe string', 1]
['assert(newtags[i] > oldtags[i]);', 1]
['assert(msg->buf);', 1]
['msg_id = found_msg_id', 1]
['*p = node;', 1]
['bc[0].chain.next = ngx_buf_size(msg_buf) > 0 ? &bc[2].chain : &bc[3].chain;', 1]
['#include "nchan_config_commands.c" //hideous but hey, it works', 1]
['nchan_reaper_withdraw(&mpt->chanhead_churner, ch);', 1]
['* Makefile overhaul. Important to check out if you override one or more', 1]
['FIXEXT8_MARKER         = 0xD7,', 1]
['cd = ngx_alloc(sizeof(*cd) + sizeof(*d), ngx_cycle->log);', 1]
['//send headers', 1]
["if redis.call('EXISTS', keys.channel) ~= 0 then", 1]
['ngx_int_t nchan_subscriber_subscribe(subscriber_t *sub, ngx_str_t *ch_id) {', 1]
['frame->fin  = (frame->header[0] >> 7) & 1;', 1]
['* printf("%d\\n", sdslen(s));', 1]
['ngx_free_connection(connection);', 1]
['if(cmp_read_str_size(cmp, &sz)) {', 1]
['if(psrd->tmp_pool) {', 1]
['ngx_int_t          code;', 1]
['DBG("%p (%V) memstore subsriber enqueued ok", d->sub, d->chid);', 1]
['if(rp->last != cur) {', 1]
['static void redisLibuvAddWrite(void *privdata) {', 1]
['if(msg->temp_allocd) {', 1]
['WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE', 1]
['delayed_alert_glob_t   *glob = ngx_alloc(sizeof(*glob), ngx_cycle->log);', 1]
['if(head->foreign_owner_ipc_sub) {', 1]
['#define IPC_SUBSCRIBE               1', 1]
['if((pd = ngx_alloc(sizeof(*pd), ngx_cycle->log)) == NULL) {', 1]
['unsigned int j;', 1]
['local id, sub_id, active_ttl, concurrency = ARGV[1], ARGV[2], tonumber(ARGV[3]) or 20, ARGV[4]', 1]
['obj->as.ext.size = 16;', 1]
['strcasecmp(reply->str,"pong") == 0)', 1]
['struct dict *patterns;', 1]
['static int _dictInit(dict *ht, dictType *type, void *privDataPtr) {', 1]
['typedef struct dictType {', 1]
['$(STLIB_MAKE_CMD) $(OBJ)', 1]
['{ ngx_string("nchan_websocket_ping_interval"),', 1]
['if (c->buffered & NGX_HTTP_LOWLEVEL_BUFFERED) {', 1]
['fsub->data.timeout_ev.data = fsub;', 1]
['else if (type_marker == U8_MARKER) {', 1]
['(((ht)->type->keyCompare) ? \\', 1]
['/* Write until done */', 1]
['if (!cmp_read_fixext2_marker(ctx, type))', 1]
['int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn);', 1]
['(head)->hh.tbl->tail =                                               \\', 1]
['fakebody = ngx_pcalloc(r->pool, sizeof(*fakebody));', 1]
['info: "Channel id for a publisher or subscriber location. Can have up to 4 values to subscribe to up to 4 channels."', 1]
["channel=tohash(redis.call('HGETALL', key.channel))", 1]
['uint32_t cmp_version(void);', 1]
['nchan_channel_t    *channel = (nchan_channel_t *)ch;', 1]
['ngx_atomic_fetch_add(&ch->shared->stored_message_count, -1);', 1]
['if(fsub->data.multimsg_first == fsub->data.multimsg_last) {', 1]
['stmt;                                           \\', 1]
['if(status_code >= 400 && status_code <=599) {', 1]
['if(nchan_strmatch(val, 1, "oldest")) {', 1]
['fsub->dequeue_handler = sub_empty_callback;', 1]
['srdata.min = msg->prev_id;', 1]
['reply = redisCommand(c,"SET %s %s","foo","hello world");', 1]
['(tbl)->bloom_nbits = HASH_BLOOM;                                               \\', 1]
["if (*_p != '\\0' && *_p == ' ') _p++;", 1]
['static ngx_int_t redis_subscriber_register(nchan_store_channel_head_t *chanhead, subscriber_t *sub) {', 1]
['int16_t v, n = id->tagcount;', 1]
['* user request. The status is set accordingly (REDIS_OK, REDIS_ERR). */', 1]
['ngx_str_t                       id;', 1]
['struct redisCallback *next; /* simple singly linked list */', 1]
['#    value: [ :last, :first, :broadcast ],', 1]
['ngx_int_t                         memstore_procslot_offset = 0;', 1]
['subtype = sub->type;', 1]
['c->fd = fd;', 1]
['bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u) {', 1]
['struct addrinfo hints, *servinfo, *bservinfo, *p, *b;', 1]
['return nchan_set_complex_value_array(cf, cmd, conf, &((nchan_loc_conf_t *)conf)->pub_chid);', 1]
['p = (rc < 0) ? &temp->left : &temp->right;', 1]
['"  for k, v in pairs(dict) do\\n"', 1]
['fsub->data.multimsg_first = mmsg;', 1]
['test("Format command without interpolation: ");', 1]
['obj->type = CMP_TYPE_UINT64;', 1]
['sub->fn->set_dequeue_callback(sub, spool_sub_dequeue_callback, &ssub->dequeue_callback_data);', 1]
['assert(prv->type == REDIS_REPLY_ARRAY);', 1]
['/* Generic hash function (a popular one from Bernstein).', 1]
['{ ngx_string("nchan_publisher_upstream_request"),', 1]
['store_message_t          *chmsg;', 1]
['const ngx_str_t NCHAN_CHANNEL_INFO_PLAIN = ngx_string(', 1]
['nchan_maybe_send_channel_event_message(sub->request, SUB_DEQUEUE);', 1]
['return cmp;', 1]
['return memstore_slot();', 1]
['union cmp_object_data_u as;', 1]
['ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);', 1]
['nchan_adjust_subrequest(sr, NGX_HTTP_POST, &POST_REQUEST_STRING, fakebody, sz, NULL);', 1]
['subscriber_pool_t             *spool = d->spool;', 1]
['static void init_header_buf(ngx_buf_t *buf) {', 1]
['head->in_gc_queue = 0;', 1]
['else if (type_marker == FLOAT_MARKER) {', 1]
['switch(event_type) {', 1]
['#define CHECK_REPLY_INT_OR_STR(reply) ((reply)->type == REDIS_REPLY_INTEGER || (reply)->type == REDIS_REPLY_STRING)', 1]
['entry->next = ht->table[index];', 1]
['__redisGetSubscribeCallback(ac,reply,&cb);', 1]
["* explanation. First, keep in mind that we're calculating the ideal", 1]
['#include <ngx_connection.h>', 1]
['bool cmp_read_ext32_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size);', 1]
['p = ngx_snprintf(p, NGX_POOL_SUMMARY_SIZE, NGX_POOL_SUMMARY_FORMAT, s, unit, n, cn, ln);', 1]
['if(conf->redis_url.len == 0) {', 1]
['h++; //just to avoid the unused variable warning', 1]
['static dictType callbackDict = {', 1]
['nchan_loc_conf_t             cf;', 1]
['rc= ngx_http_send_header(r);', 1]
['alt_err.data=NULL;', 1]
['int major, minor;', 1]
['ngx_int_t memstore_ensure_chanhead_is_ready(nchan_store_channel_head_t *head, uint8_t ipc_subscribe_if_needed);', 1]
['publish_data_t    data;', 1]
['set_varval(v, ctx->subscriber_type->data, ctx->subscriber_type->len);', 1]
['redisDisconnectCallback *onDisconnect;', 1]
['d->d.resp.getmsg_code = MSG_NOTFOUND;', 1]
['/* Bucket expansion has the effect of doubling the number of buckets', 1]
['### Errors', 1]
['DBG("%p ) (%V) reserve", self, fsub->sub.name);', 1]
['//subscriber_unregister', 1]
['//ensure last char is NUL', 1]
['size_t clen, alen;', 1]
['* This is seen as an error instead of a regular reply because the', 1]
['//output: result_code, msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, channel_subscriber_count', 1]
['if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {', 1]
['len = format->len - 8 - 1 + 3*NGX_INT_T_LEN; //minus 8 sprintf', 1]
['psrd = &fsub->upstream_stuff->psr_data;', 1]
['ngx_conf_merge_value(conf->max_channel_id_length, prev->max_channel_id_length, NCHAN_MAX_CHANNEL_ID_LENGTH);', 1]
['* should not append a callback function for this command. */', 1]
['#define MUR_PLUS0_ALIGNED(p) (((unsigned long)p & 0x3) == 0)', 1]
['ngx_int_t    i, max;', 1]
['hash = &rbtree_hash_crc32;', 1]
['cv = ngx_palloc(cf->pool, sizeof(*cv));', 1]
['//DBG("=== updated: %V", msgid_to_str(oldid));', 1]
['fsub->sub.cf->storage_engine->publish(fsub->publish_channel_id, &msg, fsub->sub.cf, (callback_pt )websocket_publish_callback, fsub);', 1]
['dictIterator *it;', 1]
['The function `redisConnect` is used to create a so-called `redisContext`. The', 1]
['bkt = (hashv) & (num_bkts-1);                                                  \\', 1]
['ngx_int_t nchan_respond_msg(ngx_http_request_t *r, nchan_msg_t *msg, nchan_msg_id_t *msgid, ngx_int_t finalize, char **err) {', 1]
['static const ngx_str_t CREATED_LINE = ngx_string("201 Created");', 1]
['/* Update current position (note: outer blocks', 1]
['int redisAppendCommand(redisContext *c, const char *format, ...);', 1]
['//     test_cond(redisBufferWrite(c,&wdone) == REDIS_OK && wdone == 1);', 1]
['_prev = (char*)ELMT_FROM_HH((head)->hh.tbl, _thh);                    \\', 1]
['extern const ngx_str_t NCHAN_HEADER_ALLOW;', 1]
['* increment c twice so compensate here) */', 1]
['get_multi_message_data_t   *d;', 1]
['/* Cleanup self */', 1]
['ERR("couldn\'t insert spool node");', 1]
['#define REDIS_REPLY_STRING 1', 1]
['char *buf, *t;', 1]
['msg->next = NULL;', 1]
['ngx_atomic_t      mutex;', 1]
['assert(data);', 1]
['nchan_msg_id_t              *lastid;', 1]
['obj->type = CMP_TYPE_BIN16;', 1]
['ERR("Unable to add request cleanup for websocket subscriber");', 1]
['nchan_store_channel_head_t   *ch;', 1]
['tags_latest = head->latest_msgid.tag.allocd;', 1]
['_he_thh->hh_next = _he_newbkt->hh_head;                               \\', 1]
['This API can also be used to implement a blocking subscriber:', 1]
['len = (sp > ep) ? 0 : ((ep-sp)+1);', 1]
['static void websocket_init_frame(ws_frame_t *frame) {', 1]
['ngx_pool_t         *nchan_pool;', 1]
['switch(ch->status) {', 1]
["* function isn't a good fit for the key domain. When expansion is inhibited", 1]
['rsv->next = msg->rsv;', 1]
['free(p);', 1]
['(MUR_PLUS1_ALIGNED(p) ? MUR_THREE_ONE(p) : \\', 1]
['void         *pd = spool->bulk_dequeue_handler_privdata;', 1]
['rc = ngx_http_send_header(r);', 1]
['if(mpt->msg_reaper.count > 0) {', 1]
['static void *callbackValDup(void *privdata, const void *src) {', 1]
['if(proc->wbuf.overflow_n > 0 && i - first > 0) {', 1]
['assert(lastid->tagcount == 1 && lastid->tagcount == 1);', 1]
['DBG("IPC: send get_message_reply for channel %V  msg %p, privdata: %p", d->shm_chid, msg, d->privdata);', 1]
['ngx_int_t          shared_sub_count = 0;', 1]
['event_set(&e->rev,c->fd,EV_READ,redisLibeventReadEvent,e);', 1]
['t = sdscat(s, buf);', 1]
['static ngx_int_t nchan_publisher_type_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['"        dbg((\\"found msg %s:%s  after %s:%s\\"):format(tostring(msg.time), tostring(msg.tag), tostring(time), tostring(tag)))\\n"', 1]
['uint8_t ext_size;', 1]
['if(ctx == NULL || (ctx->msg_id.time == 0 && ctx->msg_id.tagcount == 0)) {', 1]
["*p-- = '0'+(v%10);", 1]
['chan_info->messages = chan->messages;', 1]
["local lastmsg = redis.call('HMGET', key.last_message, 'time', 'tag')", 1]
['ngx_memset(fsub, 0xB9, sizeof(*fsub)); //debug', 1]
['ngx_atomic_cmp_set(&lock->mutex, ngx_pid, 0);', 1]
['channel_copy=&chead->channel;', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SHMEM(%i):" fmt, memstore_slot(), ##args)', 1]
['time_t                          time;', 1]
['FLOAT_MARKER           = 0xCA,', 1]
['* However all the existing buffer is not discarded but set as free space', 1]
['* For other values, the "errstr" field will hold a description. */', 1]
['if (setsockopt(c->fd,SOL_SOCKET,SO_RCVTIMEO,&tv,sizeof(tv)) == -1) {', 1]
['ngx_int_t            (*destroy)(ngx_str_t *id, void *);', 1]
['static long long usec(void) {', 1]
['char                      *name;', 1]
['if (_l < sizeof(_format)-2) {', 1]
['if (cmd == NULL)', 1]
['a -= b; a -= c; a ^= ( c >> 12 );                                              \\', 1]
['/* > 2.0 returns OK on QUIT and read() should be issued once more', 1]
['#define NCHAN_SUB_MULTI_NOTIFY_ADDSUB 0', 1]
['free(r->element);', 1]
['redis_nginx_add_read(void *privdata)', 1]
['} else if (argc >= 2 && !strcmp(argv[0],"-s")) {', 1]
['//input:  keys: [], values: [channel_id, msg_time, msg_tag, no_msgid_order, create_channel_ttl]', 1]
['if (ngx_buf_in_memory(chain->buf)) {', 1]
['* if you are using a different boolean type in your application.', 1]
['if(newid->tagactive == i && newtags[i] != -1 && oldtags[i] != -1) {', 1]
['ch.last_seen = d->last_seen;', 1]
['\x00\x00\x00\x01Bud1\x00\x00\x10\x00\x00\x00\x08\x00\x00\x00\x10\x00\x00\x00\x00\x86\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x10\x00ocblob\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00s\x00r\x00cIlocblob\x00\x00\x00\x10\x00\x00\x00F\x00\x00\x00(\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x08\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00 \x00\x00\x00\x01\x00\x00\x00@\x00\x00\x00\x01\x00\x00\x00\x80\x00\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x01\x00\x00\x02\x00\x00\x00\x00\x01\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x10\x00\x00\x00\x00\x01\x00\x00 \x00\x00\x00\x00\x01\x00\x00@\x00\x00\x00\x00\x01\x00\x00\x80\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x01\x00\x02\x00\x00\x00\x00\x00\x01\x00\x04\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00\x00\x00\x01\x00\x10\x00\x00\x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x01\x00@\x00\x00\x00\x00\x00\x01\x00\x80\x00\x00\x00\x00\x00\x01\x01\x00\x00\x00\x00\x00\x00\x01\x02\x00\x00\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x00\x00\x01\x08\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01 \x00\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x10\x0b\x00\x00\x00E\x00\x00\x00\x86\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x04DSDB\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00 \x00\x00\x00`\x00\x00\x00\x01\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x01\x00\x00\x02\x00\x00\x00\x00\x01\x00\x00\x04\x00\x00\x00\x00\x02\x00\x00\x08\x00\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00 \x00\x00\x00\x00\x01\x00\x00@\x00\x00\x00\x00\x01\x00\x00\x80\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x01\x00\x02\x00\x00\x00\x00\x00\x01\x00\x04\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00\x00\x00\x01\x00\x10\x00\x00\x00\x00\x00\x01\x00 \x00\x00\x00\x00\x00\x01\x00@\x00\x00\x00\x00\x00\x01\x00\x80\x00\x00\x00\x00\x00\x01\x01\x00\x00\x00\x00\x00\x00\x01\x02\x00\x00\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x00\x00\x01\x08\x00\x00\x00\x00\x00\x00\x01\x10\x00\x00\x00\x00\x00\x00\x01 \x00\x00\x00\x00\x00\x00\x01@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', 1]
['ngx_str_t  nchan_content_length_header_key = ngx_string("Content-Length");', 1]
['sub->last_msgid=newspool->id;', 1]
['*s = obj->as.s8;', 1]
['{ ngx_null_string,                        NULL, 0 }', 1]
['strerror_r(errno,buf+len,sizeof(buf)-len);', 1]
['u_char *last;', 1]
['#include <event.h>', 1]
['/* Double conversion (without modifiers) */', 1]
['dbg("id= ", tostring(sub_id), "count= ", tostring(sub_count))', 1]
['(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS', 1]
['info: "Whether or not a subscriber may create a channel by sending a request to a push_subscriber location. If set to on, a publisher must send a POST or PUT request before a subscriber can request messages on the channel. Otherwise, all subscriber requests to nonexistent channels will get a 403 Forbidden response."', 1]
['{ ngx_string("push_publisher"), //legacy for nchan_publisher', 1]
['msg->id.time = 0;', 1]
['//copypasta from os/unix/ngx_process_cycle.c (ngx_channel_handler)', 1]
['c = &(ac->c);', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "nchan: invalid message redis reply");', 1]
['void redis_nginx_cleanup(void *privdata);', 1]
['for(cur = first; cur != NULL; cur = cur->next) {', 1]
['if (!ctx->write(ctx, &size, sizeof(uint8_t))) {', 1]
['if (obj->type == CMP_TYPE_NIL)', 1]
['_hj_i = _hj_j = 0x9e3779b9;                                                    \\', 1]
['STLIBNAME=$(LIBNAME).$(STLIBSUFFIX)', 1]
['r->keepalive = 1;', 1]
['if(tc->thing_head != NULL) {', 1]
['bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c) {', 1]
['ERR("%s connection to redis for %V closed: %s", ctx_type, rdt.connect_url, ctx_type, ac->errstr);', 1]
['*len = (int)strtol(p+1,NULL,10);', 1]
['struct has an integer `err` field that is non-zero when an the connection is in', 1]
["//internal subscribers are *special* and don't really count", 1]
['#define HASH_BLOOM_SIGNATURE 0xb12220f2', 1]
['fsub->shook_hands = 0;', 1]
['nchan_free_msg_id(&msg->prev_id);', 1]
['if (!bound) {', 1]
['return REDIS_ERR; /* Avoid warning. */', 1]
['ngx_event_t                            *wev;', 1]
['bool cmp_read_short(cmp_ctx_t *ctx, int16_t *s);', 1]
['static void redisLibuvAddRead(void *privdata) {', 1]
['head = chanhead_redis_create(channel_id);', 1]
['static const u_char WEBSOCKET_PONG_LAST_FRAME_BYTE  = WEBSOCKET_OPCODE_PONG  | (WEBSOCKET_LAST_FRAME << 4);', 1]
['nchan_generate_random_boundary(ctx->multipart_boundary->data, 32);', 1]
['+ ( (unsigned)_hj_key[3] << 24 ) );                                      \\', 1]
['#include "hiredis/async.h"', 1]
['REDIS_HOST="127.0.0.1"', 1]
['ngx_rbt_red(node);', 1]
['char *arg;', 1]
['assert((c->flags & REDIS_SUBSCRIBED || c->flags & REDIS_MONITORING));', 1]
['nchan_store_t  nchan_store_redis = {', 1]
['store_message_t *chanhead_find_next_message(nchan_store_channel_head_t *ch, nchan_msg_id_t *msgid, nchan_msg_status_t *status) {', 1]
['bool cmp_read_s16(cmp_ctx_t *ctx, int16_t *s) {', 1]
['*  Written by Leo Ponomarev 2009-2015', 1]
['DBG("got a better response %V (n:%i), replace.", msgid_to_str(&msg->id), sd->n);', 1]
['d->multi_chanhead->multi_waiting --;', 1]
['#define CHANNEL_HASH_FIND(id_buf, p)    HASH_FIND( hh, mpt->hash, (id_buf)->data, (id_buf)->len, p)', 1]
['ngx_memcpy(buf, mbuf, sizeof(*buf));', 1]
['}; //ipc_t', 1]
['assert(t[i] >= -2);', 1]
['rp->reap = reap;', 1]
['*next_ptr = NULL;', 1]
['static void on_close(uv_handle_t* handle) {', 1]
['hashv = 2166136261UL;                                                          \\', 1]
['ngx_buf_t * nchan_chain_to_single_buffer(ngx_pool_t *pool, ngx_chain_t *chain, size_t content_length) {', 1]
['msgid = &msg->id;', 1]
['"    ch[3]=ch[4]\\n"', 1]
['There are a few hooks that need to be set on the context object after it is created.', 1]
["redis.call('EXPIRE', key.subscribers, channel.ttl)", 1]
['struct timeval tv;', 1]
['static ngx_str_t     sub_name = ngx_string("websocket");', 1]
['ERR("msgpack parsing error: %s", cmp_strerror(cmp));', 1]
['void *p = shm_locked_alloc(shm, size, label);', 1]
['bool cmp_read_uinteger(cmp_ctx_t *ctx, uint64_t *u);', 1]
['# Copyright (C) 2010-2011 Pieter Noordhuis <pcnoordhuis at gmail dot com>', 1]
["else {//don't go any further, the sub has been deleted", 1]
['return &debug_pool_str;', 1]
['if ((delptr) == ELMT_FROM_HH((head)->hh.tbl,(head)->hh.tbl->tail)) {     \\', 1]
['head->latest_msgid.tagcount = n;', 1]
['void *p = shm_alloc(shm, size, label);', 1]
['time_t                          last_subscribed_local;', 1]
['--not efficient, but useful for a few short-term subscriptions', 1]
['10', 1]
['_count += _bkt_count;                                                \\', 1]
['union getmsg_u {', 1]
['msglen = buf->file_last - buf->file_pos;', 1]
['typedef struct subscriber_s subscriber_t;', 1]
['} while(0);', 1]
['ngx_int_t nchan_detect_eventsource_request(ngx_http_request_t *r) {', 1]
['WEBSOCKET_STRINGS, EVENTSOURCE_STRINGS, HTTP_CHUNKED_STRINGS, HTTP_MULTIPART_STRINGS, LONGPOLL_STRINGS_N, INTERVALPOLL_STRINGS_N, DISABLED_STRINGS_N)) {', 1]
['int redisReaderGetReply(redisReader *r, void **reply) {', 1]
['nchan_store_memory.create_main_conf(cf, mcf);', 1]
['int16_t                      *tags_latest, *tags_oldest;', 1]
['assert(d->wanted_msgid.time <= msg->id.time);', 1]
['d->multi->sub = NULL;', 1]
['int redisEnableKeepAlive(redisContext *c);', 1]
['//     test("redisDisconnect executes pending callbacks with NULL reply: ");', 1]
['cleanup:', 1]
['if(dst_n > NCHAN_FIXED_MULTITAG_MAX && dst_n > src_n) {', 1]
['/* Locate the right callback */', 1]
['* s = sdsnew("foobar");', 1]
['frame->step = WEBSOCKET_READ_GET_REAL_SIZE_STEP;', 1]
['#define NGX_POOL_ENTRY_SIZE     (48 /* func */ + 12 * 4 + sizeof("size: num: cnum: lnum: \\n") - 1)', 1]
['struct req_s {', 1]
['v == "" ? nil : v', 1]
['return _redisContextConnectTcp(c, addr, port, timeout, NULL);', 1]
['#include <subscribers/http-multipart-mixed.h>', 1]
['((void*)((char*)(_hs_p->next) +                  \\', 1]
['ngx_table_elt_t                *h = ngx_list_push(&r->headers_out.headers);', 1]
['bool cmp_read_ext8(cmp_ctx_t *ctx, int8_t *type, uint8_t *size, void *data);', 1]
['* Return value:', 1]
["require 'minitest/reporters'", 1]
["* redisProcessCallbacks(). Otherwise, the context is immediately free'd. */", 1]
['tags_oldest[i] = 0;', 1]
['sh->len = initlen;', 1]
['self->first->prev = ssub;', 1]
['"    msg.data or \\"\\",\\n"', 1]
['size_t count);', 1]
['ngx_file_t        *f = buf->file;', 1]
['rec->data_size = data_size', 1]
['ERR("redis_get_mesage_callback has NULL userdata");', 1]
["case '-':", 1]
['/* Remap the new hashtable in the old */', 1]
['replies[i] = redisCommand(c,"PING");', 1]
['int redisSetTimeout(redisContext *c, const struct timeval tv);', 1]
['fsub->already_dequeued = 0;', 1]
['void (*freeObject)(void*);', 1]
['ngx_memzero(&fsub->data.timeout_ev, sizeof(fsub->data.timeout_ev));', 1]
['usage.', 1]
['spool->msg_status = findmsg_status;', 1]
['if ( ((delptr)->hh.prev == NULL) && ((delptr)->hh.next == NULL) )  {         \\', 1]
['nchan_init_worker,             /* init process */', 1]
['size_t j, i, l = sdslen(s);', 1]
['"  message=      \'channel:msg:%s:%s\', --hash\\n"', 1]
['d->cb(d->msg_status, &retmsg, d->privdata);', 1]
['msg_rsv_dbg_t     *rsv;', 1]
['bool cmp_write_integer(cmp_ctx_t *ctx, int64_t d);', 1]
["* more than ceil(#items/#buckets) items. that's the ideal chain length. */", 1]
['DBG("Shm created with data at %p", d);', 1]
['if(old_shared == NULL) {', 1]
['* in the flags field is set when the context is connected. */', 1]
['"if redis.call(\'EXISTS\', key.channel) ~= 0 then\\n"', 1]
['#define SPOOLER_RESPOND_SPOOLARRAY_SIZE 32', 1]
["case '7': return 7;", 1]
['typedef unsigned int uint32_t;', 1]
['$(INSTALL) hiredis.h async.h adapters $(INSTALL_INCLUDE_PATH)', 1]
['return sizeof(*sh)+sh->len+sh->free+1;', 1]
['#define NGX_RWLOCK_SPIN         2048', 1]
['c->flags |= REDIS_IN_CALLBACK;', 1]
['for (len = 0; p < last; len++) {', 1]
['cbuf->start=cbuf->pos;', 1]
['static redisContext *redisContextInit(void) {', 1]
['cur->time = ngx_time();', 1]
['&& ngx_strncasecmp(header[i].key.data, NCHAN_HEADER_IF_NONE_MATCH.data, header[i].key.len) == 0) {', 1]
['buf.start = buf.pos;', 1]
['CMP_TYPE_MAP32,           /* 33 */', 1]
['bool cmp_write_str_marker_v4(cmp_ctx_t *ctx, uint32_t size);', 1]
['return cmp_read_long(ctx, d);', 1]
['msg_file->fd = nchan_fdcache_get(&msg_file->name);', 1]
['HASH_FIND(hh,head,findptr,sizeof(void *),out)', 1]
['buf->end = buf->start + len;', 1]
['struct UT_hash_handle *hh_head;', 1]
['--output: message_tag, channel_hash {ttl, time_last_seen, subscribers, messages}', 1]
['return b;', 1]
['u_char     *cur_first = cur;', 1]
['ngx_int_t nchan_reaper_add(nchan_reaper_t *rp, void *thing) {', 1]
['int nwritten;', 1]
['chanhead = nchan_memstore_find_chanhead(d->channel_id);', 1]
['#define THING_HASH_ADD(tc, thing)      HASH_ADD_KEYPTR( hh, tc->things, (thing->id).data, (thing->id).len, thing)', 1]
['if(mpt->nobuffer_msg_reaper.count > 0) {', 1]
['for (i = 0; i < elements; i++) sdsfree(tokens[i]);', 1]
['ngx_memcpy(buf->start, els[offset+5]->str, len);', 1]
['ac->ev.delWrite = redisLibuvDelWrite;', 1]
['last = ngx_copy(last, &len_net, 8);', 1]
['ngx_int_t rbtree_init(rbtree_seed_t *seed, char *name, void *(*id)(void *), uint32_t (*hash)(void *), ngx_int_t (*compare)(void *, void *)) {', 1]
['rbtree_insert_node(urs, node);', 1]
['if(! ch->in_gc_queue) {', 1]
['if concurrency == "FILO" then', 1]
['redisCallback *dup = malloc(sizeof(*dup));', 1]
['CMP_TYPE_DOUBLE,          /* 13 */', 1]
['extern ngx_int_t nchan_worker_processes;', 1]
['* number of bytes previously available. */', 1]
['*   gcc -m64 -dM -E - < /dev/null                  (on gcc)', 1]
['val.len = cur - cbuf;', 1]
['ngx_atomic_t                stored_message_count;', 1]
['r->rstack[0].parent = NULL;', 1]
['bool cmp_write_fixstr(cmp_ctx_t *ctx, const char *data, uint8_t size) {', 1]
['d->channel_id->data = (u_char *)&(d->channel_id)[1];', 1]
['//get_message_from_key', 1]
['HASH_OOPS("invalid app item count %d, actual %d\\n",                  \\', 1]
['ngx_int_t                   ret;', 1]
['* many other MessagePack libraries.  No encoding is assumed in this case, not', 1]
['static ngx_str_t * nchan_store_content_type_from_message(nchan_msg_t *msg, ngx_pool_t *pool){', 1]
['#define _EL_ADD_WRITE(ctx) do { \\', 1]
['/* Vararg width depends on the type. These tests make sure that the', 1]
['2', 1]
['--input: keys: [], values: [channel_id, subscriber_id, empty_ttl]', 1]
['//assert(rbtree_find_node(seed, seed->id(rbtree_data_from_node(node))) == node);', 1]
['"    key.last_message=(\'channel:msg:%s:%s\'):format(channel.current_message, id)\\n"', 1]
['HASH_EMIT_KEY(hh,head,keyptr,keylen_in);                                        \\', 1]
['_dst_hh->next = NULL;                                                \\', 1]
['//ERR("%V local sub_count %i, internal_sub_count %i", &head->id,  head->sub_count, head->internal_sub_count);', 1]
['pd->callback(pd->rc, &pd->ch, pd->privdata);', 1]
['"      dbg((\\"found msg2 %i:%i  after %i:%i\\"):format(ntime, ntag, time, tag))\\n"', 1]
['ngx_uint_t                  sub_count;', 1]
['void nchan_websocket_publisher_llist_init();', 1]
['ngx_str_t                    str;', 1]
['thing->id.len = id->len;', 1]
['ngx_memcpy(&fsub->sub, &new_websocket_sub, sizeof(new_websocket_sub));', 1]
['info: "Use redis for message storage at this location."', 1]
['if (redisvAppendCommand(c,format,ap) != REDIS_OK)', 1]
['redisLibeventAttach(c,base);', 1]
['DBG("reap %s %p later (waiting to be reaped: %i)", rp->name, thing, rp->count);', 1]
['static char *readLine(redisReader *r, int *_len) {', 1]
['buf->last=pos;', 1]
['application, you can use the global `errno` variable to find out what is', 1]
['* nread = read(fd, s+oldlen, BUFFER_SIZE);', 1]
['#define HASH_ADD_PTR(head,ptrfield,add)                                          \\', 1]
['ch->multi[i].sub->fn->dequeue(ch->multi[i].sub);', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_SEC_WEBSOCKET_ACCEPT, &ws_accept_key);', 1]
['glob->timer.log = ngx_cycle->log;', 1]
['if ((n == NGX_ERROR) || (n == 0)) {', 1]
['if (!cmp_write_fixext2_marker(ctx, type))', 1]
['obj->type = CMP_TYPE_UINT8;', 1]
['* issued to find out the socket was closed by the server. In both', 1]
['pos += sdslen(curargv[j]);', 1]
['static char *nchan_subscriber_directive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['/* Force "avalanching" of final 127 bits */                                  \\', 1]
['else if (type_marker == FIXEXT2_MARKER) {', 1]
['* Use poll(2) instead of select(2) to support large fds (>= 1024).', 1]
['#define MUR_THREE_ONE(p) ((((*WP(p))&0xffffff00) >> 8) | (((*(WP(p)+1))&0x000000ff) << 24))', 1]
['if (timeout != NULL) {', 1]
['ctx = ngx_http_get_module_ctx(fsub->sub.request, nchan_module);', 1]
['msec = INT_MAX;', 1]
['default: ["http", "websocket", "eventsource", "longpoll", "chunked", "multipart-mixed"],', 1]
['nchan_maybe_send_channel_event_message(r, CHAN_DELETE);', 1]
['#define DISABLE_RWLOCK 0  //just use a regular mutex for everything', 1]
['d->chinfo.subscribers += chinfo->subscribers;', 1]
['/* Set reply object */', 1]
['static ngx_int_t rbtree_validate_nodes_reachable(rbtree_seed_t *seed) {', 1]
['bool cmp_write_str8(cmp_ctx_t *ctx, const char *data, uint8_t size);', 1]
['nchan_pubsub [:srv, :loc, :if],', 1]
['nchan_store_redis.find_channel(d->channel_id, redis_subscribe_channel_authcheck_callback, d);', 1]
['ngx_str_t                   *getmsg_chid;', 1]
['WARNINGS=-Wall -W -Wstrict-prototypes -Wwrite-strings', 1]
['if(r->headers_out.status != NGX_HTTP_BAD_REQUEST) {', 1]
['/* Main loop */                                                                \\', 1]
['#define MUR_TWO_TWO(p)   ((((*WP(p))&0x0000ffff) <<16) | (((*(WP(p)+1))&0xffff0000) >> 16))', 1]
['const  ngx_str_t NCHAN_HEADER_VARY = ngx_string("Vary");', 1]
['ngx_str_t                     ids[NCHAN_MULTITAG_MAX];', 1]
['if((tmp = nchan_get_header_value(r, TE_HEADER)) != NULL) {', 1]
['if(ngx_time() - glob->alert.time_sent >= 2) {', 1]
['nchan_subscriber_compound_etag_message_id [:srv, :loc, :if],', 1]
['ngx_chain_t                   *fakebody_chain;', 1]
['cstr += pvariant;', 1]
['static ngx_int_t spooler_respond_generic(channel_spooler_t *self, nchan_msg_t *msg, ngx_int_t code, const ngx_str_t *line) {', 1]
['seed->hash = hash;', 1]
['websocket_frame_header_chain(fsub, WEBSOCKET_CLOSE_LAST_FRAME_BYTE, err->len + 2);', 1]
['char_boundary_last = ngx_snprintf(char_boundary, 50, ("\\r\\n--%V--\\r\\n"), nchan_request_multipart_boundary(r, ctx));', 1]
['nchan_copy_msg_id(&retmsg.id, &d->wanted_msgid, multi_largetag);', 1]
['/* Initialize and install read/write events */', 1]
['char *add_fakesub;', 1]
['callback(rc, channel_copy, privdata);', 1]
['nchan_longpoll_multimsg_t     *mmsg;', 1]
['ERR("can\'t create chanhead for redis store");', 1]
['free the sub replies (it is actually harmful and will corrupt the memory).', 1]
['static void redisEchoCallback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['buf = nchan_chain_to_single_buffer(tmp_pool, request_chain, content_length);', 1]
['self->first = ssub;', 1]
['if(fakeprocess_top == NULL) {', 1]
['int pvariant, hasnext;', 1]
['sdslen(x) == 1 && memcmp(x,"a\\0",2) == 0)', 1]
['c->err = 0;', 1]
['ch.last_published_msg_id.tag.fixed[0]=reply->element[0]->integer;', 1]
['* from being issued, but tries to flush the output buffer and execute', 1]
['static ngx_int_t nchan_channel_id_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['//no id?..', 1]
['*i = obj->as.s32;', 1]
['bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size);', 1]
['DBG("init WS publisher llist");', 1]
['struct subscriber_pool_s {', 1]
['/* Reads an array from the backend */', 1]
['$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. -I$(AE_DIR) $< $(AE_DIR)/ae.o $(AE_DIR)/zmalloc.o $(AE_DIR)/../deps/jemalloc/lib/libjemalloc.a -pthread $(STLIBNAME)', 1]
['#define DICT_NOTUSED(V) ((void) V)', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "MEMSTORE:(fake)%02i: " fmt, memstore_slot(), ##args)', 1]
['#define get16bits(d) (*((const uint16_t *) (d)))', 1]
['#ifndef __HIREDIS_LIBEV_H__', 1]
['len = snprintf(buf,sizeof(buf),"%s: ",prefix);', 1]
['#ifdef _OSX', 1]
['ngx_atomic_fetch_add(&head->shared->internal_sub_count, 1);', 1]
['test_cond("sdsIncrLen() -- content", x[0] == \'0\' && x[1] == \'1\');', 1]
['} redisLibeventEvents;', 1]
['chanhead_pubsub_status_t   *channel_status;', 1]
['char    *p = conf;', 1]
['else if((cur + 4) < last) {', 1]
['* "the usual" patch-up process for the app-order doubly-linked-list.', 1]
['bool cmp_read_fixext1(cmp_ctx_t *ctx, int8_t *type, void *data);', 1]
['lcf->websocket_ping_interval=NGX_CONF_UNSET;', 1]
['bool cmp_read_char(cmp_ctx_t *ctx, int8_t *c);', 1]
['local found_msg_id', 1]
['ngx_memzero(&channel, sizeof(channel)); // for ddebugging. this should be removed later.', 1]
['tc->things = NULL;', 1]
['[IPC_DELETE_REPLY] =                (ipc_handler_pt )receive_delete_reply,', 1]
['static void prepend_es_response_line(ngx_str_t *fmt, ngx_chain_t **first_chain, ngx_str_t *str, ngx_pool_t *pool) {', 1]
["// create_channel_ttl - make new channel if it's absent, with ttl set to this. 0 to disable.", 1]
['ngx_int_t msg_reserve(nchan_msg_t *msg, char *lbl);', 1]
['ws_accept_key.len=ngx_base64_encoded_length(sha1_str.len);', 1]
['dictEntry *entry, *nextEntry;', 1]
['ngx_event_t   timer;', 1]
['if (c->flags & REDIS_BLOCK)', 1]
['/* Try to detect printf format */', 1]
['_bkt_count++;                                                     \\', 1]
['nchan_complex_value_arr_t       pubsub_chid;', 1]
['/* When compiled with -DHASH_EMIT_KEYS, length-prefixed keys are emitted to', 1]
['bool cmp_read_float(cmp_ctx_t *ctx, float *f);', 1]
['//message first', 1]
['value: ["http", "websocket"],', 1]
['static ngx_int_t parse_multi_id(ngx_str_t *id, ngx_str_t ids[]) {', 1]
['/* Helper function for the redisAppendCommand* family of functions.', 1]
['obj->as.str_size = be16(obj->as.u16);', 1]
['if exists or (not exists and num > 0) then', 1]
['self->bulk_post_subscribe_privdata = privdata;', 1]
['sdsfree(vector[*argc]);', 1]
['msg.buf=buf;', 1]
['if((rc = longpoll_multimsg_add(fsub, msg, &err)) != NGX_OK) {', 1]
['should be checked after creation to see if there were errors creating the connection.', 1]
['evcf = &evcf_data;', 1]
['struct cmp_ctx_s;', 1]
['rev = c->read;', 1]
['struct pollfd   wfd[1];', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "OUTPUT:" fmt, ##arg)', 1]
['//input:  keys: [], values: [channel_id, msg_time, msg_tag, no_msgid_order, create_channel_ttl, subscriber_channel]', 1]
['[:loc_conf, :max_messages],', 1]
['DBG("IPC: publish message generic callback");', 1]
['} redis_get_message_data_t;', 1]
['head->internal_sub_count=0;', 1]
['case 1: _mur_k1 ^= _mur_tail[0];                                   \\', 1]
['@echo "WARNING: if this fails under Linux you probably need to install libc6-dev-i386"', 1]
['//spl->prev_msg_id.time=0;', 1]
['+ ( (unsigned)_hj_key[6] << 16 )                                         \\', 1]
['msg->rsv = NULL;', 1]
['if (!ctx->read(ctx, &obj->as.s64, sizeof(int64_t))) {', 1]
['bc[1].chain.next = &bc[2].chain;', 1]
['nginx-source', 1]
['"---" CRLF', 1]
['anymsg.time = 0;', 1]
['spl->bulk_dequeue_handler(spl, type, count, spl->bulk_dequeue_handler_privdata);', 1]
['if(len > 512) {', 1]
['if ((context == NULL) || (*context == NULL) || (*context)->err) {', 1]
['u_char       *password;', 1]
['head->multi = NULL;', 1]
['#define SDS_MAX_PREALLOC (1024*1024)', 1]
['obj->as.boolean = true;', 1]
['anymsg.tagcount = 1;', 1]
['### Sending commands', 1]
['//notify subscriber', 1]
['_mur_tail = (const uint8_t*)(_mur_data + _mur_nblocks*4);            \\', 1]
['*  The command replied with an error. The error string can be accessed identical to `REDIS_REPLY_STATUS`.', 1]
['/* Read until there is a reply */', 1]
['args: 0..5,', 1]
['content_type->data = (u_char *)(content_type+1);', 1]
['l2 = sdslen((const sds)key2);', 1]
['msg.time= Time.now.utc.to_i unless msg.time', 1]
['#define HASH_MUR(key,keylen,num_bkts,hashv,bkt)                        \\', 1]
['double_newline_buf.memory = 1;', 1]
['s = sdsMakeRoomFor(s,len-curlen);', 1]
['ngx_int_t            sender;', 1]
['reply = redisvCommand(c,format,ap);', 1]
['static void *createStringObject(const redisReadTask *task, char *str, size_t len);', 1]
['obj->as.s16 = be16(obj->as.s16);', 1]
['static ngx_str_t *str_shm_copy(ngx_str_t *str){', 1]
['int redisFreeKeepFd(redisContext *c);', 1]
['ngx_int_t longpoll_enqueue(subscriber_t *self);', 1]
['if (ac->onDisconnect && (c->flags & REDIS_CONNECTED)) {', 1]
['rp->count++;', 1]
['if (uv_poll_init(loop, &p->handle, c->fd) != 0) {', 1]
['bool cmp_object_is_float(cmp_object_t *obj) {', 1]
['*synchronous API*, the *asynchronous API* and the *reply parsing API*.', 1]
['const int _mur_nblocks = (keylen) / 4;                               \\', 1]
['if (! (_hs_q) ) break;                                         \\', 1]
['#else                   /* VS2008 or older (or VS2010 in C mode) */', 1]
['nchan_llist_timed_t             *chanhead_cleanup_head;', 1]
['ttl= tonumber(ARGV[6]),', 1]
['ngx_http_complex_value(r, cv, &tmpid);', 1]
['return DICT_ERR; /* not found */', 1]
['d->channel_id.data = (u_char *)&d[1];', 1]
['tags2 = id2->tag.allocd;', 1]
['static  nchan_msg_id_t      newest_msgid = NCHAN_NEWEST_MSGID;', 1]
['tmp_etag = msgid_to_str(msgid);', 1]
['ngx_int_t nchan_request_set_content_type_multipart_boundary_header(ngx_http_request_t *r, nchan_request_ctx_t *ctx) {', 1]
['if (ac->onConnect) ac->onConnect(ac,REDIS_OK);', 1]
['DBG("REDIS: PUB/SUB subscribed to %s (%i total)", reply->element[1]->str, reply->element[2]->integer);', 1]
['int pos = 0;', 1]
['legacy: [ "push_max_message_buffer_length", "push_message_buffer_length" ],', 1]
['nchan_msg_t                   *msg;', 1]
['lcf->max_channel_id_length=NGX_CONF_UNSET;', 1]
['define REDIS_TEST_CONFIG', 1]
['return cmp_write_bin32(ctx, data, size);', 1]
['size += ngx_buf_size(chains[2].buf);', 1]
['if (redisSetTcpNoDelay(c) != REDIS_OK)', 1]
['assert(reply->element[1]->type == REDIS_REPLY_STRING);', 1]
['def ==(m)', 1]
['r = createReplyObject(REDIS_REPLY_NIL);', 1]
['ngx_connection_t                       *c;', 1]
['#ifndef __HIREDIS_ASYNC_H', 1]
['cur = id[n_out].data;', 1]
['alt_err.len=err->len;', 1]
['of_next = of->next;', 1]
['local lasttime, lasttag = tonumber(lastmsg[1]), tonumber(lastmsg[2])', 1]
['DBG("tried publishing status %i msg with a NULL chanhead", status_code);', 1]
['DBG("%p subscriber respond with status (%p %V %i) %V", d->multi->sub, d->multi_chanhead, &d->multi_chanhead->id, d->n, &d->multi->id);', 1]
["//assume both were alloc'd fine", 1]
['dbg("NEXT MESSAGE NOT FOUND")', 1]
['extern const ngx_str_t NCHAN_CONTENT_TYPE_TEXT_PLAIN;', 1]
['static nchan_msg_id_t           id = NCHAN_ZERO_MSGID;', 1]
['if (header[i].key.len == header_name.len', 1]
['typedef struct redisCallbackList {', 1]
['sh->free = sh->free+(sh->len-len);', 1]
['nchan_request_ctx_t    *ctx;', 1]
['need to be binary safe, the entire array of lengths `argvlen` should be provided.', 1]
['head->shared->stored_message_count = 0;', 1]
['if ((str_size + 1) > *size) {', 1]
['node = (rc < 0) ? node->left : node->right;', 1]
['ngx_int_t nchan_thingcache_shutdown(void *tcv) {', 1]
['switch ( _hj_k ) {                                                             \\', 1]
['/* When the connection is being disconnected and there are', 1]
['config.tcp.timeout.tv_sec = 0;', 1]
['local bulk = {}', 1]
['DBG("send get_channel_info to %i %V", dst, chid);', 1]
['#define AUTH_COMMAND "AUTH %s"', 1]
['@time, @tag =@id.split(":")', 1]
['"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT', 1]
['case 404: //not found', 1]
['fsub->dequeue_handler = cb;', 1]
['content_type->len = msg->content_type.len;', 1]
['store_channel_head_shm_t  *chinfo = d->channel_info;', 1]
['ERR("serialized channel %p %V", rlch, chid);', 1]
['gprof:', 1]
['"local msg\\n"', 1]
['return false', 1]
['char *p = start;', 1]
['#define __HIREDIS_ASYNC_H', 1]
['/* HASH_FSCK checks hash integrity on every add/delete when HASH_DEBUG is defined.', 1]
['struct config cfg = {', 1]
['if ((connection->fd != NGX_INVALID_FILE)) {', 1]
['} redisContext;', 1]
['if (cbuf!=NULL) {', 1]
['if(ipc == NULL) {', 1]
['static ngx_int_t longpoll_dequeue(subscriber_t *self) {', 1]
['switch(spool->msg_status) {', 1]
["if (p[0] != '$') {", 1]
['if(compare == NULL) {', 1]
['else if(max_notready > 0){', 1]
['assert(ch);', 1]
['if (!write_type_marker(ctx, STR8_MARKER))', 1]
['bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s);', 1]
['if (redisBufferRead(c) == REDIS_ERR)', 1]
['if(lcf == NULL) {', 1]
['nchan_reaper_add(&mpt->chanhead_churner, ch);', 1]
['else if (type_marker == NIL_MARKER) {', 1]
['redisAsyncContext *redisAsyncConnectBind(const char *ip, int port, const char *source_addr);', 1]
['spool = &spl->current_msg_spool;', 1]
['/* make sure there is room for the next element and the final one */', 1]
['static ngx_int_t memstore_reap_store_message( store_message_t *smsg ) {', 1]
['sts = "STUBBED";', 1]
['redisReply_to_int(els[offset+4], (ngx_int_t *)&msg->prev_id.tag.fixed[0]);', 1]
['"chanhead churner",', 1]
['last_chain = &chains[3];', 1]
['proc->pipe[0]=NGX_INVALID_FILE;', 1]
['test_cond("sdsrange(...,100,100)",', 1]
['ssize_t             n;', 1]
['ngx_str_t  *delim = &cf->channel_id_split_delimiter;', 1]
['static int dictAdd(dict *ht, void *key, void *val) {', 1]
['if(spool != nuspool) {', 1]
['nchan_store_async_get_message(getmsg_chid, &req_msgid[i], (callback_pt )nchan_store_async_get_multi_message_callback, sd);', 1]
['typedef struct store_message_s store_message_t;', 1]
['if (shm_size < 8 * ngx_pagesize) {', 1]
['//gc if no subscribers', 1]
['cbuf->file->sys_offset=buf->file->sys_offset;', 1]
['if (node == &seed->sentinel) {', 1]
['int                             i, j, s = 0;', 1]
['#define IPC_PUBLISH_STATUS          7', 1]
['fsub->data.already_responded = 1;', 1]
['static dictIterator *dictGetIterator(dict *ht);', 1]
['if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {', 1]
['FIXSTR_SIZE          = 0x1F', 1]
['else if (type_marker == TRUE_MARKER) {', 1]
['r->buf = newbuf;', 1]
['bool cmp_object_as_float(cmp_object_t *obj, float *f);', 1]
['test_cond("sdscatprintf() seems working in the base case",', 1]
['nearly_departed[i]=tonumber(nearly_departed[i]) or 0', 1]
['static void receive_does_channel_exist(ngx_int_t sender, channel_existence_data_t *d) {', 1]
['if (i >= size)', 1]
['rev->eof = 1;', 1]
['"local unpacked\\n"', 1]
['sleep rand(0..1.1)', 1]
['#define HASH_BLOOM_MAKE(tbl)', 1]
['callback(NGX_OK, &chaninfo_copy, privdata);', 1]
['//r->request_body_no_buffering = 1;', 1]
['static void nchan_publisher_body_handler(ngx_http_request_t *r) {', 1]
['ipc_alert_t               alert;', 1]
['DBG("publish %V expire %i", msgid_to_str(&publish_msg->id), cf->buffer_timeout);', 1]
['int   l1, l2;', 1]
['if(msg->id.time == 0) {', 1]
['bc.chain.next=NULL;', 1]
['case SUB_CHANNEL_NOTSURE:', 1]
['if @@scripts', 1]
['//#define NCHAN_MSG_RESERVE_DEBUG 1', 1]
['bind 127.0.0.1', 1]
['test_cond("sdscmp(bar,bar)", sdscmp(x,y) < 0)', 1]
['of = proc->wbuf.overflow_first;', 1]
['assert(__redisShiftCallback(&ac->replies,NULL) == REDIS_ERR);', 1]
['bool cmp_object_is_array(cmp_object_t *obj);', 1]
['redisAsyncCommand(rds_ctx(), &get_msg_from_msgkey_callback, d, "EVALSHA %s 1 %b", store_rds_lua_hashes.get_message_from_key, STR(msg_redis_hash_key));', 1]
['ngx_int_t         shm_init(shmem_t *shm);', 1]
['*size = obj.as.bin_size;', 1]
['//need individual subscriber', 1]
['uint16_t ext_size;', 1]
['if (head.hh_head) { (head).hh_head->hh_prev = (addhh); }                        \\', 1]
['rdt.connect_url = &conf->redis_url;', 1]
['/* Instruct ngx_http_read_subscriber_request_body to store the request', 1]
['#define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                            \\', 1]
['buf->end++;', 1]
['head->oldest_msgid.tagcount = n;', 1]
['if(fsub->data.multimsg_first == NULL) {', 1]
['* write operation, "done" is set to 1 (if given).', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: context already attached");', 1]
['"f5935b801e6793759a44c9bf842812f2416dec34",', 1]
['ngx_int_t              (*dequeue)(struct subscriber_s *);', 1]
['ngx_rbtree_node_t     *node = rbtree_node_from_data(spool);', 1]
['if (processItem(r) != REDIS_OK)', 1]
['_mur_h1 ^= (keylen);                                                 \\', 1]
['first = proc->wbuf.first + proc->wbuf.n;', 1]
['//AUTOGENERATED, do not edit! see nchan_commands.rb', 1]
['/* Duplicate an sds string. */', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:WEBSOCKET:" fmt, ##arg)', 1]
['* a multi-character separator. For example', 1]
['nchan_redis_url [:main],', 1]
['y = sdscatrepr(sdsempty(),x,sdslen(x));', 1]
['"  redis.call(\'HSET\', key.channel, \'time\', msg.time)\\n"', 1]
['if(!cmp_read_uinteger(cmp, (uint64_t *)&msg->id.time)) {', 1]
['if(id1->time > 0 && id2->time > 0) {', 1]
['} while(i);', 1]
['static void ipc_try_close_fd(ngx_socket_t *fd) {', 1]
['+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +', 1]
['static ngx_inline void **thing_next_ptr(nchan_reaper_t *rp, void *thing) {', 1]
['he = ht->table[i];', 1]
['int16_t          tags[NCHAN_MULTITAG_MAX], prevtags[NCHAN_MULTITAG_MAX];', 1]
['assert(ch != NULL);', 1]
['if (!write_type_marker(ctx, ARRAY32_MARKER))', 1]
['//do nothing', 1]
['total_sz = sizeof(*stuff) + (buf_filename_size + content_type_size + eventsource_event_size +  buf_body_size);', 1]
['if(ngx_time() - alert.time_sent >= 2) {', 1]
['*d = (double)obj.as.flt;', 1]
['*type = obj->as.ext.type;', 1]
['publish_msg = shmsg_link->msg;', 1]
['ngx_int_t shm_init(shmem_t *shm) {', 1]
['unsigned count;', 1]
['rdt.cleanup_timer.data=NULL;', 1]
['if (ctx->write(ctx, data, 16))', 1]
['//////// SPOOLs -- Subscriber Pools  /////////', 1]
['if(next == NULL) {', 1]
['curarg = NULL;', 1]
['* **`REDIS_ERR_OTHER`**:', 1]
['HASH_EXPAND_BUCKETS((addhh)->tbl);                                        \\', 1]
['bool cmp_write_nfix(cmp_ctx_t *ctx, int8_t c) {', 1]
['typedef struct cmp_object_s {', 1]
['HASH_FSCK(hh_dst,dst);                                                         \\', 1]
['if((ctx = ngx_pcalloc(r->pool, sizeof(nchan_request_ctx_t))) == NULL) {', 1]
['void             *id = seed->id(rbtree_data_from_node(node));', 1]
['//TODO: set subscriber id', 1]
['* buffer to the socket and reads until it has a reply. In a non-blocking', 1]
['test_cond(c->err == REDIS_ERR_OTHER &&', 1]
['DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_q))) \\', 1]
['str.len =  15;', 1]
['void *(*createNil)(const redisReadTask*);', 1]
['{ ngx_string("push_message_buffer_length"), //legacy for nchan_message_buffer_length', 1]
['static void es_ensure_headers_sent(full_subscriber_t *fsub) {', 1]
['# Deps (use make dep to generate this)', 1]
['if (dictAdd(ht, key, val) == DICT_OK)', 1]
['mkdir -p $(INSTALL_INCLUDE_PATH) $(INSTALL_LIBRARY_PATH)', 1]
['ngx_msec_t            t;', 1]
['tbl->ideal_chain_maxlen;                 \\', 1]
['memstore_redis_subscriber_destroy(ch->redis_sub);', 1]
['redisAsyncContext *redisAsyncConnect(const char *ip, int port);', 1]
['body entirely in a memory buffer or in a file */', 1]
['sname = sdsnewlen(reply->element[1]->str,reply->element[1]->len);', 1]
['static int redisSetTcpNoDelay(redisContext *c) {', 1]
['connection = ngx_get_connection(c->fd, ngx_cycle->log);', 1]
['elsif status == 200', 1]
['DBG("gc_withdraw chanhead %V", &chanhead->id);', 1]
['evcf->channel_timeout = 30;', 1]
['"redis.call(\'PUBLISH\', channel_pubsub, pubmsg)\\n"', 1]
['static const ngx_str_t    empty=ngx_string("");', 1]
['static ngx_int_t internal_dequeue(subscriber_t *self) {', 1]
['#define CLOSE_PROTOCOL_ERROR         1002', 1]
['ngx_fd_t nchan_fdcache_get(ngx_str_t *filename) {', 1]
['msg->msg->id.tag.fixed[0] = ch->msg_last->msg->id.tag.fixed[0] + 1;', 1]
['size_t sz = sizeof(*src->tag.allocd) * src->tagcount;', 1]
['bool cmp_write_s64(cmp_ctx_t *ctx, int64_t l);', 1]
['* as the input pointer since no resize is needed. */', 1]
['INSTALL= cp -r', 1]
['#define NCHAN_DEFAULT_WEBSOCKET_PING_INTERVAL 0', 1]
['//when removed, said siblings will be notified via IPC', 1]
['ngx_int_t                    owner = chead->owner;', 1]
['nchan_msg_buf_open_fd_if_needed(buf, NULL, r);', 1]
['&& CHECK_REPLY_STR(els[offset+7])){ //eventsource event', 1]
['if(cf->eventsource_event.len > 0) {', 1]
['* The interval is inclusive, so the start and end characters will be part', 1]
['* ought to be encoded using UTF-8,', 1]
['muhtags[n] = d->msg->id.tag.fixed[0];', 1]
['subscriber_t                *ipc_sub;', 1]
['DBG("Spooler for channel %p %V wasn\'t running. start it.", head, &head->id);', 1]
['nchan_respond_status(r, status_code, status_line, 0);', 1]
['//retry', 1]
['eventsource_fn->enqueue = es_enqueue;', 1]
["channel=      'channel:'..id,", 1]
['cmp_ctx_t               cmp;', 1]
['if(chanhead == NULL) {', 1]
['typedef struct nchan_reloading_channel_s nchan_reloading_channel_t;', 1]
['"    msg.ttl or 0,\\n"', 1]
['--clear short-term subscriber list', 1]
['u_char                  *cur_out, *cur, *last, *ret;', 1]
['//validate_chanhead_messages(ch);', 1]
['full_subscriber_t    *fsub = (full_subscriber_t  *)self;', 1]
['char                *rc;', 1]
['//space for frame header', 1]
['ipc->process[i].active = 0;', 1]
['if (!write_type_marker(ctx, ARRAY16_MARKER))', 1]
['else if(qval_fp > 0) {', 1]
['void sdsrange(sds s, int start, int end);', 1]
['/* Returns the index of a free slot that can be populated with', 1]
['cl=&chanhead->cleanlink;', 1]
['clean:', 1]
['char bloom_nbits;', 1]
['nchan_subscriber_last_message_id,', 1]
['subscriber_t                   *redis_sub;', 1]
['while((*argc)--)', 1]
['void nchan_match_channel_info_subtype(size_t off, u_char *cur, size_t rem, u_char **priority, const ngx_str_t **format, ngx_str_t *content_type) {', 1]
['if (s > 1024 * 1024) {', 1]
['//ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0, "nchan: channel command: %d", ch.command);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:EVENTSOURCE:" fmt, ##arg)', 1]
['char *_hf_key=(char*)(key);                                                    \\', 1]
['if(ch->gc_time - ngx_time() > 0) {', 1]
['sub->destroy_after_dequeue = 0;', 1]
['if(cf->pub.websocket) {', 1]
['freeReplyObject', 1]
['static       subscriber_fn_t *chunked_fn = NULL;', 1]
['static ngx_int_t initialize_shm(ngx_shm_zone_t *zone, void *data) {', 1]
['//d->cb(NGX_HTTP_NOT_FOUND, NULL, d->cb_privdata);', 1]
['ngx_queue_t                     queue;', 1]
['HASH_ADD(hh,head,fieldname,keylen_in,add);                                     \\', 1]
['split++;', 1]
['s += stat->size;', 1]
['rc= nchan_output_filter(r, rchain);', 1]
['urnode->id.data = (u_char *)&urnode[1];', 1]
['(*last_chain)->next = &bc[0].chain;', 1]
['tags[i]=(val == 0 && sign == -1) ? -1 : val * sign; //shorthand "-" for "-1";', 1]
['/* iterate over items in a known bucket to find desired item */', 1]
['#define IPC_DATA_SIZE 56', 1]
['ngx_handle_write_event(c->write, 0);', 1]
['ngx_atomic_fetch_add(&msg->refcount, 1);', 1]
['static void reaper_timer_handler(ngx_event_t *ev);', 1]
['dbg("channel missing")', 1]
['"Max Error"', 1]
[':nchan_store_messages_directive,', 1]
['ipc_alert_t               alerts[IPC_WRITEBUF_SIZE];', 1]
['int redisFormatCommand(char **target, const char *format, ...) {', 1]
['ngx_del_timer(&rdt.cleanup_timer);', 1]
['static int dictAdd(dict *ht, void *key, void *val);', 1]
['static const subscriber_t new_websocket_sub;', 1]
['* sdscatprintf(sdsempty(),"%lld\\n", value);', 1]
['#define rbtree_data_from_node(node) ((void *)(&node[1]))', 1]
['ngx_slab_free_locked(SHPOOL(shm), p);', 1]
['} shmem_t;', 1]
['static void chunked_ensure_headers_sent(full_subscriber_t *fsub) {', 1]
['bool cmp_write_ext16(cmp_ctx_t *ctx, int8_t tp, uint16_t sz, const void *data) {', 1]
['pd->privdata = privdata;', 1]
['int                          n = alt_msgid_cv_arr->n;', 1]
['touched = 0;', 1]
['bool cmp_read_nfix(cmp_ctx_t *ctx, int8_t *c) {', 1]
['dir = compare_msgid_onetag_range(&data->min, &data->max, &spool->id);', 1]
['return {err="non-numeric status code given, bailing!"}', 1]
['static ngx_int_t websocket_publisher_upstream_handler(ngx_http_request_t *sr, void *data, ngx_int_t rc) {', 1]
['context is where Hiredis holds state for a connection. The `redisContext`', 1]
['/* Like sdscatpritf() but gets va_list instead of being variadic. */', 1]
['CMP_TYPE_EXT32,           /* 11 */', 1]
['static ngx_str_t          empty_line = ngx_string("");', 1]
['if(err) *err="WTF just happened to request?";', 1]
['void redis_nginx_force_close_context(redisAsyncContext **context);', 1]
['if (obj->as.u8 <= 127) {', 1]
['static unsigned long _dictNextPower(unsigned long size);', 1]
['#include <stddef.h>   /* ptrdiff_t */', 1]
['shdata->reloading = 0;', 1]
['[:loc_conf, :channel_group],', 1]
['shm->zone = zone;', 1]
['#define IPC_GET_CHANNEL_INFO        13', 1]
['class PubSubTest < Minitest::Test', 1]
['&internal_reserve,', 1]
['bool cmp_read_str_size(cmp_ctx_t *ctx, uint32_t *size) {', 1]
['if (head->status == INACTIVE) { //recycled chanhead', 1]
['ngx_str_t                      request_origin_header;', 1]
['void      (*create_main_conf)(ngx_conf_t *cf, nchan_main_conf_t *mcf);', 1]
['EOF', 1]
['memcpy(cmd+pos,argv[j],len);', 1]
['callbackHash,', 1]
['void                      *first;', 1]
['self.class.loadscripts', 1]
['"Error writing packed data",', 1]
['ac->ev.delWrite = redisLibeventDelWrite;', 1]
['ngx_rbtree_node_t *node = ngx_alloc(sizeof(ngx_rbtree_node_t) + data, ngx_cycle->log);', 1]
['spool->msg_status = MSG_PENDING;', 1]
['its_reaping_rotating_time(rp, 0);', 1]
['*size = obj->as.map_size;', 1]
['test("Returns I/O error when the connection is lost: ");', 1]
['nchan_longpoll_multimsg_t     *next;', 1]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_SNDTIMEO)");', 1]
['nchan_reaper_t                  chanhead_churner;', 1]
['//channel id variable', 1]
['if((whole = ngx_alloc(sizeof(*whole) + id->len, ngx_cycle->log)) == NULL) {', 1]
['nchan_store_channel_head_t  *head = d;', 1]
['//initialize storage engines', 1]
['if (c->error || c->timedout || c->close || c->destroyed || rev->closed || rev->eof) {', 1]
['{ ngx_string("nchan_channel_id"),', 1]
['return spooler_respond_generic(self, NULL, code, line);', 1]
['if(!first_chain) {', 1]
['fwd_buf(mpb, sz);', 1]
['val.data = cbuf;', 1]
['static ngx_int_t ipc_write_alert_fd(ngx_socket_t fd, ipc_alert_t *alert) {', 1]
['next->prev = cur->prev;', 1]
['char *get_message_from_key;', 1]
['// a newly restarted worker', 1]
['if (dummy_ctx) {', 1]
['//spl->want_to_stop = 0;', 1]
['for (i=0; i<NGX_MAX_PROCESSES; i++) {', 1]
['ngx_chain_t     chain;', 1]
['d = bedouble(d);', 1]
['bool cmp_object_is_bool(cmp_object_t *obj);', 1]
['#include "hiredis/hiredis.h"', 1]
['{ ngx_string("push_min_message_buffer_length"),', 1]
['alert->src_slot = ngx_process_slot;', 1]
['ch = nchan_store_get_chanhead(d->channel_id);', 1]
['if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {', 1]
['if((out = ngx_pcalloc(pool, sizeof(*out)))==NULL) {', 1]
['#ifndef uthash_fatal', 1]
['int16_t                 largetags[NCHAN_MULTITAG_MAX];', 1]
['bool cmp_read_fixext1_marker(cmp_ctx_t *ctx, int8_t *type);', 1]
['while((sep = ngx_strlchr(cur, last, NCHAN_MULTI_SEP_CHR)) != NULL) {', 1]
['DBG("UNSUBSCRIBING from channel:pubsub:%V", &ch->id);', 1]
['/* For the blocking context, flush output buffer and read reply */', 1]
['//ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "nchan: multiple buffers in request, need memcpy :(");', 1]
['#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                                   \\', 1]
['head->shared->total_message_count = 0;', 1]
['bc[1].buf.last_in_chain = 0;', 1]
['#    legacy: "push_subscriber_concurrency",', 1]
['//TODO: respond to all subscribers', 1]
['buf->end=pos;', 1]
['cur=reply->element[1];', 1]
['#include "dict.c"', 1]
['ngx_str_t        *shm_copy_immutable_string(shmem_t *shm, ngx_str_t *str);', 1]
['nchan_store_redis.subscribe(&head->id, head->redis_sub);', 1]
['void ngx_rwlock_init(ngx_rwlock_t *lock);', 1]
['int argc = 3;', 1]
['/* Called when the first write event was received. */', 1]
['char                  *err;', 1]
['if ( _hs_nmerges <= 1 ) {                                              \\', 1]
['if (!ctx->read(ctx, &obj->as.dbl, sizeof(double))) {', 1]
['set_buffer(&buf, frame->header, frame->last, 8);', 1]
['shdata->msgdebug_head->dbg_prev = msg;', 1]
['offsetof(nchan_loc_conf_t, authorize_request_url),', 1]
['list->tail->next = cb;', 1]
['"dbg(\' ######## SUBSCRIBER REGISTER SCRIPT ####### \')\\n"', 1]
['ht->table[h] = de->next;', 1]
['static void * nchan_create_main_conf(ngx_conf_t *cf) {', 1]
['if (ngx_handle_read_event(c->read, 0) != NGX_OK) {', 1]
['HASH_BLOOM_FREE((head)->hh.tbl);                                         \\', 1]
['/* Set newarg so it can be checked even if it is not touched. */', 1]
['if (newtokens == NULL) goto cleanup;', 1]
["/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */", 1]
['rbtree_init(&spl->spoolseed, "spooler msg_id tree", spool_rbtree_node_id, spool_rbtree_bucketer, spool_rbtree_compare);', 1]
['printf("SET: %s\\n", reply->str);', 1]
['ngx_memcpy(rbuffer, buffer, sizeof(*buffer));', 1]
['nchan_msg_t         *msg=NULL;', 1]
['static void receive_delete_reply(ngx_int_t sender, delete_data_t *d) {', 1]
['r->pos = r->len = 0;', 1]
['ngx_int_t nchan_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method, ngx_str_t *method_name, ngx_http_request_body_t *request_body, size_t content_length_n, u_char *content_len_str) {', 1]
['printf("\\t(%dx LRANGE with 500 elements: %.3fs)\\n", num, (t2-t1)/1000000.0);', 1]
['fseek(stream, fcur, SEEK_SET);', 1]
['LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR', 1]
['static ngx_int_t nchan_message_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['#define HASH_ADD_STR(head,strfield,add)                                          \\', 1]
['if time and time ~= 0 and tag then', 1]
['nchan_publisher_upstream_request [:srv, :loc, :if],', 1]
['//ngx_log_error(NGX_LOG_WARN, r->connection->log, 0, "nchan: the legacy $push_channel_id variable is not set");', 1]
['redis_nginx_event_attach(ac);', 1]
['//     redisCommandWithCallback(c,__test_reply_callback,(void*)1,"PING");', 1]
['return thing->data;', 1]
['unsigned                   destroy_after_dequeue:1;', 1]
['i /= 10;', 1]
['cur->prev = last;', 1]
['"    if found_msg_id == nil then\\n"', 1]
['ngx_memzero(frame, sizeof(*frame));', 1]
['publish msg', 1]
['eventsource_fn = &eventsource_fn_data;', 1]
['static ngx_inline void reaper_reset_timer(nchan_reaper_t *rp) {', 1]
['remsg.id.tagactive = d->n;', 1]
['if(cf->max_messages == 0) {', 1]
['static int dictReplace(dict *ht, void *key, void *val) {', 1]
['id=nil,', 1]
['case WEBSOCKET_OPCODE_PING:', 1]
['* note that if the old hash table is empty ht->size is zero,', 1]
['if(dt >= SLOW_REDIS_REPLY) {', 1]
['b->start = body->data;', 1]
['local id, time, tag, subscribe_if_current = ARGV[1], tonumber(ARGV[2]), tonumber(ARGV[3])', 1]
['alt_err.data=err->data;', 1]
['char *_ho_key=(char*)(key);                                                    \\', 1]
['* received up before setting this flag, so reset it here. */', 1]
['str=[]', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS_REPLY_STATUS  %s", reply->str);', 1]
['static ngx_int_t spool_fetch_msg(subscriber_pool_t *spool);', 1]
['#define uthash_expand_fyi(tbl)            /* can be defined to log expands   */', 1]
['static void redisLibuvCleanup(void *privdata) {', 1]
['while (argc) {', 1]
['redisLibuvAttach(c,loop);', 1]
['extern const ngx_str_t NCHAN_ANYSTRING;', 1]
['#define MUR_PLUS2_ALIGNED(p) (((unsigned long)p & 0x3) == 2)', 1]
['return NCHAN_MESSAGE_QUEUED;', 1]
['};// full_subscriber_t', 1]
['//sr->variables = ngx_pcalloc(sr->pool, cmcf->variables.nelts * sizeof(ngx_http_variable_value_t));', 1]
['ssize_t         n;', 1]
['nchan_msg_id_t          new_id = NCHAN_ZERO_MSGID;', 1]
['bool cmp_read_double(cmp_ctx_t *ctx, double *d);', 1]
['* **`REDIS_REPLY_ERROR`**:', 1]
['ngx_pool_t                  *tmp_pool;', 1]
['oldid->tag.allocd = ngx_alloc(sz, ngx_cycle->log);', 1]
['local pubmsg = "status:"..code', 1]
['nchan_store_channel_head_t   *cur, *tmp;', 1]
['u_char              buf_sha1[21];', 1]
['/* Execute disconnect callback. When redisAsyncFree() initiated destroying', 1]
['ev_io_start(EV_A_ &e->wev);', 1]
['#define dictFreeEntryVal(ht, entry) \\', 1]
['//ngx_chain_t                  link;', 1]
['head->owner = head->slot; //multis are always self-owned', 1]
['len = redisFormatCommand(&cmd,"SET %s %s","foo","bar");', 1]
['+ ( (unsigned)_hj_key[7] << 24 ) );                                      \\', 1]
['ac->ev.addWrite = NULL;', 1]
['bc[2].buf.last_in_chain = 0;', 1]
['static const u_char WEBSOCKET_TEXT_LAST_FRAME_BYTE =  WEBSOCKET_OPCODE_TEXT  | (WEBSOCKET_LAST_FRAME << 4);', 1]
['} sub;', 1]
['head->last_msgid.time=0;', 1]
['ngx_int_t (*delete_channel)(ngx_str_t *, callback_pt, void *);', 1]
['*reply = r->reply;', 1]
['ngx_int_t        sender;', 1]
['//ERR("  --- id2: %V --", msgid_to_str(id2));', 1]
['static size_t etag_maxlen(nchan_msg_id_t *id) {', 1]
['switch(reply->element[0]->integer) {', 1]
['uint8_t     error;', 1]
['UT_hash_bucket *_he_new_buckets, *_he_newbkt;                                \\', 1]
['return write_type_marker(ctx, FALSE_MARKER);', 1]
['bool cmp_write_ext32_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size);', 1]
['static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {', 1]
['if(len == 0) {', 1]
['{ ngx_string("nchan_subscriber_first_message"),', 1]
['muhtags = (d->multi_count > NCHAN_FIXED_MULTITAG_MAX) ? retmsg.id.tag.allocd : retmsg.id.tag.fixed;', 1]
['ngx_add_timer(ev, NCHAN_DEFAULT_CHANHEAD_CLEANUP_INTERVAL);', 1]
['channel.max_stored_messages = store_at_most_n_messages', 1]
['spool = get_spool(self, msgid);', 1]
['if (slots < elements+2) {', 1]
['ngx_conf_merge_bitmask_value(conf->sub.eventsource, prev->sub.eventsource, 0);', 1]
['if(ch->in_gc_queue) {', 1]
['//ngx_http_request_t          *sr;', 1]
['}                                                                 \\', 1]
['void                    *privdata;', 1]
['u_char *ret = buf->pos;', 1]
['switch(findmsg_status) {', 1]
['if (success) {', 1]
['ipc_process_t      *proc = &ipc->process[slot];', 1]
['return nchan_store_async_get_multi_message(channel_id, msg_id, callback, privdata);', 1]
['case RBTREE_WALK_LEFT:', 1]
['ac = redisAsyncConnect((const char *)host, port);', 1]
['unsigned                        longpoll:1;', 1]
['DBG("channel not for for get_channel_info");', 1]
['obj->type = CMP_TYPE_ARRAY32;', 1]
['ARRAY32_MARKER         = 0xDD,', 1]
['this list of conditions and the following disclaimer.', 1]
['if((sdata = ngx_alloc(sizeof(*sdata), ngx_cycle->log)) == NULL) {', 1]
['ERR("no callback given for async get_message. someone\'s using the API wrong!");', 1]
['assert(cur != prev);', 1]
['int redisReaderFeed(redisReader *r, const char *buf, size_t len) {', 1]
['cur->prev = tc->thing_tail;', 1]
['ngx_int_t nchan_memstore_force_delete_channel(ngx_str_t *channel_id, callback_pt callback, void *privdata) {', 1]
['pt=str->data;', 1]
['iter->index++;', 1]
['if(ngx_strnstr(accept_header->data, "multipart/mixed", accept_header->len)) {', 1]
['tags[0]=msg->id.tag.fixed[0];', 1]
['buf.temporary = 1;', 1]
['if (msec < 0 || msec > INT_MAX) {', 1]
['int                        count;', 1]
['if ((p = readLine(r,&len)) != NULL) {', 1]
['head->spooler.fn->handle_channel_status_change(&head->spooler);', 1]
['*d = obj.as.u64;', 1]
['bool cmp_object_is_sinteger(cmp_object_t *obj) {', 1]
['ngx_str_t                       id; //channel id', 1]
['void *privdata; /* user-settable arbitrary field */', 1]
['* and read some bytes from the socket and feed them to the reply parser.', 1]
['static void init_msg_buf(ngx_buf_t *buf);', 1]
['subdebug_head = next;', 1]
['if (c < 0x80) {', 1]
['ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err, "write() failed");', 1]
['self->add_handler(self, sub, self->add_handler_privdata);', 1]
['if (obj.as.u16 <= 32767) {', 1]
['{ ngx_string("push_message_timeout"), //legacy for nchan_message_timeout', 1]
['bc[1].buf.last_buf = 0;', 1]
['case 11: hashv += ( (unsigned)_hj_key[10] << 24 );                          \\', 1]
['default: "oldest",', 1]
['val=0;', 1]
['#define WEBSOCKET_STRINGS "websocket", "ws", "websockets"', 1]
['* But now we have improved things a bit by recognizing that b is', 1]
['static const ngx_str_t   hello = ngx_string(": hi\\n\\n");', 1]
['reply = redisCommand(c,"INCR mycounter");', 1]
['assert(data.shm_chid->data != NULL);', 1]
['time_t                 time = ngx_time();', 1]
['switch(frame->opcode) {', 1]
['ngx_module_t        nchan_module;', 1]
['dbg("channel.max_stored_messages was not set, but is now ", store_at_most_n_messages)', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_VARY, &NCHAN_VARY_HEADER_VALUE);', 1]
['rdt.chanhead_cleanup_head=cur;', 1]
['head->stub = 0;', 1]
['if (obj.type == CMP_TYPE_NIL)', 1]
['#endif /* __DICT_H */', 1]
["buf[buflen-2] = '\\0';", 1]
['bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size) {', 1]
['m->nobuffer_msg_reaper.max_notready_ratio = 0.20;', 1]
['int redisBufferWrite(redisContext *c, int *done);', 1]
['static char *nchan_set_sub_channel_id(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['/* Reads a signed integer that fits inside a signed int */', 1]
['#include <subscribers/memstore_redis.h>', 1]
['static void test_reply_reader(void) {', 1]
['U64_MARKER             = 0xCF,', 1]
['d->shared_channel_data = NULL;', 1]
['b -= c; b -= a; b ^= ( a << 8 );                                               \\', 1]
['msg_release(d->d.resp.shm_msg, "get_message_reply");', 1]
['return 7 * id->multi_count;', 1]
["local ntime, ntag, prev_time, prev_tag, ndata, ncontenttype, neventsource_event=unpack(redis.call('HMGET', key.next_message, 'time', 'tag', 'prev_time', 'prev_tag', 'data', 'content_type', 'eventsource_event'))", 1]
['DBG("not found in %s %p", tc->name, tc);', 1]
['subscriber_t *http_chunked_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id) {', 1]
['nchan_msg_id_t               msg_id;', 1]
['msg.channel_info=channel_info', 1]
['nchan_memstore_publish_generic(chead, NULL, d->status_code, d->status_line);', 1]
['nchan_msg_id_t                  id;', 1]
['static rbtree_seed_t  uniq_rsp_seed;', 1]
['"      return\\n"', 1]
['bool cmp_object_is_ext(cmp_object_t *obj) {', 1]
['"return cur\\n",', 1]
['DBG("%p release for req %p, reservations: %i", self, fsub->sub.request, self->reserved);', 1]
['b->flush = 1; //flush just to be sure, although I should perhaps rethink this', 1]
['redisAsyncCommand(rds_ctx(), &redisPublishCallback, (void *)d, "EVALSHA %s 0 %b %i %b %b %b %i %i", store_rds_lua_hashes.publish, STR(channel_id), msg->id.time, msgstart, msglen, STR(&(msg->content_type)), STR(&(msg->eventsource_event)), cf->buffer_timeout, cf->max_messages);', 1]
['free(ht);', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan thingcache %p: can\'t allocate memory for thing with id %V", tc, id);', 1]
['int            i;', 1]
['"local hmset = function (key, dict)\\n"', 1]
['if(cmp_read_str_size(&cmp, &sz)) {', 1]
['}; // nchan_msg_t', 1]
['if (replaced!=NULL) {                                                          \\', 1]
['if((chead = nchan_memstore_get_chanhead(channel_id, cf)) == NULL) {', 1]
['/////////// SUBSCRIBER KEEPALIVE ///////////', 1]
['assert(cur->idx < prv->elements);', 1]
['nchan_store_channel_head_t *nchan_memstore_get_chanhead(ngx_str_t *channel_id, nchan_loc_conf_t *cf) {', 1]
['p = charbuf;', 1]
['redisReply_to_int(els[offset+3], &time_int);', 1]
['redis_nginx_init(void)', 1]
['When any of the functions in the `redisCommand` family is called, Hiredis first formats the', 1]
['CMP_TYPE_BIN16,           /*  7 */', 1]
['sh->len = newlen;', 1]
['alt: [ :nchan_pub_channel_id ],', 1]
['fsub->data.timeout_handler = empty_handler;', 1]
['} dictEntry;', 1]
['_hd_hh_del->prev;                                            \\', 1]
['alt: ["nchan_message_max_buffer_length"],', 1]
['_hj_key += 12;                                                              \\', 1]
['//no more', 1]
["val = 10 * val + (c - '0');", 1]
['if (!(c->flags & REDIS_IN_CALLBACK))', 1]
['head->shared = NULL;', 1]
['shmem_t           *shm;', 1]
['ERR("couldn\'t allocate memstore-multi subscriber data");', 1]
['msg->expires = msg->id.time + cf->buffer_timeout;', 1]
['"--input:  keys: [], values: [channel_id, msg_time, msg_tag, no_msgid_order, create_channel_ttl]\\n"', 1]
['&internal_dequeue,', 1]
['el = reply->element[2];', 1]
['if (curarg != NULL)', 1]
['nchan_store_t              *store;', 1]
['list->tail = NULL;', 1]
['info: "Channel id for subscriber location. Can have up to 4 values to subscribe to up to 4 channels."', 1]
['ngx_str_t                     *publisher_type;', 1]
['ngx_int_t memstore_ipc_send_delete(ngx_int_t dst, ngx_str_t *chid, callback_pt callback,void *privdata) {', 1]
['int i, nonnegs = 0;', 1]
['return data->spools[--data->n];', 1]
['case NGX_ABORT:', 1]
['# Installation related variables and target', 1]
['"  message=      \'channel:msg:%s:\'..id, --not finished yet\\n"', 1]
['//debugging config', 1]
['ngx_int_t            (*respond_message)(channel_spooler_t *self, nchan_msg_t *msg);', 1]
['bool cmp_write_map32(cmp_ctx_t *ctx, uint32_t size);', 1]
['ngx_buf_t               hdr_buf;', 1]
['alert.code = code;', 1]
['return valid;', 1]
['last_chain = &chains[2];', 1]
['if(id1->time != id2->time || id1->tagcount != id2->tagcount) return 0;', 1]
['//     wdone = 0;', 1]
['"    msg.eventsource_event or \\"\\"\\n"', 1]
['return *thing_next_ptr(rp, thing);', 1]
['ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "nchan: error publishing message");', 1]
['subt->http_multipart=0;', 1]
['if msg_id==nil then', 1]
['memstore_fakeprocess_push(0);', 1]
['if(conf->sub_chid.n == 0) {', 1]
['dictEntry *entry;', 1]
['ngx_event_t                   *timer = ngx_pcalloc(r->pool, sizeof(*timer));', 1]
["redis.call('EXPIRE', key.channel, create_channel_ttl)", 1]
['ngx_int_t            (*set_bulk_dequeue_handler)(channel_spooler_t *, void (*cb)(channel_spooler_t *, subscriber_type_t, ngx_int_t, void*), void*);', 1]
['"    redis.call(\'EXPIRE\', chan_key, 5) --something small thing\\n"', 1]
['redisReaderFeed(reader,(char*)"+OK\\r",4);', 1]
['} else if (argc >= 2 && !strcmp(argv[0],"-p")) {', 1]
['int16_t       *tags;', 1]
["case '\\0':", 1]
['ERR("verify_msg_id: only the first message in a given second is ok. anything else means a missed message.");', 1]
['#define dictSetHashVal(ht, entry, _val_) do { \\', 1]
['if (size >= LONG_MAX) return LONG_MAX;', 1]
['return ctx->multipart_boundary;', 1]
['file->fd=NGX_INVALID_FILE;', 1]
['memstore_ipc_send_publish_message(owner, &chead->id, publish_msg, cf, callback, privdata);', 1]
['return sh->len;', 1]
['DBG("finalize request %p", fsub->sub.request);', 1]
['//no need to subscribe, but keep a connection open for publishing', 1]
['cur = ch->msg_last;', 1]
['char *t;', 1]
['shdata->procslot[i]=NCHAN_INVALID_SLOT;', 1]
['static ngx_str_t                POST_REQUEST_STRING = {4, (u_char *)"POST "};', 1]
['$(CC) -std=c99 -pedantic -c $(REAL_CFLAGS) $<', 1]
['ERR("can\'t get chanhead for id %V", ids[i]);', 1]
['static void memstore_reap_chanhead(nchan_store_channel_head_t *ch);', 1]
['if (x->tv_usec < y->tv_usec) {', 1]
['if(chanhead != NULL){', 1]
['if ((frame->payload = ngx_pcalloc(temp_pool, frame->payload_len)) == NULL) {', 1]
['(ht)->type->valDestructor((ht)->privdata, (entry)->val)', 1]
['unsigned                     meta:1;', 1]
['subscriber_t  *msub;', 1]
['NULL,                          /* create server configuration */', 1]
['ngx_log_error(NGX_LOG_ERR, (r)->connection->log, 0, "nchan: can\'t allocate msg in request pool");', 1]
['assert(msg->refcount == MSG_REFCOUNT_INVALID);', 1]
['if(rc == NGX_CONF_ERROR) {', 1]
['/* Calculate the number of bytes needed to represent an integer as string. */', 1]
['(head).hh_head = hh_del->hh_next;                                          \\', 1]
['* abort with an error, but simply ignore it because the client', 1]
['//ngx_log_debug2(NGX_LOG_DEBUG_HTTP, wev->log, 0, "http writer handler: \\"%V?%V\\"", &r->uri, &r->args);', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not delete write event to redis");', 1]
['bool cmp_write_object_v4(cmp_ctx_t *ctx, cmp_object_t *obj);', 1]
['* trying to get replies and wait for the next loop tick. */', 1]
["/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the", 1]
['case \'\\r\': s = sdscatlen(s,"\\\\r",2); break;', 1]
['def cquote(str)', 1]
['*i = obj->as.s8;', 1]
['static ngx_inline void rbtree_walk_real(rbtree_seed_t *seed, ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel, rbtree_walk_callback_pt callback, void *data) {', 1]
['if(generated_content_type) {', 1]
['Override the default behavior of using both `Last-Modified` and `Etag` headers for the message id.', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS_REPLY_INTEGER: %i", reply->integer);', 1]
['ngx_rbtree_debug_node_link_t   active;', 1]
['link->next = fakeprocess_top;', 1]
['bool cmp_write_bin_marker(cmp_ctx_t *ctx, uint32_t size);', 1]
['bc[3].buf.last_buf = 0;', 1]
['(hashv) = 0;                                                                   \\', 1]
['ngx_memcpy(&retmsg, d->msg, sizeof(retmsg));', 1]
['static       subscriber_fn_t *multipart_fn = NULL;', 1]
['#define HIREDIS_PATCH 0', 1]
['int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {', 1]
['if (ngx_utf8_decode(&p, n) > 0x10ffff) {', 1]
['wb->overflow_first = overflow;', 1]
['memstore_reap_chanhead(ch);', 1]
['hashv ^= (uint32_t)(_sfh_key[sizeof (uint16_t)] << 18);              \\', 1]
['#ifndef uthash_free', 1]
['ngx_int_t                       mmapped=0;', 1]
['if (aux == NULL && c->flags & REDIS_BLOCK) {', 1]
['d->pd = privdata;', 1]
['#define CHECK_REPLY_ARRAY_MIN_SIZE(reply, size) ( (reply)->type == REDIS_REPLY_ARRAY && (reply)->elements >= (unsigned )size )', 1]
['void                *cur, *next;', 1]
['e = assert_raises Redis::CommandError do', 1]
['assert(rp->count > 0);', 1]
['d = &static_subscribe_data;', 1]
['ngx_str_t *nchan_get_header_value(ngx_http_request_t * r, ngx_str_t header_name) {', 1]
['if(!databuf.in_file) {', 1]
['ngx_int_t rbtree_init(rbtree_seed_t *seed, char *name, void *(*id)(void *), uint32_t (*hash)(void *), ngx_int_t (*compare)(void *, void *));', 1]
['ngx_http_complex_value_t          **cv = &((nchan_loc_conf_t *)conf)->channel_events_channel_id;', 1]
['/* Not found. */', 1]
['p = eptr+1; /* char next to the first "." */', 1]
['extern const ngx_str_t NCHAN_HEADER_ETAG;', 1]
['messages  = channel->messages;', 1]
['status_line = &NCHAN_HTTP_STATUS_409;', 1]
['//output: current_subscribers', 1]
['bool cmp_write_nil(cmp_ctx_t *ctx) {', 1]
['if (!ctx->write(ctx, &size, sizeof(uint32_t))) {', 1]
['cur = copy_preallocated_str_to_cur(&msg->content_type, &m->content_type, cur);', 1]
['* should be terminated once all replies have been read. */', 1]
['hashv ^= (hashv >> 6);                                                     \\', 1]
['return ht;', 1]
['assert(n == sizeof(alert));', 1]
['typedef struct cmp_ctx_s {', 1]
['nchan_store_channel_head_t  *originator;', 1]
['if (!_he_new_buckets) { uthash_fatal( "out of memory"); }                    \\', 1]
['/* Regular command callbacks */', 1]
['"  redis.call(\'HSET\', key.channel, \'max_stored_messages\', store_at_most_n_messages)\\n"', 1]
['CMP_TYPE_STR32,           /* 29 */', 1]
['"--input: keys: [], values: [channel_id, subscriber_id, channel_empty_ttl, active_ttl, concurrency]\\n"', 1]
['NGX_MODULE_V1,', 1]
['DBG("%p wanted to fetch msg %V, but channel %V not ready", spool, msgid_to_str(&spool->id), spool->spooler->chid);', 1]
['ngx_str_t                          *value = &((ngx_str_t *) cf->args->elts)[1];', 1]
['ngx_str_t               msg_redis_hash_key = ngx_null_string;', 1]
['bool cmp_write_integer(cmp_ctx_t *ctx, int64_t d) {', 1]
['dictFreeEntryKey(ht,de);', 1]
['ERR("Neither dequeue_handler not bulk_dequeue_handler present in spooler for spool sub dequeue");', 1]
['return (fd > 0) && ((fcntl(fd, F_GETFL) != -1) || (errno != EBADF));', 1]
['#ifndef NCHAN_MODULE_H', 1]
["case 'c': case 'C': return 12;", 1]
['* hash handle that must be present in the structure. */', 1]
['else if (type_marker == FIXEXT1_MARKER) {', 1]
['bool cmp_read_ext32(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data);', 1]
['DBG("Get message from msgkey %V", msg_redis_hash_key);', 1]
['sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);', 1]
['/* Returns the MessagePack version employed by CMP */', 1]
['bool cmp_object_as_ulong(cmp_object_t *obj, uint64_t *u);', 1]
['len = snprintf(buf,size,"\\"%c\\"",byte);', 1]
['fsub->privdata = privdata;', 1]
['/* Context for a connection to Redis */', 1]
['name=v.first', 1]
['ngx_int_t                       owner;', 1]
['replaced=NULL;                                                                 \\', 1]
['void redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);', 1]
['newspool = !immortal_spool ? find_spool(spl, &new_id) : get_spool(spl, &new_id);', 1]
['ac->ev.cleanup = NULL;', 1]
['fsub->data.holding = 1;', 1]
['#define NGX_POOL_PID_FORMAT     "pid:%P\\n"', 1]
['unsigned expand_mult;', 1]
['if(ngx_strncmp(reply->str, hash, REDIS_LUA_HASH_LENGTH)!=0) {', 1]
['int val = 1;', 1]
['nchan_auth_subrequest_stuff_t *psr_stuff = ngx_palloc(sub->request->pool, sizeof(*psr_stuff));', 1]
['f->respond_status(status_code, (void *)status_line, f->privdata);', 1]
['HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt],_dst_hh);            \\', 1]
['//building for old versions', 1]
['//cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);', 1]
['callback_pt             respond_message;', 1]
['cmt=l.match /^--(.*)/', 1]
['"memstore nobuffer message",', 1]
['memstore_pub_debug_end();', 1]
['ngx_int_t internal_subscriber_set_respond_message_handler(subscriber_t *sub, callback_pt handler);', 1]
['else if(ngx_strmatch(&alerttype, "unsub all") && array_sz > 1) {', 1]
['* When using %b you need to provide both the pointer to the string', 1]
['hdr_buf->last_buf=0;', 1]
['buf->last = ngx_copy(buf->start, chain->buf->pos, len);', 1]
['redisEchoCallback(c,r,privdata);', 1]
['return cmp_write_ext16(ctx, tp, sz, data);', 1]
['spooler_respond_data_t     srdata;', 1]
['bool cmp_write_object(cmp_ctx_t *ctx, cmp_object_t *obj);', 1]
['"  msgpacked = cmsgpack.pack(unpacked)\\n"', 1]
['return dictExpand(ht, DICT_HT_INITIAL_SIZE);', 1]
['static ngx_int_t nchan_process_legacy_channel_id(ngx_http_request_t *r, nchan_loc_conf_t *cf, ngx_str_t **ret_id) {', 1]
['if(node) {', 1]
['redis_nginx_del_read(privdata);', 1]
['static ngx_int_t delete_multi_callback_handler(ngx_int_t code, nchan_channel_t* chinfo, delete_multi_data_t *d) {', 1]
['#define SELECT_DATABASE_COMMAND "SELECT %d"', 1]
['rd.subscribers = ch->subscribers;', 1]
["//use the shitty-ass LFSR-based ngx_random. we're not looking for cryptographic randomness,", 1]
['if(nchan_shm_zone && nchan_shm_zone->shm.size != shm_size) {', 1]
['ngx_memcpy(&head->channel.id, &head->id, sizeof(ngx_str_t));', 1]
['while(de) {', 1]
['* **`REDIS_ERR_EOF`**:', 1]
['msg_debug_add(msg);', 1]
['{ ngx_string("nchan_publisher_type"),     nchan_publisher_type_variable, 0},', 1]
['callbacks have been executed. After this, the disconnection callback is executed with the', 1]
['content_type_len=els[offset+6]->len;', 1]
['#define FLOAT_WIDTH_TEST(type) do {                                                       \\', 1]
['bc->chain.next = NULL;', 1]
['if (r->str != NULL)', 1]
['ngx_int_t nchan_respond_status(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *status_line, ngx_int_t finalize);', 1]
['u_char   *match;', 1]
['def test_publish', 1]
['if(self->cf->websocket_ping_interval > 0) {', 1]
['ngx_str_t                    upstream_request_url;', 1]
['DBG("multi[%i] of %i msg FOUND %V %p", sd->n, d->multi_count, msgid_to_str(&msg->id), msg);', 1]
['#define CLOSE_NORMAL                 1000', 1]
['if(shdata->old_max_workers == NCHAN_INVALID_SLOT) {', 1]
['//too small to have a qvalue, not followed by a space. must be "chunkedsomething"', 1]
['bool cmp_object_as_bool(cmp_object_t *obj, bool *b) {', 1]
["//we're probably reloading or something", 1]
['ERR("ws request pool size: %V", ngx_http_debug_pool_str(fsub->sub.request->pool));', 1]
['{ ngx_string("nchan_access_control_allow_origin"),', 1]
['cf.use_redis = chanhead->use_redis;', 1]
['if(nchan_detect_websocket_request(r)) {', 1]
['if (obj.type != CMP_TYPE_EXT32) {', 1]
['fsub->enqueue = empty_callback;', 1]
['ngx_rbtree_node_t    *cur, *sentinel;', 1]
['char **vector = NULL;', 1]
['h->value.len = ngx_sprintf(h->value.data, "%O", len) - h->value.data;', 1]
['* data in chunks instead of a single shot.', 1]
['size_t                      sz = 0, grouplen = group->len;', 1]
['def self.luac', 1]
['/* Add the last argument if needed */', 1]
['subscriber_debug_assert_isempty();', 1]
['assert(shmsg_link != NULL);', 1]
['while (len--)', 1]
['deleted_count++;', 1]
['cf->storage_engine->find_channel(channel_id, (callback_pt) &channel_info_callback, (void *)r);', 1]
['* error that occured. REDIS_ERR_IO means there was an I/O error and you', 1]
["redis.call('EXPIRE', key.channel, channel.ttl)", 1]
['cur = ngx_cpymem(cur, "\\r\\nLast-Modified: ", sizeof("\\r\\nLast-Modified: ") - 1);', 1]
['#define cmp_write_sint     cmp_write_integer', 1]
['psrd->cln->data = fsub;', 1]
['ngx_buf_t         *buf = msg->buf;', 1]
['*integer=ngx_atoi((u_char *)el->str, el->len);', 1]
['"    local arg, cur = {...}, nil\\n"', 1]
['srdata.max = msg->id;', 1]
['/* API */', 1]
['* return the reply. In a non-blocking context, it is identical to calling', 1]
['reply = redisCommand(c,"SET %b %b","foo",(size_t)3,"hello\\x00world",(size_t)11);', 1]
['static char *nchan_set_storage_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['dictFreeEntryVal(ht, &auxentry);', 1]
['"local sub_count = 0\\n"', 1]
['assert(active_before - n == 0);', 1]
['lcf->subscriber_start_at_oldest_message = 0;', 1]
['ngx_int_t            (*handle_channel_status_change)(channel_spooler_t *self);', 1]
['if(msg->id.time < d->msg->id.time) {', 1]
['{ ngx_string("nchan_channel_group"),', 1]
['bc.buf.start = cbuf;', 1]
['"local messages=   \'channel:messages:\'..id\\n"', 1]
['channel_spooler_t               spooler;', 1]
['nchan_publisher_body_handler_continued(r, channel_id, cf);', 1]
['the `err` field in the context will be set (see section on **Errors**).', 1]
['"    for i = 1, #arg do\\n"', 1]
['DBG("stopped %i spools in SPOOLER %p", n, *spl);', 1]
['redisReply_to_int(els[offset+2], (ngx_int_t *)&msg->id.tag.fixed[0]); // tag is a uint, meh.', 1]
['lastid = &d->chanhead->latest_msgid;', 1]
['ngx_int_t nchan_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method, ngx_str_t *method_name, ngx_http_request_body_t *request_body, size_t content_length_n, u_char *content_len_str);', 1]
["s[len] = '\\0';", 1]
['/* The nil object can always be created. */', 1]
['static ngx_int_t spool_respond_general(subscriber_pool_t *self, nchan_msg_t *msg, ngx_int_t status_code, const ngx_str_t *status_line);', 1]
['"  return redis.call(\'HMSET\', key, unpack(bulk))\\n"', 1]
['shdata->rlch = NULL;', 1]
['ngx_rbtree_node_t *rbtree_find_node(rbtree_seed_t *seed, void *id) {', 1]
['DBG("%p set dequeue handler data to %p", self, cb);', 1]
['_p++;', 1]
['#include <nchan_setup.c>', 1]
['exit:', 1]
['if(chid_conf->n > 0) {', 1]
['{ ngx_string("nchan_subscriber"),', 1]
['/* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */', 1]
["if (_p[0] == 'l' && _p[1] == 'l') {", 1]
['seed->id = id;', 1]
['nchan_store_redis_connection_close_handler(ac);', 1]
['// DBG("CREATED spool node %p for msgid %V", node, msgid_to_str(id));', 1]
['#endif  /*SPOOL_HEADER*/', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "can\'t allocate redis publish callback data");', 1]
['d->cb(d->msg_status, NULL, d->privdata);', 1]
['rc = nchan_process_legacy_channel_id(r, cf, &id);', 1]
['/* Forward declaration of function in hiredis.c */', 1]
['//         redisProcessCallbacks(c);', 1]
['ac->ev.delRead = redisLibeventDelRead;', 1]
['"messages: %ui" CRLF', 1]
['bool cmp_read_u16(cmp_ctx_t *ctx, uint16_t *s) {', 1]
['DBG("REDIS: PUB/SUB unsubscribed from %s (%i total)", reply->element[1]->str, reply->element[2]->integer);', 1]
['tc->thing_tail->next = cur;', 1]
['bool cmp_read_s8(cmp_ctx_t *ctx, int8_t *c);', 1]
['extern nchan_store_t  nchan_store_redis;', 1]
['databuf.file = msg_file;', 1]
['ngx_int_t nchan_respond_status(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *status_line, ngx_int_t finalize) {', 1]
['#define REDIS_ERR -1', 1]
["if (0 != 0) { //TODO: check the subscriber's id", 1]
['//meh, this message has already been delivered probably hopefully', 1]
['bool cmp_object_as_double(cmp_object_t *obj, double *d);', 1]
['if not channel.max_stored_messages then', 1]
['if code==nil then', 1]
['int cmp;', 1]
['extern subscriber_t *internal_subscriber_create(ngx_str_t *, void *privdata);', 1]
['get_multi_message_data_t   *d = sd->d;', 1]
['static void __redisAsyncCopyError(redisAsyncContext *ac) {', 1]
['//static subscribe_data_t        static_subscribe_data;', 1]
['ngx_int_t       n;', 1]
['return first;', 1]
['if(*first_chain == NULL) {', 1]
['stop_spooler(&ch->spooler, 1);', 1]
['publish_data_t  *d;', 1]
['"    return i==1 and id or \\"DENY\\"\\n"', 1]
[':nchan_set_storage_engine,', 1]
['if (!cmp_write_bin32_marker(ctx, size))', 1]
['case SUB_DEQUEUE:', 1]
['static ngx_str_t evt_chan_delete = ngx_string("channel_delete");', 1]
['/* Get the new element index */', 1]
['if((chead = nchan_memstore_get_chanhead(chid, NULL)) != NULL) {', 1]
['ngx_memzero(&lcf->pubsub_chid, sizeof(nchan_complex_value_arr_t));', 1]
['char *errstr;', 1]
['if (newtags[i] != -1) {', 1]
['ngx_buf_t     buf;', 1]
['//assert(rbtree_find_node(seed, seed->id(rbtree_data_from_node(node))) == NULL);', 1]
['*p++ = itoa64[ngx_random() % 64];', 1]
['cb->fn(ac,reply,cb->privdata);', 1]
['//DBG("we got data %V", &msg_in_str);', 1]
['assert(msg_reserve(d->d.resp.shm_msg, "get_message_reply") == NGX_OK);', 1]
['/* State for the protocol parser */', 1]
['test("Format command with literal %%: ");', 1]
['if(ctx) return ctx;', 1]
['void   *prev;', 1]
['return cmp_write_u8(ctx, u);', 1]
['* Write the **entire** output buffer to the socket', 1]
['# Platform-specific overrides', 1]
["if redis.call('EXISTS', chan_key) == 1 then", 1]
['lcf->sub.poll=0;', 1]
['else if(timcur == timmax && timcur == timmin) {', 1]
['assert(msg->dbg_prev == NULL);', 1]
['static void ipc_read_handler(ngx_event_t *ev);', 1]
['int16_t  *oldtags = oldid->tagcount <= NCHAN_FIXED_MULTITAG_MAX ? oldid->tag.fixed : oldid->tag.allocd;', 1]
['if (node) {', 1]
['static const u_char WEBSOCKET_PAYLOAD_LEN_64_BYTE = 127;', 1]
['DBG("send SUBSCRIBER KEEPALIVE to %i %V", dst, chid);', 1]
['nchan_loc_conf_t cf;', 1]
['ngx_memcpy(&bc[1].buf, msg_buf, sizeof(*msg_buf));', 1]
['r->request_body_in_clean_file = 0;', 1]
['const uint32_t *_mur_blocks = (const uint32_t*)(_mur_data+_mur_nblocks*4); \\', 1]
['cfg.tcp.port = atoi(argv[0]);', 1]
['ngx_event_t                timer;', 1]
['tried_count = 0;', 1]
['ngx_int_t              rev_count = count;', 1]
['static const ngx_str_t    STATUS_500=ngx_string("500 Internal Server Error");', 1]
['while (_hs_looping) {                                                      \\', 1]
['store_message_t               *msg = NULL;', 1]
['__redisSetErrorFromErrno(c, REDIS_ERR_IO, "poll(2)");', 1]
['return mp_version;', 1]
['timer->log = d->sub->request->connection->log;', 1]
['bool cmp_read_ext(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data);', 1]
['* number of allowed connections on the server side.', 1]
['/* Return 1 if result is negative. */', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "IPC:" fmt, ##args)', 1]
['switch(channel_status) {', 1]
['#define REDIS_DISCONNECTING 0x4', 1]
['DBG("prev: %V", msgid_to_str(&msg->prev_id));', 1]
['d->multi->sub = sub;', 1]
['"  msg.prev_time = 0\\n"', 1]
['* data in chunks instead of a single shot.  This avoids using the STR8', 1]
['* NULL if there was an error in performing the request, otherwise it will', 1]
['nchan_subscriber_channel_id [:srv, :loc, :if],', 1]
['#ifdef HASH_FUNCTION', 1]
['if (!write_type_marker(ctx, EXT8_MARKER))', 1]
['cbuf->memory=ngx_buf_in_memory_only(buf) ? 1 : 0;', 1]
['memstore_ipc_send_publish_status(d->originator, d->chid, status, status_line, empty_callback, NULL);', 1]
['return {err=("Message for channel %s id %s already exists"):format(id, msg.id)}', 1]
['ngx_list_part_t                 *part;', 1]
['internal_subscriber_t               *fsub;', 1]
['multipart_fn->respond_status = multipart_respond_status;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan Redis lua script %s has unexpected hash %s (expected %s)", (*names)[i], reply->str, hash);', 1]
['DYLIB_MAJOR_NAME=$(LIBNAME).$(HIREDIS_MAJOR).$(DYLIBSUFFIX)', 1]
['if(head->shared){', 1]
['DYLIBSUFFIX=so', 1]
['hashv += hashv >> 17;                                                \\', 1]
['bool cmp_read_integer(cmp_ctx_t *ctx, int64_t *d) {', 1]
['websocket_init_frame(&fsub->frame);', 1]
['*     0 if s1 and s2 are exactly the same binary string.', 1]
['static ngx_int_t publish_multi_callback(ngx_int_t status, void *rptr, void *privdata) {', 1]
['typedef struct{', 1]
['void msg_debug_add(nchan_msg_t *msg) {', 1]
['redisAppendCommand(context,"GET foo");', 1]
['#include <stdio.h> /* for size_t */', 1]
['if (!ctx->write(ctx, &size, sizeof(uint16_t))) {', 1]
['#define uthash_free(ptr,sz) free(ptr)     /* free fcn                        */', 1]
['--output: current_subscribers', 1]
['forbidden:', 1]
['if (r->headers_in.headers.last == &r->headers_in.headers.part) {', 1]
['//TODO: some kind of missed-message check maybe?', 1]
['(add)->hh.key = (char*)(keyptr);                                                \\', 1]
['} channel_event_type_t;', 1]
['static void redisChannelInfoCallback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['void *nchan_thingcache_find(void *tcv, ngx_str_t *id);', 1]
['ngx_memcpy(urnode->smallmsg.data, msg->buf->start, msglen);', 1]
['bool cmp_object_is_long(cmp_object_t *obj);', 1]
['*d = obj.as.u32;', 1]
['msgid = msgid_to_str(&ctx->prev_msg_id);', 1]
['ngx_int_t internal_subscriber_set_name(subscriber_t *self, ngx_str_t *name) {', 1]
['ngx_event_t             ping_ev;', 1]
['assert(old_shared == d->shared_channel_data);', 1]
['return *thing_prev_ptr(rp, thing);', 1]
["* followed by a \\n. Note that strchr cannot be used because it doesn't", 1]
['nchan_loc_conf_t   *cf = ngx_http_get_module_loc_conf(r, nchan_module);', 1]
['nchan_ws_llink_destroy((nchan_llist_timed_t *)privdata);', 1]
['DBG("chanhead %p (%V) is empty and expired. delete.", ch, &ch->id);', 1]
['//unable to allocate multipart boundary;', 1]
['"   or not channel.current_message then\\n"', 1]
['ngx_http_finalize_request(r, NGX_HTTP_NO_CONTENT);', 1]
['bc.buf.pos = bc.buf.start;', 1]
['nchan_store_redis_fakesub_add(&head->id, 1);', 1]
['assert_equal sent[2], cur', 1]
['} spooler_respond_generic_data_t;', 1]
['### Using replies', 1]
['sub_create = intervalpoll_subscriber_create;', 1]
['assert(match == cur);', 1]
['static ngx_int_t spooler_set_dequeue_handler(channel_spooler_t *self, void (*handler)(channel_spooler_t *, subscriber_t *, void*), void *privdata) {', 1]
['typedef ngx_int_t (*callback_pt)(ngx_int_t, void *, void *);', 1]
['dict *ht = malloc(sizeof(*ht));', 1]
['assert(rc == NGX_OK);', 1]
['"local del_msgpack =cmsgpack.pack({\\"alert\\", \\"delete channel\\", id})\\n"', 1]
['static ngx_int_t longpoll_set_dequeue_callback(subscriber_t *self, subscriber_callback_pt cb, void *privdata) {', 1]
['* Writes the extended type marker to the backend.  This is useful if you want', 1]
['time_t          msg_time;', 1]
['struct timeval timeout;', 1]
['ngx_memset(smsg, 0xBC, sizeof(*smsg)); //debug stuff', 1]
['if(memstore_channel_owner(d->shm_chid) == memstore_slot()) {', 1]
['for(rcur = r; rcur != NULL; rcur = rcur->parent) {', 1]
['#define HASH_FSCK(hh,head)', 1]
['s = seekNewline(p,r->len-r->pos);', 1]
['return write_fixed_value(ctx, FIXARRAY_MARKER | size);', 1]
['spl->bulk_dequeue_handler(spl, sub->type, 1, spl->bulk_dequeue_handler_privdata);', 1]
['redisContext *c = connect(config);', 1]
['bool cmp_read_nil(cmp_ctx_t *ctx) {', 1]
['bool cmp_object_as_short(cmp_object_t *obj, int16_t *s) {', 1]
['int is_hex_digit(char c) {', 1]
['e = (redisLibevEvents*)malloc(sizeof(*e));', 1]
['sdsfree(curargv[j]);', 1]
['rc = ngx_conf_set_flag_slot(cf, cmd, conf);', 1]
['void *key;', 1]
['void             *shm_alloc(shmem_t *shm, size_t size, const char *label);', 1]
['test_cond(redisContext == NULL);', 1]
['head->shared->sub_count = 0;', 1]
['//ngx_int_t http_chunked_subscriber_destroy(subscriber_t *sub);', 1]
['* of the resulting string.', 1]
['spl->running = 1;', 1]
['chain->buf=b;', 1]
['void *next;                       /* next element in app order      */', 1]
['/* Position should be < len-1 because the character at "pos" should be', 1]
['ch->msg_last = msg;', 1]
['static ngx_int_t redis_subscriber_unregister(ngx_str_t *channel_id, subscriber_t *sub) {', 1]
['sub->type = INTERVALPOLL;', 1]
['shm_free(nchan_memstore_get_shm(), d->shm_channel_info);', 1]
['nchan_auth_subrequest_data_t *d = ev->data;', 1]
['static int  flood_seq = 0;', 1]
['head = nchan_memstore_get_chanhead(d->shm_chid, &cf);', 1]
['"  redis.call(\'EXPIRE\', key.messages, channel.ttl)\\n"', 1]
['void nchan_websocket_publisher_llist_init() {', 1]
['argv[1] = "foo\\0xxx";', 1]
['FIXMAP_MARKER          = 0x80,', 1]
['if (x->tv_usec - y->tv_usec > 1000000) {', 1]
['nchan_channel_t                 channel;', 1]
['/* Compute the key hash value */', 1]
['The specifier `%s` interpolates a string in the command, and uses `strlen` to', 1]
['return 1+intlen(len)+2+len+2;', 1]
['char *_hs_key=(char*)(key);                                                    \\', 1]
['databuf.pos = cur;', 1]
['#include "nchan_output.h"', 1]
['ngx_buf_t                       channel_info_buf;', 1]
['store_message_t           *prev;', 1]
['nginx', 1]
['/* skip blanks */', 1]
['REAL_CFLAGS=$(OPTIMIZATION) -fPIC $(CFLAGS) $(WARNINGS) $(DEBUG) $(ARCH)', 1]
['ngx_int_t nchan_reaper_withdraw(nchan_reaper_t *rp, void *thing);', 1]
['memstore_data_t *mpt = &mdata;', 1]
['if(d->msg) msg_release(d->msg, "get multi msg");', 1]
['#define CLOSE_GOING_AWAY             1001', 1]
['unsigned _fn_i;                                                                \\', 1]
['newlen += SDS_MAX_PREALLOC;', 1]
['DBG("multi[%i] of %i msg EXPECTED", sd->n, d->multi_count);', 1]
['ngx_uint_t             ttl;', 1]
['if @data && @time.nil?', 1]
['if(chanhead != NULL && cmp_to_msg(&cmp, &msg, &buf)) {', 1]
[':nchan_publisher_directive,', 1]
['ch[3]=ch[4]', 1]
['if (status_code == NGX_HTTP_CREATED) {', 1]
['rsv=shm_locked_calloc(shm, sizeof(*rsv) + ngx_strlen(lbl) + 1, "msgdebug");', 1]
['while(argc--)', 1]
['bool cmp_object_as_array(cmp_object_t *obj, uint32_t *size);', 1]
['static nchan_msg_id_t zero_msgid = NCHAN_ZERO_MSGID;', 1]
['assert(shdata->msgdebug_head->dbg_prev == NULL);', 1]
['data.shared_channel_data = NULL;', 1]
['*u = obj->as.u16;', 1]
["If the reply for a command with a `NULL` callback is read, it is immediately free'd. When the callback", 1]
['if (buf == NULL) return NULL;', 1]
['!memcmp(reply->element[0]->element[0]->str,"bar",3) &&', 1]
["sub_count = redis.call('hincrby', keys.channel, 'subscribers', -1)", 1]
['shdata->max_workers = NGX_CONF_UNSET;', 1]
['[:loc_conf, :max_channel_id_length],', 1]
['if(cur->prev) {', 1]
['1. The input buffer is non-empty:', 1]
['else if (type_marker == STR32_MARKER) {', 1]
['CMP_TYPE_FIXARRAY,        /*  2 */', 1]
['ngx_http_complex_value(r, publisher_upstream_request_url_ccv, &publisher_upstream_request_url);', 1]
['refute msg, "message should be absent"', 1]
['Setting the disconnect callback can only be done once per context. For subsequent calls it will', 1]
['static ngx_int_t es_respond_message(subscriber_t *sub,  nchan_msg_t *msg) {', 1]
['def tag=(t)', 1]
['if(prev != NULL && next != NULL) {', 1]
['ngx_int_t memstore_ipc_send_publish_message(ngx_int_t dst, ngx_str_t *chid, nchan_msg_t *shm_msg, nchan_loc_conf_t *cf, callback_pt callback, void *privdata);', 1]
['static ngx_int_t chunked_respond_status(subscriber_t *sub, ngx_int_t status_code, const ngx_str_t *status_line){', 1]
['local msg', 1]
['if (err) {', 1]
['attr_accessor :data, :chid, :time, :tag, :id, :content_type, :channel_info, :ttl', 1]
['/* Free the async context. When this function is called from a callback,', 1]
['DBG("IPC: received publish reply");', 1]
['} else if (nwritten > 0) {', 1]
['unsigned ideal_chain_maxlen;', 1]
['#define INTEGER_WIDTH_TEST(fmt, type) do {                                                \\', 1]
['"  for i = 1, #ch do\\n"', 1]
['fwd_buf_to_str(&mpbuf, sz, &chid);', 1]
['head->spooler.fn->set_bulk_post_subscribe_handler(&head->spooler, spooler_bulk_post_subscribe_handler, NULL);', 1]
['DBG("%p (%V) timeout", fsub, fsub->sub.name);', 1]
['ERR("can\'t allocate multi tag array for multi-channel %p", head);', 1]
['if(thing == NULL) {', 1]
['"    return\\n"', 1]
['static int _dictInit(dict *ht, dictType *type, void *privDataPtr);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:MULTIPART:" fmt, ##arg)', 1]
['* received and passed to the callback. */', 1]
['// delete this channel and all its messages', 1]
['msgid = &ch->last_published_msg_id;', 1]
['thing->data = tc->create(id);', 1]
['if(code == NCHAN_SUB_MULTI_NOTIFY_ADDSUB) {', 1]
['bool cmp_write_bin32(cmp_ctx_t *ctx, const void *data, uint32_t size);', 1]
['/* key comparison function; return 0 if keys equal */', 1]
['+(uint32_t)(((const uint8_t *)(d))[0]) )', 1]
['int redisGetReply(redisContext *c, void **reply);', 1]
['#define _EL_DEL_WRITE(ctx) do { \\', 1]
['void *(*keyDup)(void *privdata, const void *key);', 1]
['} dict;', 1]
['if (nwritten == (signed)sdslen(c->obuf)) {', 1]
["redis.call('EXPIRE', chan_key, 5) --something small thing", 1]
['head->oldest_msgid.tag.allocd = ngx_alloc(sizeof(*head->oldest_msgid.tag.allocd) * n, ngx_cycle->log);', 1]
['for(_fn_i=0; _fn_i < keylen; _fn_i++)                                          \\', 1]
['_hs_list = &((head)->hh);                                                  \\', 1]
['/* Handle read/write events */', 1]
["case 'n': c = '\\n'; break;", 1]
['bc.buf.pos = cbuf;', 1]
['head->channel.subscribers = head->shared->sub_count;', 1]
['void memstore_fakeprocess_push(ngx_int_t slot) {', 1]
['bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {', 1]
['fakebody_buf = ngx_palloc(r->pool, sizeof(*fakebody_buf));', 1]
['unsigned                        temp_allocd:1;', 1]
['ngx_int_t         shm_destroy(shmem_t *shm);', 1]
['ngx_buf_t               mpbuf;', 1]
['assert(id->tagcount == 1);', 1]
['rd.messages = ch->messages;', 1]
['redisReply           *reply = r;', 1]
['ngx_memcpy(d->channel_id.data, channel_id->data, channel_id->len);', 1]
['nchan_llist_timed_t    *cur, *last;', 1]
['value: ["websocket", "eventsource", "longpoll", "intervalpoll", "chunked", "multipart-mixed"],', 1]
['* lengths. If the latter is set to NULL, strlen will be used to compute the', 1]
['CMP_TYPE_FIXEXT16,        /* 26 */', 1]
['{ ngx_string("nchan_subscriber_compound_etag_message_id"),', 1]
['if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {', 1]
['nchan_channel_t            chan;', 1]
['//static ngx_int_t empty_callback() {', 1]
['int redisCheckSocketError(redisContext *c);', 1]
['"  redis.call(\'HSET\', key.channel, \'prev_message\', msg.prev)\\n"', 1]
['if((tmp = nchan_get_header_value(r, NCHAN_HEADER_SEC_WEBSOCKET_VERSION)) == NULL) {', 1]
['sds sdsnew(const char *init);', 1]
['"  redis.call(\'PUBLISH\', channel_key, del_msgpack)\\n"', 1]
['else if(max_notready > 0) {', 1]
['ngx_str_t                   *chid;', 1]
["redis.call('HSET', key.channel, 'current_message', msg.id)", 1]
['case NGX_HTTP_FORBIDDEN:', 1]
['bool cmp_write_fixext2_marker(cmp_ctx_t *ctx, int8_t type);', 1]
['redisAppendCommand(c,"LRANGE mylist 0 499");', 1]
["for k,channel_key in pairs(redis.call('SMEMBERS', subscribers)) do", 1]
['static ngx_int_t websocket_dequeue(subscriber_t *self) {', 1]
['bool cmp_read_ufix(cmp_ctx_t *ctx, uint8_t *c);', 1]
['def delete(ch_id)', 1]
['h->hash = 1;', 1]
['d->multi_count = n;', 1]
['redisAsyncCommand(rds_sub_ctx(), NULL, NULL, "UNSUBSCRIBE channel:pubsub:%b", STR(&ch->id));', 1]
['m.each do |msg|', 1]
['#define CMP_H__', 1]
['if(chunked_fn == NULL) {', 1]
['ngx_int_t rbtree_conditional_walk(rbtree_seed_t *seed, rbtree_walk_conditional_callback_pt callback, void *data) {', 1]
['static ngx_int_t chanhead_messages_gc(nchan_store_channel_head_t *ch);', 1]
['if((nchan_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, cycle->log))==NULL) {', 1]
['if(head->sub_count == 0 && head->foreign_owner_ipc_sub == NULL) {', 1]
['bool cmp_write_s32(cmp_ctx_t *ctx, int32_t i) {', 1]
['nchan_llist_timed_t          cleanlink;', 1]
['int redisReaderGetReply(redisReader *reader, void **reply);', 1]
['coverage: gcov', 1]
['if (r->ridx == 0) {', 1]
['else if (type_marker == S16_MARKER) {', 1]
['free(he);', 1]
['//DBG("pop fakeprocess to return to %i", (ngx_int_t)next->data);', 1]
['rbtree_walk_direction_t    direction;', 1]
['cur = (u_char *)&blob[1];', 1]
["while(*c != '\\0') {", 1]
['uint8_t type_marker = 0;', 1]
['DBG("reap %s again later (remaining: %i)", rp->name, rp->count);', 1]
['unsigned _hj_i,_hj_j,_hj_k;                                                    \\', 1]
['INTEGER_WIDTH_TEST("hhu", unsigned char);', 1]
['ngx_memzero(&glob->timer, sizeof(glob->timer));', 1]
['(tbl)->bloom_sig = HASH_BLOOM_SIGNATURE;                                       \\', 1]
['0, //deque after response', 1]
['redisReplyObjectFunctions *fn;', 1]
['ngx_int_t                       n;', 1]
['else if(head->shared == NULL) {', 1]
["if (*_p != '\\0' && *_p == '0') _p++;", 1]
['fclose(stream);', 1]
['ngx_http_finalize_request(r->parent, NGX_HTTP_FORBIDDEN);', 1]
['ccv.value = str;', 1]
['/* Default set of functions to build the reply. Keep in mind that such a', 1]
['subscriber_t *http_multipart_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id);', 1]
['* If the key already exists, -1 is returned. */', 1]
['sub_keepalive_data_t        data = {str_shm_copy(chid), sub, ch, 0, callback, privdata};', 1]
['Enabling this option packs the entire message id into the `Etag` header, and discards', 1]
['if(!firstmoved) firstmoved = cur;', 1]
['Redis may reply with nested arrays but this is fully supported.', 1]
['test("Don\'t fail when redisFree is passed a NULL value: ");', 1]
['extern const ngx_str_t NCHAN_HEADER_CONNECTION;', 1]
['if(!nchan_strmatch(val, 1, "broadcast")) {', 1]
['//static analyzer pointed this out. This is a damn unlikely condition, but', 1]
['_hs_insize *= 2;                                                       \\', 1]
['//not sposed to happen', 1]
['count = 0;', 1]
['if(id1->time == 0 && id2->time == 0) return 0; //always equal on zero-time', 1]
['redisAsyncCommand(rds_ctx(), &redisCheckErrorCallback, NULL, "EVALSHA %s 0 %b %i %i", store_rds_lua_hashes.subscriber_unregister, STR(channel_id), 0/*TODO: sub->id*/, cf->channel_timeout);', 1]
['//ERR("id1 equals id2. 0");', 1]
['chaninfo.last_seen = ch->shared->last_seen;', 1]
['assert(head->shared != NULL);', 1]
['if (cmd == NULL) goto err;', 1]
['compare = &rbtree_compare_str;', 1]
['bool cmp_write_str16(cmp_ctx_t *ctx, const char *data, uint16_t size);', 1]
['msg2_data = "what is this i don\'t even"', 1]
['nchan_max_reserved_memory [:main],', 1]
['def e.backtrace; []; end', 1]
['extern const ngx_str_t NCHAN_CHANNEL_INFO_PLAIN;', 1]
['"local msg={\\n"', 1]
['redisCallbackFn *fn;', 1]
['static       subscriber_fn_t  eventsource_fn_data;', 1]
['} sub_data_t;', 1]
['void ngx_rwlock_release_write(ngx_rwlock_t *lock);', 1]
['psr->handler = subscriber_authorize_callback;', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "VARIABLES:" fmt, ##arg)', 1]
['fprintf(stderr, "Invalid argument: %s\\n", argv[0]);', 1]
['assert(min->tagcount == max->tagcount);', 1]
['cd->d = (publish_data_t *)&cd[1];', 1]
['if(rdt.chanhead_cleanup_tail==cl)', 1]
['else if( timcur > timmin && timcur < timmax) {', 1]
['ngx_int_t           workers = ccf->worker_processes;', 1]
['for l in script.lines do', 1]
['#    group: "pubsub",', 1]
['static ngx_int_t publish_message_generic_callback(ngx_int_t status, void *rptr, void *privdata) {', 1]
['bool cmp_write_false(cmp_ctx_t *ctx);', 1]
['extern const ngx_str_t NCHAN_HEADER_SEC_WEBSOCKET_VERSION;', 1]
['const  ngx_str_t NCHAN_HEADER_ALLOW_HEADERS = ngx_string("Access-Control-Allow-Headers");', 1]
['void verify_reaper_list(nchan_reaper_t *rp, void *thing);', 1]
['fd = ngx_open_file(fname, NGX_FILE_RDONLY, NGX_FILE_OPEN, NGX_FILE_OWNER_ACCESS);', 1]
['str.data = body->start;', 1]
['* non-subscribe mode. */', 1]
['//just one message.', 1]
['* if the specified length is smaller than the current length, no operation', 1]
['void sdsIncrLen(sds s, int incr) {', 1]
['//     while(!wdone) {', 1]
['static const u_char WEBSOCKET_PAYLOAD_LEN_16_BYTE = 126;', 1]
['static ngx_uint_t                nchan_content_length_hash = 0;', 1]
['while(cur != NULL && notready <= max_notready) {', 1]
['static char *ngx_conf_enable_redis(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['msg->refcount = MSG_REFCOUNT_INVALID;', 1]
['bc = ngx_palloc(pool, sizeof(*bc));', 1]
['/* Event library data and hooks */', 1]
['} resp;', 1]
['ERR("couldn\'t add subscriber to spool %p", spool);', 1]
['/* We want the error field to be accessible directly instead of requiring', 1]
['} else if (s > 1024) {', 1]
['for(cur=rdt.chanhead_cleanup_head; cur != NULL; cur=next) {', 1]
['ac->sub.invalid.tail = NULL;', 1]
['printf("Database #9 is not empty, test can not continue\\n");', 1]
['"  if next(msg) == nil then -- no such message. it might\'ve expired, or maybe it was never there\\n"', 1]
['dictFreeEntryKey(ht, he);', 1]
['size_t sdslen(const sds s);', 1]
["for k,channel_key in pairs(redis.call('SMEMBERS', subs_key)) do", 1]
['static void sudden_upstream_request_abort_handler(full_subscriber_t *fsub) {', 1]
['static const ngx_str_t   everything_ok = ngx_string("200 OK");', 1]
['case 3: hashv += get16bits (_sfh_key);                                       \\', 1]
['msgpacked = cmsgpack.pack(unpacked)', 1]
['unsigned    i;', 1]
['bkt = hashv & (num_bkts-1);                                          \\', 1]
['* socketpairs are unusable for our purposes (as of nginx 0.8 -- check the', 1]
['boundary[i].last_buf = 1;', 1]
['nchan_expand_msg_id_multi_tag(&remsg.prev_id, 0, d->n, -1);', 1]
['glob->timer.cancelable = 1;', 1]
['bool cmp_write_fixext1_marker(cmp_ctx_t *ctx, int8_t type);', 1]
['x = sdsMakeRoomFor(x,1);', 1]
['next=cur->next;', 1]
['bool cmp_read_ext(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data) {', 1]
['bool cmp_read_fixext4(cmp_ctx_t *ctx, int8_t *type, void *data);', 1]
['"if concurrency == \\"FILO\\" then\\n"', 1]
['//     __test_callback_flags = 0;', 1]
["`REDIS_OK` status and the context object is free'd.", 1]
['nchan_store_publish_generic(&chid, NULL, NGX_HTTP_GONE, &NCHAN_HTTP_STATUS_410);', 1]
['ngx_int_t internal_subscriber_set_enqueue_handler(subscriber_t *sub, callback_pt handler) {', 1]
['ngx_fd_t fd = buf->file->fd == NGX_INVALID_FILE ? nchan_fdcache_get(&buf->file->name) : buf->file->fd;', 1]
['DBG("not yet time to reap %V, %i sec left", &ch->id, ch->churn_time - ngx_time());', 1]
['ERR("Couldn\'t allocate ngx buf or chain.");', 1]
['u_char           *cur = first;', 1]
['push_subscriber_concurrency [:srv, :loc, :if],', 1]
['channel_existence_data_t        data = {str_shm_copy(chid), 0, callback, privdata};', 1]
["} else if (*s == '+') {", 1]
['#define HASH_FIND_PTR(head,findptr,out)                                          \\', 1]
['the response of type `REDIS_REPLY_STATUS` then the `str` field of `redisReply`', 1]
['#define __SDS_H', 1]
['spool_respond_general(&self->current_msg_spool, data.msg, data.code, data.line);', 1]
['bytelen = s-(r->buf+r->pos)+2; /* include \\r\\n */', 1]
['sh = calloc(sizeof *sh+initlen+1,1);', 1]
['evcf->storage_engine->publish(id, &msg, evcf, NULL, NULL);', 1]
['test("Returns error when the unix socket path doesn\'t accept connections: ");', 1]
['ngx_atomic_int_t                sub_count;', 1]
['while ((_hs_psize > 0) || ((_hs_qsize > 0) && _hs_q )) {           \\', 1]
['#define WEBSOCKET_STRINGS_N 3', 1]
['void redisReaderFree(redisReader *r) {', 1]
['assert_equal sent[0], cur', 1]
['(sizeof(*buf) +                                                              \\', 1]
['#define __HIREDIS_LIBUV_H__', 1]
['#define dictHashKey(ht, key) (ht)->type->hashFunction(key)', 1]
['nchan_channel_info(r, messages, subscribers, last_seen, msgid);', 1]
['(((buf)->temporary || (buf)->memory) ? ngx_buf_size(buf) : 0) +              \\', 1]
['n.used = ht->used;', 1]
['if(i <= NCHAN_FIXED_MULTITAG_MAX) {', 1]
['"    dbg(\\"MESSAGE NOT FOUND\\")\\n"', 1]
['fsub->ping_ev.cancelable = 1;', 1]
['DBG("find next message %V", msgid_to_str(msgid));', 1]
['+-+-+-+-+-------+-+-------------+-------------------------------+', 1]
['max = (ngx_int_t *) (p + offsetof(nchan_loc_conf_t, max_messages));', 1]
['/* Write a formatted command to the output buffer. Use these functions in blocking mode', 1]
['bc[2].buf.last = bc[2].buf.end;', 1]
['ERR("Can\'t allocate spooler");', 1]
['or, for VS2008 where neither is available, uses casting workarounds. */', 1]
['assert(publish_msg->id.time != publish_msg->prev_id.time || ( publish_msg->id.time == publish_msg->prev_id.time && publish_msg->id.tag.fixed[0] != publish_msg->prev_id.tag.fixed[0]));', 1]
['id = randid', 1]
['if (pr == NULL) {', 1]
['ngx_conf_log_error(NGX_LOG_WARN, cf, 0, "The push_max_reserved_memory value must be at least %udKiB", (8 * ngx_pagesize) >> 10);', 1]
['tags_latest = head->latest_msgid.tag.fixed;', 1]
['if num==nil then', 1]
['if(priority) {', 1]
['"subscriber_register",', 1]
['} redisReplyObjectFunctions;', 1]
['#define HASH_FIND(hh,head,keyptr,keylen,out)                                     \\', 1]
['uint32_t cmp_mp_version(void);', 1]
['r->headers_out.status = NGX_HTTP_SWITCHING_PROTOCOLS;', 1]
['/* Even if the context is subscribed, pending regular callbacks will', 1]
['* bytes after the end of the string, plus one more byte for nul term.', 1]
['proc->wbuf.n++;', 1]
['info: "Channel id where `nchan_channel_id`\'s events should be sent. Events like subscriber enqueue/dequeue, publishing messages, etc. Useful for application debugging. The channel event message is configurable via nchan_channel_event_string. The channel group for events is hardcoded to \'meta\'."', 1]
['chanhead->spooler.fn->handle_channel_status_change(&chanhead->spooler);', 1]
['#define __HIREDIS_AE_H__', 1]
['__redisShiftCallback(&ac->sub.invalid,dstcb);', 1]
['retmsg.id.tagcount = d->multi_count;', 1]
['"local channel_pubsub = \'channel:pubsub:\'..id\\n"', 1]
['#ifndef NGX_HTTP_CREATED', 1]
['init_msg_buf(msg_buf);', 1]
['{ ngx_string("nchan_message_timeout"),', 1]
['LONGPOLL,', 1]
['int idx; /* index in parent (array) object */', 1]
['size = strlen(arg);', 1]
['void              shmtx_unlock(shmem_t *shm);', 1]
['#define AF_LOCAL AF_UNIX', 1]
['ngx_str_t      first_choice_msgid = ngx_string("$http_last_event_id");', 1]
['struct sdshdr {', 1]
["/* Proceed with free'ing when redisAsyncFree() was called. */", 1]
['ngx_int_t          rsv_found=0;', 1]
['nchan_reaper_t                  msg_reaper;', 1]
['* This function is useful when the sds string is hacked manually in some', 1]
['r->pool = d->original_pool;', 1]
['tc->destroy = destroy;', 1]
['shm_free(shm, msg);', 1]
['ngx_free(glob);', 1]
['self->first = next;', 1]
['* server closes the connection after sending it.', 1]
['static int dictReplace(dict *ht, void *key, void *val);', 1]
['ch->in_gc_queue = 1;', 1]
['if(CHECK_REPLY_ARRAY_MIN_SIZE(r, offset + 7)', 1]
['seed->active_nodes--;', 1]
['#define HTTP_CHUNKED_STRINGS_N 2', 1]
['|| defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)', 1]
['ngx_int_t ipc_alert(ipc_t *ipc, ngx_int_t slot, ngx_uint_t code, void *data, size_t data_size) {', 1]
['tc->create = create;', 1]
['if (u <= 0x7F)', 1]
['HASH_DELETE(hh,head,delptr)', 1]
['max = msg->id.tagcount;', 1]
['_dictClear(ht);', 1]
['u_char                    *lbl;', 1]
['MAP_LENGTH_TOO_LONG_ERROR,', 1]
['ERR("missed a message for an unknown reason. Maybe it\'s a bug or maybe the message queue length is too small.");', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "rwlock %p mutex wait", lock);', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDISTORE: " fmt, ##args)', 1]
['c = redisConnectFd(fd);', 1]
['memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */', 1]
['ngx_rbtree_debug_node_link_t   allocd;', 1]
['#define HASH_OVERHEAD(hh,head)                                                   \\', 1]
['/* Flag specific to the async API which means that the context should be clean', 1]
['if(want[i]) {', 1]
['size_t totlen, curlen = sh->len;', 1]
['*integer=el->integer;', 1]
['"  next_message= \'channel:msg:%s:\'..id, --hash\\n"', 1]
['DBG("sub %p dequeue callback", sub);', 1]
['rc = ngx_http_complex_value_noalloc(r, alt_msgid_cv_arr->cv[i], &str, 128);', 1]
['unit = (u_char *) " B";', 1]
['nchan_msg_t                 *cur;', 1]
['size_t sdsAllocSize(sds s);', 1]
['u_char                    msgbuf[50];', 1]
['size_t pos; /* Buffer cursor */', 1]
['//got nonzero qval. accept', 1]
['char *start, *end, *sp, *ep;', 1]
['#define CHECK_REPLY_NIL(reply) ((reply)->type == REDIS_REPLY_NIL)', 1]
['* they are added into the new hash through a secondary hash', 1]
['list->tail = cb;', 1]
['#include <nginx.h>', 1]
['(UT_hash_handle*)((ptrdiff_t)((delptr)->hh.prev) +               \\', 1]
['nchan_pub_upstream_data_t     *psrd = &psr_stuff->psr_data;', 1]
['srdata.msg = msg;', 1]
['"-- This script has gotten big and ugly, but there are a few good reasons \\n"', 1]
["if(buf->temporary || buf->memory) { //we don't want to copy mmpapped memory, so no ngx_buf_in_momory(buf)", 1]
['#define NGX_HTTP_CREATED 201', 1]
['double    dbl;', 1]
['ch->id.data=NULL;', 1]
['int redisGetReplyFromReader(redisContext *c, void **reply) {', 1]
['int             i;', 1]
['&websocket_release,', 1]
['DEBUG_MEMZERO(&rd);', 1]
['next = thing_next(rp, thing);', 1]
['info: "The length of time a subscriber\'s long-polling connection can last before it\'s timed out. If you don\'t want subscriber\'s connection to timeout, set this to 0. Applicable only if a `nchan_subscriber` is present in this or a child context."', 1]
['static void str_shm_free(ngx_str_t *str) {', 1]
['return ctx->write(ctx, &c, sizeof(uint8_t));', 1]
["redis.call('DEL', key_msg:format(msg))", 1]
['fsub->dequeue_handler(&fsub->sub, fsub->dequeue_handler_data);', 1]
['unless @@redis', 1]
['(head)->hh.tbl = (UT_hash_table*)uthash_malloc(                                \\', 1]
['static store_message_t *create_shared_message(nchan_msg_t *m, ngx_int_t msg_already_in_shm) {', 1]
['/* Disconnects and frees the context */', 1]
['- clang', 1]
['params->db = ngx_atoi(cur, last-cur);', 1]
['//  ctx->channel_id[i] = empty_string;', 1]
['# Fallback to gcc when $CC is not in $PATH.', 1]
['"get_message_from_key",', 1]
['if (status != REDIS_OK)', 1]
['DBG("wrote alert at %i", i % IPC_WRITEBUF_SIZE);', 1]
['ngx_pool_cleanup_file_t        *clnf = NULL;', 1]
['HASH_FSCK(hh,head);                                                             \\', 1]
['if(pool != NULL && (content_type = ngx_palloc(pool, sizeof(*content_type) + msg->content_type.len))==NULL) {', 1]
['temp = *p;', 1]
['returns. This behavior will probably change in future releases, so make sure to', 1]
["/* Make sure we're on DB 9. */", 1]
["c->errstr[0] = '\\0';", 1]
['if (tbl->ineff_expands > 1) {                                                \\', 1]
['typedef struct ipc_writebuf_s ipc_writebuf_t;', 1]
['totlen = 1+intlen(argc)+2;', 1]
['*cd->d = *d;', 1]
['typedef struct ipc_s ipc_t;', 1]
['char *obuf; /* Write buffer */', 1]
['psrd->sub = sub;', 1]
['assert(ch->last_published_msg_id.tagcount == 1);', 1]
['static int callbackKeyCompare(void *privdata, const void *key1, const void *key2) {', 1]
['assert_equal sent[1], cur', 1]
['subscriber_t       sub;', 1]
['redisAsyncCommand(c, &redis_load_script_callback, (void *)i, "SCRIPT LOAD %s", (*scripts)[i]);', 1]
["/* This is an adaptation of Simon Tatham's O(n log(n)) mergesort */", 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "MEMSTORE:%02i: " fmt, memstore_slot(), ##args)', 1]
['sh->free = sh->free-len;', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:MEM-MULTI:" fmt, ##arg)', 1]
['extern const  ngx_str_t NCHAN_HTTP_STATUS_410;', 1]
['if (start < 0) {', 1]
['ngx_add_timer(&fsub->ping_ev, self->cf->websocket_ping_interval * 1000);', 1]
['#define SUB_CHANNEL_UNAUTHORIZED 0', 1]
['static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {', 1]
['else if(status_code == NGX_HTTP_NO_CONTENT || status_code == NGX_HTTP_NOT_MODIFIED) {', 1]
['buf->end=str->data + str->len;', 1]
['cbuf = ngx_create_temp_buf(pool,sizeof(*cbuf));', 1]
['int done=0;', 1]
['d->channel_info = NULL;', 1]
['&internal_respond_status,', 1]
['INTEGER_WIDTH_TEST("hu", unsigned short);', 1]
['/* Set the new value and free the old one. Note that it is important', 1]
['#define NCHAN_NEWEST_MSGID {-1, {{0}}, 1, 0}', 1]
["redis.call('HSET', key.channel, 'ttl', channel.ttl)", 1]
['unid.tag[i] =     msg->id.tag[i];', 1]
['return cmp_write_nfix(ctx, d);', 1]
['s = sdscatprintf(s,"%c",*p);', 1]
['INSTALL_LIBRARY_PATH= $(PREFIX)/lib', 1]
['psr = &fsub->upstream_stuff->psr;', 1]
['Once an error is returned the context cannot be reused and you should set up', 1]
['websocket_send_frame(fsub, WEBSOCKET_PONG_LAST_FRAME_BYTE, 0);', 1]
['u_char        *pos;', 1]
['obj->type = CMP_TYPE_UINT16;', 1]
['"local new_channel\\n"', 1]
['DBG("ensure chanhead ready: Spooler for channel %p %V wasn\'t running. start it.", head, &head->id);', 1]
['test_cond(c->err == REDIS_ERR_IO &&', 1]
['bool cmp_object_as_ulong(cmp_object_t *obj, uint64_t *u) {', 1]
['if (!write_type_marker(ctx, U32_MARKER))', 1]
['HASH_BLOOM_BITTEST((tbl)->bloom_bv, (hashv & (uint32_t)((1ULL << (tbl)->bloom_nbits) - 1)))', 1]
['case WEBSOCKET_READ_START_STEP:', 1]
['for (j = 0; j < len; j++) s[j] = toupper(s[j]);', 1]
['#define HASH_BLOOM_FREE(tbl)                                                     \\', 1]
['if(d->getting == 0) {', 1]
['if(cf->use_redis) {', 1]
['ngx_int_t                       max_channel_subscribers;', 1]
['static ngx_int_t spool_transfer_subscribers(subscriber_pool_t *spool, subscriber_pool_t *newspool, uint8_t update_subscriber_last_msgid);', 1]
['case \'\\b\': len = snprintf(buf,size,"\\"\\\\b\\""); break;', 1]
['bool cmp_object_is_double(cmp_object_t *obj) {', 1]
['unsigned int hash = 5381;', 1]
['ctx->error = TYPE_MARKER_WRITING_ERROR;', 1]
['msg->shared = 0;', 1]
['{ ngx_string("nchan_use_redis"),', 1]
['static ngx_http_module_t  nchan_module_ctx = {', 1]
['databuf.last = cur;', 1]
['proc = &ipc->process[s];', 1]
['|| (timcur == timmin && (min_cmp = msgid_tag_compare(&spool->id, &data->min)) >= 0))', 1]
['if(conf->channel_event_string == NULL) {', 1]
['next = msg->dbg_next;', 1]
['store_message_t             *msg = NULL;', 1]
['ngx_int_t                     owner = memstore_channel_owner(channel_id);', 1]
['FIXED_VALUE_WRITING_ERROR,', 1]
['DOUBLE_MARKER          = 0xCB,', 1]
['if(oldid->time != newid->time) {', 1]
["* end of the specified sds string 's'.", 1]
['cbuf->last = cbuf->pos + ngx_buf_size(buf);', 1]
['* situations where we know that a particular bucket tends to be overused.', 1]
['msub->fn->notify(msub, NCHAN_SUB_MULTI_NOTIFY_ADDSUB, (void *)1);', 1]
[':nchan_set_channel_events_channel_id,', 1]
['static const ngx_str_t ACCEPTED_LINE = ngx_string("202 Accepted");', 1]
['} publish_data_t;', 1]
['ERR("couldn\'t allocate memstore subscriber data");', 1]
['tc->thing_head = cur->next;', 1]
['if(fsub->data.multimsg_first != NULL) {', 1]
['//     int wdone = 0;', 1]
['h->key = nchan_content_length_header_key;', 1]
['val = interval/3;', 1]
['BIN_DATA_LENGTH_TOO_LONG_ERROR,', 1]
['} delete_multi_data_t;', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:WEBSOCKET:" fmt, ##arg)', 1]
['CMP_TYPE_NIL,             /*  4 */', 1]
['unsigned                   use_redis:1;', 1]
['_hs_tail = NULL;                                                       \\', 1]
['static void receive_publish_message(ngx_int_t sender, publish_data_t *d) {', 1]
['#include <nchan_variables.h>', 1]
['--output: current_fake_subscribers', 1]
['BIN32_MARKER           = 0xC6,', 1]
['//origin_chanhead->use_redis', 1]
['if ((!b) || (!chain)) {', 1]
['bc.chain.buf=&bc.buf;', 1]
["/* Don't accept new commands when the connection is about to be closed. */", 1]
['#define WEBSOCKET_READ_GET_MASK_KEY_STEP    2', 1]
['if(max_notready > 0) {', 1]
['websocket_subscriber_destroy(sub);', 1]
['rd.callback = cd->d->callback;', 1]
['#ifdef ONE_FAKE_CHANNEL_OWNER', 1]
['bc[1].buf.last = ngx_snprintf(cur, 255, "Content-Type: %V\\r\\n\\r\\n", &msg->content_type);', 1]
['OPTIMIZATION?=-O3', 1]
['last = first + (IPC_WRITEBUF_SIZE - proc->wbuf.n);', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:INTERNAL:" fmt, ##arg)', 1]
['prev = ssub->prev;', 1]
['ngx_memcpy(channel_copy, &chead->channel, sizeof(*channel_copy));', 1]
['if((ws_key = nchan_get_header_value(r, NCHAN_HEADER_SEC_WEBSOCKET_KEY)) == NULL) {', 1]
['head->shared->last_seen = ngx_time();', 1]
['dictReplace(ac->sub.channels,sname,&cb);', 1]
['"local found_msg_id\\n"', 1]
['#define HASH_FCN HASH_JEN', 1]
['len = redisFormatCommand(&cmd,"SET %s %s","","foo");', 1]
['bool cmp_object_is_ext(cmp_object_t *obj);', 1]
['static ngx_int_t websocket_set_timeout_callback(subscriber_t *self, subscriber_callback_pt cb, void *privdata) {', 1]
['if (config.type == CONN_TCP) {', 1]
['if (d >= -32)', 1]
['&nchan_subscriber_subscribe', 1]
['alt: [ :nchan_pubsub_channel_id ],', 1]
['nchan_exit_master,             /* exit master */', 1]
['extern const ngx_str_t NCHAN_ACCESS_CONTROL_ALLOWED_PUBLISHER_HEADERS;', 1]
['msg.buf = NULL;', 1]
['//no existing ctx found', 1]
['* Return 1 if the key was added from scratch, 0 if there was already an', 1]
['#include "spool.h"', 1]
['if((d=ngx_alloc(sizeof(*d) + (u_char)channel_id->len, ngx_cycle->log)) == 0) {', 1]
['static ngx_int_t chanhead_gc_withdraw(nchan_store_channel_head_t *chanhead);', 1]
['ERROR_MAX', 1]
['p = buf+31; /* point to the last character */', 1]
['u_char            c;', 1]
['memstore_data_t *mpt = &fake_default_mdata;', 1]
['f->respond_message(NGX_OK, msg, f->privdata);', 1]
['* the original length of the sds will be set to zero.', 1]
['if(nodestroy == 0 && fsub->data.awaiting_destruction == 1 && self->reserved == 0) {', 1]
['//DBG("======= old: %V", msgid_to_str(oldid));', 1]
['if channel.current_message ~= nil then', 1]
['return websocket_frame_header_chain(fsub, WEBSOCKET_CLOSE_LAST_FRAME_BYTE, 0);', 1]
['HASH_FSCK(hh,head);                                                          \\', 1]
['sent << publish(Msg.new(id, data: "foo2", ttl: 30))', 1]
['sds sdscatlen(sds s, const void *t, size_t len);', 1]
['"return {sub_id, sub_count}",', 1]
['if( timcur > timmin && timcur < timmax) {', 1]
['return p+2+(*len)+2;', 1]
['ngx_log_error(NGX_LOG_ERR, log, 0, "nchan: can\'t create output chain, can\'t allocate chain  in pool");', 1]
['if(d->msg == NULL) {', 1]
['msg_file = ngx_palloc(pool, sizeof(*msg_file));', 1]
['msg_tag, channel_info=redis.evalsha hashes[:publish], [], [msg.chid, msg.time, msg.data, msg.content_type, msg.ttl, 100]', 1]
['tag1 = i < max1 ? tags1[i] : -1;', 1]
['va_list   args;', 1]
['if(nchan_store_memory.init_worker(cycle)!=NGX_OK) {', 1]
['h->value.data = p;', 1]
['redisAsyncContext *redisAsyncConnectUnix(const char *path) {', 1]
['void nchan_copy_preallocated_buffer(ngx_buf_t *buf, ngx_buf_t *cbuf) {', 1]
['ngx_pool_stat_t     *stat;', 1]
['errno = ETIMEDOUT;', 1]
['#ifdef SDS_TEST_MAIN', 1]
['static ngx_int_t nchan_init_worker(ngx_cycle_t *cycle) {', 1]
['"      dbg(\\"get most recent\\")\\n"', 1]
['content_type_size += m->content_type.len;', 1]
['CMP_TYPE_BOOLEAN,         /*  5 */', 1]
['assert(proc->pipe[0] != NGX_INVALID_FILE);', 1]
['#define WEBSOCKET_OPCODE_CLOSE              0x8', 1]
['assert(callback != NULL);', 1]
['assert(d->shm_chid->data != NULL);', 1]
['extern const ngx_str_t NCHAN_CHANNEL_INFO_JSON;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: unable to allocate memory for Etag header in pool");', 1]
['file->fd=ngx_open_file(file->name.data, NGX_FILE_RDONLY, NGX_FILE_OPEN, NGX_FILE_OWNER_ACCESS);', 1]
['nchan_thingcache_shutdown(fd_cache);', 1]
['+ ( (unsigned)_hj_key[10] << 16 )                                        \\', 1]
['default: "*",', 1]
['frame->opcode = frame->header[0] & 0xf;', 1]
['cb->next = NULL;', 1]
['snprintf(c->errstr,sizeof(c->errstr),"%s",((redisReply*)reply)->str);', 1]
['/* It is only useful to call (P)UNSUBSCRIBE when the context is', 1]
['lcf->subscriber_timeout=NGX_CONF_UNSET;', 1]
['if(tags2[i] >= 0) nonnegs++;', 1]
["redis.call('DEL', 'channel:msg:'..id..':'..oldmsgid)", 1]
['int redisvAppendCommand(redisContext *c, const char *format, va_list ap);', 1]
['zone->init = init;', 1]
['static ngx_inline void *thing_next(nchan_reaper_t *rp, void *thing) {', 1]
['"  id=nil,\\n"', 1]
['channel_status = channel == NULL ? SUB_CHANNEL_UNAUTHORIZED : SUB_CHANNEL_AUTHORIZED;', 1]
['static       subscriber_fn_t *eventsource_fn = NULL;', 1]
['setkeyttl(active_ttl)', 1]
['publish_msg = create_shm_msg(msg);', 1]
["* an hash entry for the given 'key'.", 1]
['bool cmp_object_is_nil(cmp_object_t *obj) {', 1]
['n = c->recv(c, buf->last, (ssize_t) len - (buf->last - buf->start));', 1]
['"    dbg(\\"channel current_message absent\\")\\n"', 1]
['#define DISABLED_STRINGS "none", "off", "disabled"', 1]
['bool cmp_object_is_uinteger(cmp_object_t *obj);', 1]
['/* Setup error flags so they can be used directly. */', 1]
['c = ngx_get_connection(proc->pipe[1], cycle->log);', 1]
['"    dbg(\\"NEXT MESSAGE KEY NOT PRESENT. ERROR, ERROR!\\")\\n"', 1]
['cur = url->data;', 1]
['test_cond(strncmp(cmd,"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nb\\0r\\r\\n",len) == 0 &&', 1]
['} ngx_rbtree_debug_node_link_t;', 1]
['e.ip = val->lengths;', 1]
['r->request_body_in_persistent_file = 1;', 1]
["msg = redis.call('LPOP', messages)", 1]
['/////////// SPOOLER - container of several spools //////////', 1]
['len = s-(r->buf+r->pos);', 1]
['NULL,                          /* merge server configuration */', 1]
['ipc_t        *ipc;', 1]
['ERR("%i channels still present in reaper at exit  (slot %i)", mpt->chanhead_reaper.count, ngx_process_slot);', 1]
['ngx_str_t                 *etag, *tmp_etag;', 1]
['"local cur = 0\\n"', 1]
['shm_free(shm, ch->shared);', 1]
['while(count--)', 1]
['local msg_id', 1]
['u_char                    *priority=&accept[len-1];', 1]
['ipc_alert(nchan_memstore_get_ipc(), dst, IPC_TEST_FLOOD, &data, sizeof(data));', 1]
['sizeof(UT_hash_table));                                        \\', 1]
['value: ["memory", "redis"],', 1]
['if(ch->in_churn_queue) {', 1]
['d->msglen = msglen;', 1]
['set_varval(v, ctx->channel_event_name->data, ctx->channel_event_name->len);', 1]
['static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, char *cmd, size_t len) {', 1]
['static ngx_str_t   sub_name = ngx_string("memstore-redis");', 1]
['unsigned long i;', 1]
['for(_he_bkt_i = 0; _he_bkt_i < tbl->num_buckets; _he_bkt_i++)                \\', 1]
['CMP_TYPE_FIXEXT2,         /* 23 */', 1]
['"  local next_msg, next_msgtime, next_msgtag\\n"', 1]
['#ifdef HASH_DEBUG', 1]
['static ngx_str_t     subscriber_name = ngx_string("internal");', 1]
['static void memstore_sub_debug_end() {', 1]
['if(data->n < SPOOLER_RESPOND_SPOOLARRAY_SIZE) {', 1]
['else if (type_marker == BIN16_MARKER) {', 1]
['nchan_update_multi_msgid(&sub->last_msgid, &msg->id);', 1]
['//#define FAKESHARD 1', 1]
['* The string is always null-termined (all the sds strings are, always) so', 1]
["//(liucougar: this is a bit confusing, but it is what's the default behavior before this option is introducecd)", 1]
['static void redisAeDelRead(void *privdata) {', 1]
['static int16_t              multi_largetag[NCHAN_MULTITAG_MAX], multi_prevlargetag[NCHAN_MULTITAG_MAX];', 1]
['long msec;', 1]
['ngx_http_cleanup_t          *cln;', 1]
['THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS', 1]
['#define NGX_DEFAULT_LINEBREAK_POOL_SIZE 1024', 1]
['assert(proc->active);', 1]
['ngx_int_t     time;', 1]
['"local id, sub_id, active_ttl, concurrency = ARGV[1], ARGV[2], tonumber(ARGV[3]) or 20, ARGV[4]\\n"', 1]
['default: ["$http_last_event_id", "$arg_last_event_id"],', 1]
['//assert((node = rbtree_find_node(&spl->spoolseed, &spool->id)) == NULL);', 1]
['keep an eye on the changelog when upgrading (see issue #39).', 1]
['sds sdscpy(sds s, const char *t);', 1]
['static size_t chrtos(char *buf, size_t size, char byte) {', 1]
['ngx_int_t nchan_reaper_stop(nchan_reaper_t *rp) {', 1]
['#ifdef SUB_FAKE_WORKER', 1]
['cf.buffer_timeout = 50;', 1]
['{ ngx_string("nchan_channel_id"),         nchan_channel_id_variable, 0},', 1]
['Gemfile.lock', 1]
['* interrupted by a signal. */', 1]
['_hs_list = NULL;                                                       \\', 1]
['char            data[IPC_DATA_SIZE];', 1]
['bc[0].buf.start = headerbuf;', 1]
['HASH_ITER(hh, mpt->hash, cur, tmp) {', 1]
['msg.tag=msg_tag', 1]
['} whole_thing_t;', 1]
['rdt.chanhead_cleanup_head = NULL;', 1]
['redis_nginx_auth_callback(redisAsyncContext *ac, void *rep, void *privdata)', 1]
['for (i = 0; i < setlen; i++) {', 1]
['typedef struct ngx_rbtree_debug_node_s ngx_rbtree_debug_node_t;', 1]
['ngx_int_t          started_count, tried_count, deleted_count;', 1]
['if(websocket_release(&fsub->sub, 0) == NGX_ABORT) {', 1]
['* It is better to let its chain length grow to a longer yet-still-bounded', 1]
['ngx_str_t                *close_msg;', 1]
['bool cmp_write_decimal(cmp_ctx_t *ctx, double d);', 1]
['const ngx_str_t NCHAN_CHANNEL_INFO_YAML = ngx_string(', 1]
['require "redis"', 1]
['/* Return a.s.a.p. when the stack is now empty. */', 1]
['#include <ngx_crypt.h>', 1]
['prev = msg->dbg_prev;', 1]
['if(spool->sub_count > 0) {', 1]
['if(reply == NULL) return;', 1]
['strcmp(c->errstr,"Connection refused") == 0);', 1]
['messages  = ch->messages;', 1]
['rchain = &cb->chain;', 1]
['int16_t *tags1, *tags2;', 1]
['if(count < shdata->max_workers) {', 1]
['spooled_subscriber_cleanup_t  *d = (spooled_subscriber_cleanup_t *)data;', 1]
['static int tests = 0, fails = 0;', 1]
['DBG("received does_channel_exist request for channel %V privdata %p", d->shm_chid, d->privdata);', 1]
['static nchan_msg_id_t     latest_msg_id = NCHAN_NEWEST_MSGID;', 1]
['if (start >= (signed)len) {', 1]
['msgbuf.start = frame->payload;', 1]
['ngx_http_script_flush_complex_value(r, val);', 1]
['#define HASH_BLOOM_FREE(tbl)', 1]
['multipart_fn->respond_message = multipart_respond_message;', 1]
['bool cmp_object_is_ushort(cmp_object_t *obj);', 1]
['zone = ngx_shared_memory_add(cf, name, shm_size, &nchan_module);', 1]
['static ngx_int_t spooler_respond_message(channel_spooler_t *self, nchan_msg_t *msg) {', 1]
['iter->entry = NULL;', 1]
['//output: message_tag, channel_hash {ttl, time_last_seen, subscribers, messages}', 1]
['return i==1 and id or "DENY"', 1]
['ipc_alert(nchan_memstore_get_ipc(), sender, IPC_SUBSCRIBE_REPLY, d, sizeof(*d));', 1]
['ngx_int_t               immortal_spool = spool->id.time == -1;', 1]
['scripts.sort_by {|k,v| k}.each do |v|', 1]
['d->allocd = 0;', 1]
['typedef enum {MSG_CHANNEL_NOTREADY, MSG_INVALID, MSG_PENDING, MSG_NOTFOUND, MSG_FOUND, MSG_EXPECTED, MSG_EXPIRED} nchan_msg_status_t;', 1]
['extern const ngx_str_t NCHAN_HEADER_UPGRADE;', 1]
['DBG("timer for %s %p", tc->name, tc);', 1]
['ngx_int_t code = d->http_response_code;', 1]
['time_t                          time; //tag message by time', 1]
['* Note the preprocessor built-in defines can be emitted using:', 1]
['CMP_TYPE_EXT8,            /*  9 */', 1]
['bool cmp_read_bin(cmp_ctx_t *ctx, void *data, uint32_t *size);', 1]
['uintptr_t i;', 1]
['ngx_int_t nchan_set_msgid_http_response_headers(ngx_http_request_t *r, nchan_msg_id_t *msgid) {', 1]
['void                  (*handler)(ngx_int_t, ngx_uint_t, void*);', 1]
['//move to the end of the list', 1]
['chanhead_churner_add(ch);', 1]
['chan.id.len = d->shm_chid->len;', 1]
['DBG("%p (%V) release", self, fsub->sub.name);', 1]
['//reusable output chains and bufs', 1]
['mkdir -p tmp/lcov', 1]
['if (ngx_del_event(connection->read, NGX_READ_EVENT, 0) == NGX_ERROR) {', 1]
['/* not found */', 1]
['EXT16_MARKER           = 0xC8,', 1]
['flags |= O_NONBLOCK;', 1]
['DBG("created node %p", node);', 1]
['if (source_addr) {', 1]
['dbg("get oldest")', 1]
['ngx_str_t                      *eventsource_event;', 1]
['bool cmp_object_as_long(cmp_object_t *obj, int64_t *d) {', 1]
['DBG("not ready to reap %V : status %s", &ch->id, sts);', 1]
['flast = databuf.file_last;', 1]
['if (redisBufferWrite(c,&wdone) == REDIS_ERR)', 1]
['#define NCHAN_NOBUFFER_MSG_EXPIRE_SEC 10', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not allocate the redis context for %s:%d", host, port);', 1]
['* if someone used the same symbol for the head and deletee, like', 1]
['nchan_loc_conf_t       *cf = ngx_http_get_module_loc_conf(fsub->sub.request, nchan_module);', 1]
['nchan_subscriber_timeout [:main, :srv, :loc, :if],', 1]
['if(code < 1000 || code > 1011) {', 1]
['bc.buf.end = bc.buf.start + 5;', 1]
['ctx->channel_id_count = 1;', 1]
['#define MUR_TWO_TWO(p)   ((((*WP(p))&0xffff0000) >>16) | (((*(WP(p)+1))&0x0000ffff) << 16))', 1]
['#define __HIREDIS_FMACRO_H', 1]
['if(create_complex_value_from_ngx_str(cf, &conf->channel_event_string, &DEFAULT_CHANNEL_EVENT_STRING) == NGX_CONF_ERROR) {', 1]
['if(mpt->chanhead_churner.count > 0) {', 1]
['nchan_reaper_t                  nobuffer_msg_reaper;', 1]
['make check', 1]
['#define MEMSTORE_IPC_SUBSCRIBER_TIMEOUT 5', 1]
['nchan_msg_t                       *msgdebug_head;', 1]
['char* (*scripts)[]=(char* (*)[])&store_rds_lua_scripts;', 1]
['reset_timer(fsub);', 1]
['ngx_memcpy(str->data, str_in->data, str_in->len);', 1]
['/* PING server */', 1]
['nchan_publisher_post_request(r, content_type, content_length, r->request_body->bufs, d->ch_id, cf);', 1]
['msg=Msg.new(msg[:channel_id] || msg[:chid], msg) if Hash === msg', 1]
['if(multi_count <= 1) {', 1]
['//everyone might have this multi. broadcast the delete everywhere', 1]
['r->headers_out.content_length_n=ngx_buf_size(rbuffer);', 1]
['//no multi-ids allowed here', 1]
['dst_n = NCHAN_FIXED_MULTITAG_MAX;', 1]
['nchan_msg_t                 retmsg;', 1]
['* A multi bulk reply. The number of elements in the multi bulk reply is stored in', 1]
['new_channel=true', 1]
['ngx_int_t            (*set_dequeue_handler)(channel_spooler_t *, void (*cb)(channel_spooler_t *, subscriber_t *, void*), void*);', 1]
['/* For non-clean disconnects, __redisAsyncFree() will execute pending', 1]
['static void receive_does_channel_exist_reply(ngx_int_t sender, channel_existence_data_t *d) {', 1]
['local new_channel', 1]
['ngx_int_t          i;', 1]
['void verify_unique_response(ngx_str_t *uri, nchan_msg_id_t *msgid, nchan_msg_t *msg, subscriber_t *sub) {', 1]
['r->headers_out.status=NGX_HTTP_OK; //no need to fool chunking module', 1]
['nchan_conf_subscriber_types_t *subt = &lcf->sub;', 1]
['time= time,', 1]
['ac->ev.cleanup = redis_nginx_cleanup;', 1]
['if(max == 1) {', 1]
['HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                             \\', 1]
['"    table.remove(ch, 4)\\n"', 1]
['if(src_n <= NCHAN_FIXED_MULTITAG_MAX) {', 1]
['break; //good practice?', 1]
['/* Reads a signed integer that fits inside a signed long */', 1]
['obj->as.array_size = be32(obj->as.u32);', 1]
['chead = nchan_memstore_find_chanhead(channel_id);', 1]
['ngx_int_t nchan_copy_new_msg_id(nchan_msg_id_t *dst, nchan_msg_id_t *src) {', 1]
['Internally, Hiredis splits the command in different arguments and will', 1]
['"  dbg(\\"channel.max_stored_messages was not set, but is now \\", store_at_most_n_messages)\\n"', 1]
['//okay, this crazy data chain is finished.', 1]
['if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev =               \\', 1]
['if(srdata.n == 0) {', 1]
['if(tc->gc_timer.timer_set) {', 1]
['return cmp_write_str8_marker(ctx, size);', 1]
['static ngx_int_t nchan_subscriber_type_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['bool cmp_write_map(cmp_ctx_t *ctx, uint32_t size);', 1]
['/* XXX work-around a bug in ngx_http_subrequest */', 1]
['#define REDIS_MONITORING 0x40', 1]
['redisAeDelRead(privdata);', 1]
['spooled_subscriber_t       *ssub;', 1]
['y = sdsnew("foa");', 1]
['fsub->data.timeout_handler = cb;', 1]
['if(ngx_buf_size(databuf) == 0) {', 1]
["sh->buf[initlen] = '\\0';", 1]
['assert(prev != next);', 1]
['ngx_close_file(fd);', 1]
['d->callback(MSG_EXPIRED, NULL, d->privdata);', 1]
['r->ridx++;', 1]
['b[1] = swap;', 1]
['goto end;', 1]
['dictIterator *iter = malloc(sizeof(*iter));', 1]
['if((psrd->cln = ngx_http_cleanup_add(sr, 0)) == NULL) {', 1]
['struct ngx_rbtree_debug_node_s  *next;', 1]
['typedef enum {INACTIVE, NOTREADY, WAITING, STUBBED, READY} chanhead_pubsub_status_t;', 1]
['/* Reads a signed integer */', 1]
['//content type', 1]
['//multi is always self-owned', 1]
['seed->allocd_nodes++;', 1]
['if ((head)->hh.tbl->buckets[_bkt_i].count !=  _bkt_count) {          \\', 1]
['for(i = memstore_procslot_offset; i < NGX_MAX_PROCESSES - memstore_procslot_offset; i++) {', 1]
['buf->last = buf->last + len;', 1]
['head->latest_msgid.tag.fixed[0] = 0;', 1]
['bool cmp_read_u64(cmp_ctx_t *ctx, uint64_t *l);', 1]
['if(head->redis_sub == NULL) {', 1]
['obj->as.s32 = be32(obj->as.s32);', 1]
['assert(ws_accept_key.len < 255);', 1]
['} nchan_channel_t;', 1]
['if (HASH_BLOOM_TEST((head)->hh.tbl, _hf_hashv)) {                           \\', 1]
['* === Object API', 1]
['ngx_msec_t           t;', 1]
['#include <uthash.h>', 1]
['nchan_msg_t             *msg;', 1]
['ch = nchan_memstore_find_chanhead(channel_id);', 1]
['static u_char        charbuf[512];', 1]
["local messages=   'channel:messages:'..id", 1]
['ngx_close_socket(*fd);', 1]
["dbg(' #######  PUBLISH   ######## ')", 1]
['if ( !CHECK_REPLY_ARRAY_MIN_SIZE(reply, 1) || !CHECK_REPLY_INT(reply->element[0]) ) {', 1]
['uint16_t                   max_msgs;', 1]
['nchan_llist_timed_t   *thing_tail;', 1]
['psr = &psr_stuff->psr;', 1]
['"      msg_id = found_msg_id\\n"', 1]
['*l = obj.as.u64;', 1]
['if (c->reader != NULL)', 1]
['cout= <<EOF', 1]
['static ngx_int_t rbtree_compare_str(void *id1, void *id2) {', 1]
['totlen += bulklen(len);', 1]
['if(tags[i] == -1) {', 1]
['if(rchain) {', 1]
['ngx_memcpy(&fn_buf, filename->data, filename->len);', 1]
['char **curargv = NULL, **newargv = NULL;', 1]
['Any other error. Currently, it is only used when a specified hostname to connect', 1]
['redisGetReply(c,&_reply) == REDIS_ERR);', 1]
['ngx_memcpy(msg_file, msg_buf->file, sizeof(*msg_file));', 1]
['redisAeDelWrite(privdata);', 1]
['//ERR("spool %p nextmsg (%V) --", spool, msgid_to_str(&spool->id));', 1]
['ngx_http_complex_value_t       *publisher_upstream_request_url;', 1]
['"-- delete this channel and all its messages\\n"', 1]
['typedef char *sds;', 1]
['else if (type_marker == U16_MARKER) {', 1]
['out="//nothing here\\n"', 1]
['/* Copy callback from heap to stack */', 1]
['ngx_str_t             *content_type;', 1]
['data.d.req.msgid = *msgid;', 1]
['for(cur = msg->rsv; cur != NULL; cur = cur->next) {', 1]
['DYLIB_MAKE_CMD=$(CC) -shared -Wl,-soname,$(DYLIB_MINOR_NAME) -o $(DYLIBNAME) $(LDFLAGS)', 1]
['cbuf->file->offset=buf->file->offset;', 1]
['#include <sys/socket.h>', 1]
['ngx_memzero(seed->actives, sizeof(seed->actives));', 1]
['//ngx_log_debug2(NGX_LOG_DEBUG_HTTP, wev->log, 0, "http writer done: \\"%V?%V\\"", &r->uri, &r->args);', 1]
['def publish(*arg)', 1]
['ngx_int_t internal_subscriber_set_dequeue_handler(subscriber_t *sub, callback_pt handler) {', 1]
['test_cond(reply->type == REDIS_REPLY_STATUS &&', 1]
['static void redisLibeventDelRead(void *privdata) {', 1]
['/* Set a key */', 1]
['"msg.id=(\'%i:%i\'):format(msg.time, msg.tag)\\n"', 1]
['if(ngx_strlcasestrn(tmp->data, tmp->data + tmp->len, NCHAN_UPGRADE.data, NCHAN_UPGRADE.len - 1) == NULL) return 0;', 1]
['nchan_store_channel_head_t         *cur, *tmp;', 1]
['modification, are permitted provided that the following conditions', 1]
['static ngx_int_t subscriber_authorize_callback(ngx_http_request_t *r, void *data, ngx_int_t rc) {', 1]
['return nchan_respond_status(r, NGX_HTTP_OK, NULL, 0);', 1]
['ngx_memzero(&bc[1].buf, sizeof(ngx_buf_t));', 1]
["if (*p == '\\\\' && *(p+1) == '\\'') {", 1]
['else if(i==2) {', 1]
['nchan_memstore_force_delete_channel(channel_id, (callback_pt )delete_multi_callback_handler, d);', 1]
['dict n; /* the new hashtable */', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "REAPER: " fmt, ##args)', 1]
['ngx_memcpy(dst->data, src->data, sz);', 1]
['static ngx_int_t spooler_set_bulk_post_subscribe_handler(channel_spooler_t *self, void (*handler)(channel_spooler_t *, int, void *), void *privdata) {', 1]
['start = 0;', 1]
['HASH_MAKE_TABLE(hh_dst,dst);                                       \\', 1]
['u_char   *delim = sub->data;', 1]
['tc->thing_tail = NULL;', 1]
['&& CHECK_REPLY_INT(r->element[2]) ) {', 1]
['DBG("send does_channel_exist to %i %V", dst, chid);', 1]
['/* Subscription callbacks */', 1]
['ipc_process_t         *proc;', 1]
['static void receive_get_message(ngx_int_t sender, getmessage_data_t *d) {', 1]
['assert(redisGetReply(c, (void*)&reply) == REDIS_OK);', 1]
['"  nearly_departed = redis.call(\'hmget\', key_channel, \'ttl\', \'time_last_seen\', \'subscribers\')\\n"', 1]
['hh_del->hh_next->hh_prev = hh_del->hh_prev;                              \\', 1]
['bc[3].buf.flush = 1;', 1]
['DBG("gc_withdraw chanhead %p (%V), but already inactive", chanhead, &chanhead->id);', 1]
['#define CHANNEL_HASH_DEL(chanhead)      HASH_DEL( mpt->hash, chanhead)', 1]
['tbl->nonideal_items++;                                              \\', 1]
['void nchan_output_shutdown(void) {', 1]
['ngx_int_t nchan_add_variables(ngx_conf_t *cf);', 1]
['#include <arpa/inet.h>', 1]
['ngx_memzero(&fsub->hdr_buf, sizeof(fsub->hdr_buf));', 1]
['////////// PUBLISH STATUS ////////////////', 1]
['if(status_code != NGX_HTTP_NO_CONTENT) self->responded_count++;', 1]
['static const subscriber_t new_websocket_sub = {', 1]
['#define redisReplyReaderFeed redisReaderFeed', 1]
['understanding of the internal execution flow.', 1]
['test_report()', 1]
['ch->gc_queued_times ++;', 1]
['if(!fsub->sub.cf->pub.websocket) {', 1]
['the latter means an error occurred while reading a reply. Just as with the other commands,', 1]
['void *val;', 1]
['ngx_conf_enable_redis,', 1]
['subscriber_t *memstore_redis_subscriber_create(nchan_store_channel_head_t *chanhead) {', 1]
['DBG("%p enqueued (%p %V %i) %V", d->multi->sub, d->multi_chanhead, &d->multi_chanhead->id, d->n, &d->multi->id);', 1]
['/* test 7 */', 1]
['static char * create_complex_value_from_ngx_str(ngx_conf_t *cf, ngx_http_complex_value_t **dst_cv, ngx_str_t *str) {', 1]
['if (setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {', 1]
['ctx->error = FIXED_VALUE_WRITING_ERROR;', 1]
['if (redisReaderFeed(c->reader,buf,nread) != REDIS_OK) {', 1]
['if(d->allocd) {', 1]
['void         *privdata;', 1]
['rp->timer.cancelable = 1;', 1]
['if ((ht)->type->valDestructor) \\', 1]
['long long integer; /* The integer when type is REDIS_REPLY_INTEGER */', 1]
['double_newline_buf.start = (u_char *)"\\r\\n\\r\\n";', 1]
['extern const ngx_str_t NCHAN_UPGRADE;', 1]
['if(nchan_parse_compound_msgid(&id, if_none_match) == NGX_OK) {', 1]
["-- create_channel_ttl - make new channel if it's absent, with ttl set to this. 0 to disable.", 1]
['bool cmp_read_fixext4_marker(cmp_ctx_t *ctx, int8_t *type);', 1]
['elseif max_stored_msgs > 0 then', 1]
['get_msg_from_msgkey(&chanhead->id, &msgid, &msg_redis_hash_key);', 1]
['close_code = CLOSE_INTERNAL_SERVER_ERROR;', 1]
['newspool = get_spool(spl, &new_id);', 1]
['def test_timeout', 1]
['STR32_MARKER           = 0xDB,', 1]
['bool cmp_write_true(cmp_ctx_t *ctx) {', 1]
[':nchan_ignore_subscriber_concurrency,', 1]
['static ngx_inline void rbtree_conditional_walk_real(rbtree_seed_t *seed, ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel, rbtree_walk_conditional_callback_pt callback, void *data) {', 1]
['r = calloc(sizeof(redisReader),1);', 1]
['overflow->spool = spool;', 1]
['local nearly_departed = nil', 1]
['f->already_dequeued = 1;', 1]
['ngx_int_t              (*reserve)(struct subscriber_s *);', 1]
['if (!p) {', 1]
['bool cmp_object_as_ext(cmp_object_t *obj, int8_t *type, uint32_t *size);', 1]
['if(ch->redis_sub->enqueued) {', 1]
['sds *sdssplitargs(const char *line, int *argc) {', 1]
['ac->ev.delWrite = redisAeDelWrite;', 1]
['self->sub_count--;', 1]
['assert(head->shutting_down == 1);', 1]
['ngx_str_t      second_choice_msgid = ngx_string("$arg_last_event_id");', 1]
['const  ngx_str_t NCHAN_HEADER_CACHE_CONTROL = ngx_string("Cache-Control");', 1]
['test("Append format command: ");', 1]
['bc[2].buf.start = chunk_end;', 1]
['} else if (strncasecmp(cstr,"unsubscribe\\r\\n",13) == 0) {', 1]
['int ngx_rwlock_write_check(ngx_rwlock_t *lock) {', 1]
['time_t                          channel_timeout;', 1]
['uthash_free((tbl)->bloom_bv, HASH_BLOOM_BYTELEN);                              \\', 1]
['psrd->buf = *buf;', 1]
['alert->time_sent = ngx_time();', 1]
['get_multi_message_data_t    *d = ngx_alloc(sizeof(*d), ngx_cycle->log);', 1]
['redisAsyncCommand(ac, redis_nginx_auth_callback, context, AUTH_COMMAND, password);', 1]
['"    setkeyttl(empty_ttl)\\n"', 1]
['char* (*names)[]=(char* (*)[])&store_rds_lua_script_names;', 1]
['c = redisConnect((char*)"idontexist.local", 6379);', 1]
['ngx_int_t internal_subscriber_set_respond_status_handler(subscriber_t *sub, callback_pt handler) {', 1]
['#include "ngx_rwlock.h"', 1]
['HASH_FIND(hh,head,&((add)->fieldname),keylen_in,replaced);                     \\', 1]
['//VALGRIND_DESTROY_MEMPOOL(SHPOOL(shm));', 1]
['DYLIB_MAKE_CMD=$(CC) -shared -Wl,-install_name,$(DYLIB_MINOR_NAME) -o $(DYLIBNAME) $(LDFLAGS)', 1]
['//maybe a message?', 1]
["local subscribers='channel:subscribers:'..id", 1]
['bc->buf.last_buf = 0;', 1]
['/* Set error for nested multi bulks with depth > 7 */', 1]
['ev_io_init(&e->wev,redisLibevWriteEvent,c->fd,EV_WRITE);', 1]
['void                        (*add_handler)(channel_spooler_t *, subscriber_t *, void *);', 1]
['export REDIS_TEST_CONFIG', 1]
['HASH_ADD(hh,head,strfield[0],strlen(add->strfield),add)', 1]
['#ifndef __NET_H', 1]
['//figure out the memstore_procslot_offset', 1]
['static dictEntry * dictFind(dict *ht, const void *key);', 1]
['* maximum chain length based on the *new* (doubled) bucket count.', 1]
['size_t                          msglen;', 1]
['glob->alert = alert;', 1]
['if((params = ngx_calloc(sizeof(*params) + url->len + 4, ngx_cycle->log)) == NULL) {', 1]
['bool cmp_object_is_ulong(cmp_object_t *obj) {', 1]
['sh->len = curlen+len;', 1]
['static ngx_int_t nchan_ws_llink_destroy(nchan_llist_timed_t *cur) {', 1]
['static void test_invalid_timeout_errors(struct config config) {', 1]
['full_subscriber_t     *fsub = (full_subscriber_t *)self;', 1]
['"  ttl= tonumber(ARGV[6]),\\n"', 1]
['msg.prev=channel.current_message', 1]
['extern nchan_store_t *nchan_store;', 1]
['ERR("time_min: %i, time_cur: %i, time_max: %i", timmin, timcur, timmax);', 1]
['union getmsg_u          d;', 1]
['msglen = buf->last - msgstart;', 1]
['buffer of the `redisReader` using `redisReaderFeed`. This function will make a', 1]
['ctx->channel_event_name = &evt_sub_enqueue;', 1]
['"  msg.prev_time = lasttime\\n"', 1]
['fsub->timeout_ev.log = ngx_cycle->log;', 1]
['DBG("want %i", i);', 1]
['ngx_int_t                    i;', 1]
['ERR("verify_msg_id: more than one tag set to something besides -1. that means this isn\'t a single channel\'s forwarded multi msg. fail.");', 1]
['@data= _empty_is_nil arg[:data]', 1]
['large payloads. The context should be set back to `REDIS_READER_MAX_BUF` again', 1]
['} redisLibuvEvents;', 1]
['/* Build the command string accordingly to protocol */', 1]
['/* Set read/write timeout on a blocking socket. */', 1]
['redisAsyncContext               *ctx;', 1]
['msg_debug_remove(msg);', 1]
['content_length = 0;', 1]
['HIREDIS_MAJOR=0', 1]
['* Returns REDIS_OK when the buffer is empty, or (a part of) the buffer was', 1]
['alt: [ :nchan_sub_channel_id ],', 1]
['//  { ngx_string("nchan_message"),            nchan_message_variable, 0},', 1]
["redis.call('HSET', key.channel, 'time', time)", 1]
['switch(cur->type) {', 1]
['ngx_str_t                *content_type;', 1]
['ngx_http_complex_value_t       *authorize_request_url_ccv = cf->authorize_request_url;', 1]
['"-- to keep it big and ugly. It needs to do a lot of stuff atomically, and \\n"', 1]
['nchan_hash_str((u_char *) s, sizeof(s) - 1)', 1]
['DBG("%p (%V) not ready to destroy (reserved for %i)", fsub, d->chid, fsub->sub.reserved);', 1]
['* callback, there might be more replies and we can safely defer disconnecting', 1]
['static bool ngx_buf_reader(cmp_ctx_t *ctx, void *data, size_t limit) {', 1]
['spooler_respond_generic_data_t  data = {self, msg, code, line};', 1]
['r->headers_out.status = status_code == (ngx_int_t) NULL ? NGX_HTTP_OK : status_code;', 1]
['ngx_add_timer(&rdt.cleanup_timer, NCHAN_DEFAULT_CHANHEAD_CLEANUP_INTERVAL);', 1]
['memstore_ipc_send_memstore_subscriber_keepalive(d->originator, d->chid, d->sub, d->foreign_chanhead, keepalive_reply_handler, d);', 1]
['return _redisContextConnectTcp(c, addr, port, timeout, source_addr);', 1]
['sdslen(x) == 33 &&', 1]
['$(STLIBNAME): $(OBJ)', 1]
['ch->in_churn_queue = 0;', 1]
['if(ngx_atomic_cmp_set(&smsg->msg->refcount, 0, MSG_REFCOUNT_INVALID)) {', 1]
['static void rbtree_insert_generic(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel) {', 1]
['static void *createStringObject(const redisReadTask *task, char *str, size_t len) {', 1]
['or not channel.current_message then', 1]
['return cmp_write_array32(ctx, size);', 1]
['bool cmp_read_s64(cmp_ctx_t *ctx, int64_t *l) {', 1]
['ch.last_published_msg_id.time = d->msg_time;', 1]
['fsub->data.already_responded = 0;', 1]
['/* convenience forms of HASH_FIND/HASH_ADD/HASH_DEL */', 1]
['#define IPC_PUBLISH_MESSAGE_REPLY   6', 1]
['rev_count--;', 1]
['table.insert(ch, redis.call(\'llen\', "channel:messages:"..id))', 1]
['static u_char   itoa64[] ="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";', 1]
['r->headers_out.status_line = NCHAN_HTTP_STATUS_101;', 1]
['#endif /* NCHAN_DEFS_H */', 1]
['r->headers_in.content_length_n = len;', 1]
['return cmp_write_u16(ctx, u);', 1]
['nchan_loc_conf_t          *cf;', 1]
['for (j = 0; j < r->elements; j++)', 1]
['DBG("reaped %s %p (waiting to be reaped: %l)", rp->name, cur, rp->count);', 1]
['return cur + sz;', 1]
['u_char rsv2:1;', 1]
['"if redis.call(\'PUBSUB\',\'NUMSUB\', pubsub)[2] > 0 then\\n"', 1]
['when `redisReaderGetReply` is called. This function returns an integer status', 1]
['if (!wev->ready) {', 1]
['eventsource_event_size += m->eventsource_event.len;', 1]
['DBG("gc_add chanhead %V", &head->id);', 1]
['subt->websocket=0;', 1]
['websocket_reserve(&fsub->sub);', 1]
['ngx_int_t *max;', 1]
['/* Helper that calculates the bulk length given a certain string length. */', 1]
['uthash_free((head)->hh.tbl->buckets,                                     \\', 1]
['{ "x-yaml", 6, &NCHAN_CHANNEL_INFO_YAML }', 1]
["* Note that fcntl(2) for F_GETFL and F_SETFL can't be", 1]
['#define SUB_CHANNEL_AUTHORIZED 1', 1]
['ngx_uint_t                    messages; //# of channels being used', 1]
['ERR("couldn\'t allocate memory for file struct while responding with msg");', 1]
['if(cond) {                                        \\', 1]
['HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt],&(add)->hh);                   \\', 1]
['"      found_msg_id=oldestmsg(key.messages, (\'channel:msg:%s:\'..id))\\n"', 1]
['static void spool_bubbleup_bulk_dequeue_handler(subscriber_pool_t *spool, subscriber_type_t type, ngx_int_t count, channel_spooler_t *spl) {', 1]
['assert(subdebug_head == NULL);', 1]
['*last_chain = &bc[0].chain;', 1]
['The library comes with multiple APIs. There is the', 1]
['hashed_table << "  \\"#{Digest::SHA1.hexdigest script}\\""', 1]
['ch_id=msg.chid', 1]
['cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_p)), \\', 1]
['} nchan_msg_id_t;', 1]
['sts = "NOTREADY";', 1]
['static char *nchan_subscriber_directive_parse(ngx_conf_t *cf, ngx_command_t *cmd, void *conf, ngx_int_t fail) {', 1]
['newspool = spool;', 1]
['remsg.id.tag.allocd = tags;', 1]
['redisCallback *cb;', 1]
['} publish_response_data;', 1]
['#define REDIS_FREEING 0x8', 1]
['legacy: "push_publisher",', 1]
['@chid= _empty_is_nil channel_id', 1]
['"Error reading type marker",', 1]
['bool cmp_write_fixext16_marker(cmp_ctx_t *ctx, int8_t type) {', 1]
['fsub->ping_ev.log = ngx_cycle->log;', 1]
['if ((p = readLine(r,NULL)) != NULL) {', 1]
['data->sub->fn->release(data->sub, 0);', 1]
['bool cmp_read_bool(cmp_ctx_t *ctx, bool *b) {', 1]
['databuf.end = cur;', 1]
['#if (defined(__i386__) || defined(__x86_64__)  || defined(_M_IX86))', 1]
['//debugstuff', 1]
['redisContext *dummy_ctx = redisConnectUnix(config.unix.path);', 1]
['nchan_store_subscribe_continued(SUB_CHANNEL_NOTSURE, NULL, d);', 1]
['*d = obj->as.u64;', 1]
['int         max_cmp = -1, min_cmp = -1;', 1]
['ngx_uint_t              subscriber_id;', 1]
['void shm_locked_free(shmem_t *shm, void *p) {', 1]
['redisAppendCommand(c,"PING");', 1]
['ERR("unsub all except not yet  implemented");', 1]
['* **`REDIS_ERR_PROTOCOL`**:', 1]
['static shm_data_t      *shdata = NULL;', 1]
['clnf->log = pool->log;', 1]
['bc.buf.start = (u_char *)"0\\r\\n\\r\\n";', 1]
['//set up message buffer;', 1]
['uint8_t                    multi;', 1]
['if (c->flags & REDIS_SUBSCRIBED)', 1]
['head->channel.subscribers++;', 1]
['(addhh)->hh_prev = NULL;                                                        \\', 1]
['nchan_store_channel_head_t  *chanhead = NULL;', 1]
['ngx_close_file(f->fd);', 1]
['dst->tag = src->tag;', 1]
['sds sdscatvprintf(sds s, const char *fmt, va_list ap) {', 1]
['#define HASH_ADD_TO_BKT(head,addhh)                                              \\', 1]
['to cannot be resolved.', 1]
['nchan_msg_status_t  msg_status;', 1]
['"  messages=     \'channel:messages:\'..id, --list\\n"', 1]
['ifndef AE_DIR', 1]
['msg->prev->next = msg->next;', 1]
['case 6:  _hj_j += ( (unsigned)_hj_key[5] << 8 );                            \\', 1]
['getmsg_chid = (multi == NULL) ? &ids[i] : &multi[i].id;', 1]
['/* Search and remove an element */', 1]
['_thh = (head)->hh.tbl->buckets[_bkt_i].hh_head;                      \\', 1]
['//DBG("%p (%V) memstore subscriber (lastid %V) respond with message %V (lastid %V)", d->sub, d->chid, msgid_to_str(&d->sub->last_msg_id), msgid_to_str(&msg->id), msgid_to_str(&msg->prev_id));', 1]
['nchan_msg_id_t             max;', 1]
['subscriber_t                *subscriber;', 1]
['head->internal_sub_count -= count;', 1]
['void                        (*bulk_post_subscribe_handler)(channel_spooler_t *, int, void *);', 1]
['strcmp(c->errstr,"no address associated with name") == 0));', 1]
['//      * arrive in a single packet, causing all callbacks to be executed in', 1]
['static subscriber_pool_t *spoolcollector_unwind_nextspool(spooler_respond_data_t *data) {', 1]
['test("Format command with %%b and an empty string: ");', 1]
['if(spool->bulk_dequeue_handler) {', 1]
['if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {', 1]
['ngx_int_t ipc_register_worker(ipc_t *ipc, ngx_cycle_t *cycle) {', 1]
['"  redis.call(\'EXPIRE\', key.subscriber_id, channel.ttl)\\n"', 1]
['* any workers are spawned. Rather than futzing around with existing', 1]
['static void redis_load_script_callback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['ngx_memcpy(frame->mask_key, buf.start, 4);', 1]
['static rbtree_walk_direction_t compare_msgid_onetag_range(nchan_msg_id_t *min, nchan_msg_id_t *max, nchan_msg_id_t *id) {', 1]
['&& CHECK_REPLY_STRVAL(reply->element[0], "unsubscribe")', 1]
['file->log=log;', 1]
['if((blob = allocator(sizeof(*blob) + len + content_type_len + es_event_len))==NULL) {', 1]
['return nchan_subscriber_directive_parse(cf, cmd, conf, 1);', 1]
['static int _dictExpandIfNeeded(dict *ht);', 1]
["if no_msgid_order == 'FIFO' then --most recent message", 1]
['S64_MARKER             = 0xD3,', 1]
['ngx_int_t       n = 0;', 1]
['"if not channel.max_stored_messages then\\n"', 1]
['multi_subs = chanhead->shared->sub_count;', 1]
['callback_pt     callback;', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "NCHAN:" fmt, ##args)', 1]
['test_cond(reply->type == REDIS_REPLY_INTEGER && reply->integer == 1)', 1]
['if(conf->pubsub_chid.n == 0) {', 1]
['subdebug_head = sub;', 1]
['static int redisLibeventAttach(redisAsyncContext *ac, struct event_base *base) {', 1]
['ipc_writebuf_overflow_t  *overflow;', 1]
['max = id1->tagcount;', 1]
['} redisCallbackList;', 1]
['/* Return the total size of the allocation of the specifed sds string,', 1]
['buf->pos = buf->last;', 1]
['//WTF?', 1]
['ngx_atomic_fetch_add(&head->shared->sub_count, -count);', 1]
['//redisAsyncContext **context = privdata;', 1]
['"  messages=     \'channel:messages:\'..id,\\n"', 1]
['spool_respond_general(newspool, NULL, NGX_HTTP_NO_CONTENT, NULL);', 1]
['* On out of memory, zero length string, zero length', 1]
['if (write_byte(ctx, value))', 1]
['static redisContext *connect(struct config config) {', 1]
['&websocket_enqueue,', 1]
['bc.buf.pos = end_boundary;', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_UPGRADE, &NCHAN_WEBSOCKET);', 1]
['if (vector == NULL) vector = malloc(sizeof(void*));', 1]
['"  for i = 1, #nearly_departed do\\n"', 1]
['ac->ev.addRead  = redisLibuvAddRead;', 1]
['static ngx_int_t spool_remove_subscriber(subscriber_pool_t *, spooled_subscriber_t *);', 1]
['/* Reads a signed integer that fits inside a signed char */', 1]
['if (ev->timedout) {', 1]
['nchan_reaper_start(&m->msg_reaper,', 1]
["//lots of copypasta here, but it's the fastest way for me to write these IPC handlers", 1]
['ngx_http_complex_value(sub->request, authorize_request_url_ccv, &auth_request_url);', 1]
['uint8_t i;', 1]
['"local store_at_most_n_messages = ARGV[7]\\n"', 1]
['memstore_fakeprocess_push(PUB_FAKE_WORKER);', 1]
['redisAppendCommand(context,"SET foo bar");', 1]
['else if(ngx_strmatch(&msg_type, "ch+msgkey")) {', 1]
['bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size);', 1]
['*oldid = *newid;', 1]
['nchan_parse_msg_tag(split, last, id);', 1]
['assert(ssub->next != ssub);', 1]
['ngx_log_debug0(NGX_LOG_DEBUG_HTTP, wev->log, 0, "http writer delayed");', 1]
['/* Reads a boolean from the backend */', 1]
['nchan_set_storage_engine,', 1]
['uv_loop_t* loop = uv_default_loop();', 1]
['bool cmp_read_s16(cmp_ctx_t *ctx, int16_t *s);', 1]
['ERR("verify_msg_id: not a multimsg tag, different times. could be a missed message.");', 1]
['"dbg(\' #######  GET_MESSAGE ######## \')\\n"', 1]
['bool cmp_read_ulong(cmp_ctx_t *ctx, uint64_t *u) {', 1]
['uint32_t _sfh_tmp, _sfh_len = keylen;                                          \\', 1]
['ngx_int_t memstore_ipc_send_subscribe(ngx_int_t owner, ngx_str_t *shm_chid, nchan_store_channel_head_t *, nchan_loc_conf_t *);', 1]
['//force delete is always ok', 1]
['info: "Interval for sending websocket ping frames. Disabled by default."', 1]
['* Redistributions in binary form must reproduce the above copyright', 1]
['const ngx_str_t NCHAN_WEBSOCKET = ngx_string("websocket");', 1]
['return (void *)((char *)thing + rp->next_ptr_offset);', 1]
["case '5': return 5;", 1]
['redis.evalsha hashes[:delete], [], [ch_id]', 1]
['c->write->handler = NULL;', 1]
['ngx_str_t    *str;', 1]
['memset(_he_new_buckets, 0,                                                   \\', 1]
['"    --replace subscribers count with fake_subscribers\\n"', 1]
['return ngx_memn2cmp(((ngx_str_t *)id1)->data, ((ngx_str_t *)id2)->data, ((ngx_str_t *)id1)->len, ((ngx_str_t *)id2)->len);', 1]
['fsub->shook_hands = 1;', 1]
['"--input:  keys: [], values: [channel_id, time, message, content_type, eventsource_event, msg_ttl, max_msg_buf_size]\\n"', 1]
['endef', 1]
['unsigned                     shutting_down:1;', 1]
['* argument lengths.', 1]
['return sdsnewlen("",0);', 1]
['case RBTREE_WALK_STOP:', 1]
['size_t totlen = sh->free+sh->len;', 1]
['static const int32_t _i = 1;', 1]
['extern const ngx_str_t NCHAN_VARY_HEADER_VALUE;', 1]
['ERR("couldn\'t allocate memstore-redis subscriber data");', 1]
['DBG("writebuf overflow, allocating memory");', 1]
['/* Try again later when connect(2) is still in progress. */', 1]
['static bool cmp_err(cmp_ctx_t *cmp) {', 1]
['U16_MARKER             = 0xCD,', 1]
['struct nchan_msg_s             *reload_next;', 1]
['### Pipelining', 1]
['The functions that can be used to issue commands in an asynchronous context are:', 1]
['bool cmp_read_long(cmp_ctx_t *ctx, int64_t *d) {', 1]
['tags1 = id1->tag.fixed;', 1]
['if(ngx_time() - alert->time_sent >= 2) {', 1]
['static u_char   fn_buf[512];', 1]
["case 's':", 1]
['(dst)->hh_dst.tbl->num_items++;                                      \\', 1]
['uint64_t                    i;', 1]
['/* Should not happen... */', 1]
['responsible for creating instances of the `redisReply` can be customized by', 1]
['dynamic: $(DYLIBNAME)', 1]
["dbg(' #######  GET_MESSAGE ######## ')", 1]
['//output: message_tag, channel_hash', 1]
['* in both hashes. There is no copy of the items made; rather', 1]
['nchan_conf_publisher_types_t *pubt = &lcf->pub;', 1]
['sds sdscpy(sds s, const char *t) {', 1]
['bool cmp_object_is_nil(cmp_object_t *obj);', 1]
['assert(seed->allocd_nodes == 0);', 1]
['const  ngx_str_t NCHAN_HEADER_ORIGIN = ngx_string("Origin");', 1]
['test("Returns error when host cannot be resolved: ");', 1]
['msg_rsv_dbg_t         *prev;', 1]
['static nchan_loc_conf_t             *dummy_config_ptr = NULL;', 1]
['ngx_int_t nchan_subscriber_subscribe(subscriber_t *sub, ngx_str_t *ch_id);', 1]
['/* ineffective expands occur when a bucket doubling was performed, but', 1]
['void                       *add_handler_privdata;', 1]
['//     /* Reset callback flags */', 1]
['params->db = 0;', 1]
['ERR("unable to allocate buf and chain for EventSource response line %V", fmt);', 1]
['void                        (*dequeue_handler)(channel_spooler_t *, subscriber_t *, void *);', 1]
['/* Reads the size of packed binary data from the backend */', 1]
['b->last = ngx_snprintf(b->start, 512, (char *)format->data, messages, last_seen==0 ? -1 : (ngx_int_t) time_elapsed, subscribers, msgid_to_str(last_msgid));', 1]
['"--set new message id\\n"', 1]
['static dictEntry *dictNext(dictIterator *iter) {', 1]
['* library functions are already set. */', 1]
['enum connection_type type;', 1]
['ngx_fd_t nchan_fdcache_get(ngx_str_t *filename);', 1]
['_hs_psize = 0;                                                     \\', 1]
['#define MUR_GETBLOCK(p,i) (MUR_PLUS0_ALIGNED(p) ? ((p)[i]) :           \\', 1]
['typedef struct channel_spooler_s channel_spooler_t; //holds many different spools', 1]
['nchan_msg_id_t                 msg_id;', 1]
['ngx_memcpy(&len, frame->header, 2);', 1]
['obj->as.flt = befloat(obj->as.flt);', 1]
['static const ngx_str_t          NO_CHANNEL_ID_MESSAGE = ngx_string("No channel id provided.");', 1]
['id->time = time;', 1]
['test_cond(len == -1);', 1]
['size_t sdsavail(const sds s);', 1]
['.port = 6379', 1]
['bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size);', 1]
['bool cmp_object_as_uchar(cmp_object_t *obj, uint8_t *c) {', 1]
['assert(shdata->msgdebug_head == NULL);', 1]
['assert(ch->shared->stored_message_count == ch->channel.messages);', 1]
['0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1', 1]
['d->callback(d->channel_exists, NULL, d->privdata);', 1]
['local subs_count = tonumber(channel.subscribers)', 1]
['int       i;', 1]
['if (obj.type != CMP_TYPE_FIXEXT4) {', 1]
['uint32_t  array_size;', 1]
['bool cmp_read_sfix(cmp_ctx_t *ctx, int8_t *c);', 1]
['va_list cpy;', 1]
['ngx_int_t           channel_status;', 1]
['* Writes a floating-point value (either single or double-precision) to the', 1]
['#define SUB_CHANNEL_NOTSURE 2', 1]
['bool cmp_read_fixext8(cmp_ctx_t *ctx, int8_t *type, void *data) {', 1]
['was successfully added to the output buffer and `REDIS_ERR` otherwise. Example: when the connection', 1]
['config.tcp.timeout.tv_sec = (((LONG_MAX) - 999) / 1000) + 1;', 1]
['/* This is the initial size of every hash table */', 1]
['static ngx_int_t internal_release(subscriber_t *self, uint8_t nodestroy) {', 1]
['info: "The size of the shared memory chunk this module will use for message queuing and buffering."', 1]
['sd->n = i;', 1]
['if (obj.type != CMP_TYPE_UINT32) {', 1]
['#define NGX_MAX_INT_T_VALUE  9223372036854775807', 1]
['int nsec = (x->tv_usec - y->tv_usec) / 1000000;', 1]
['_dst_hh->key = _src_hh->key;                                         \\', 1]
['#ifndef __REDIS_NGINX_ADAPTER_H', 1]
['char **_da_dst = (char**)(&(dst));                                             \\', 1]
['void *nchan_thingcache_init(char *name, void *(*create)(ngx_str_t *), ngx_int_t(*destroy)(ngx_str_t *, void *), ngx_uint_t ttl) {', 1]
['channel_info_data_t        data;', 1]
['len = len < (sizeof(c->errstr)-1) ? len : (sizeof(c->errstr)-1);', 1]
['unsigned _hb_keylen=keylen;                                                    \\', 1]
['sdsrange(y,100,100);', 1]
['def test_nomessage', 1]
['//ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "REDIS: PUB/SUB subscribed to %s, chanhead %p now READY.", reply->element[1]->str, chanhead);', 1]
['c->flags |= REDIS_FREEING;', 1]
['if (_prev != (char*)(_thh->hh_prev)) {                            \\', 1]
['rwl_lock_mutex(lock);                             \\', 1]
['if (redisSetReuseAddr(c) == REDIS_ERR) {', 1]
['int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len);', 1]
['return {err="fakesub number not given"}', 1]
['int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {', 1]
['if(newspool != NULL) {', 1]
['"  local msg=tohash(redis.call(\'HGETALL\', key.message))\\n"', 1]
['if (keep_fd)', 1]
['static void redisAeAddRead(void *privdata) {', 1]
['#include <adapters/ae.h>', 1]
['"  sub_count=redis.call(\'hget\', keys.channel, \'subscribers\')\\n"', 1]
['int i, max = newid->tagcount;', 1]
['char *_prev;                                                                 \\', 1]
['sub->fn->set_dequeue_callback(sub, ws_publisher_dequeue_callback, sub_link);', 1]
['dbg(("Stored message with id %i:%i => %s"):format(msg.time, msg.tag, msg.data))', 1]
['In an asynchronous context, commands are automatically pipelined due to the nature of an event loop.', 1]
['static ngx_str_t         transfer_encoding_header = ngx_string("Transfer-Encoding");', 1]
['ngx_int_t    i, max, valid;', 1]
['local time=tonumber(ARGV[2])', 1]
['assert(allocd_before - n == 0);', 1]
['* least significant bit of the flags field in redisContext. */', 1]
['subscriber_t *memstore_ipc_subscriber_create(ngx_int_t originator_slot, ngx_str_t *chid, uint8_t use_redis, void* foreign_chanhead);', 1]
['#define DICT_OK 0', 1]
['time = ngx_atoi(str->data, split - str->data);', 1]
['DBG("receive subscribe proceed to do ipc_sub stuff");', 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_DELETE, &data, sizeof(data));', 1]
['* It processes all replies that can be read and executes their callbacks.', 1]
['int redis_nginx_event_attach(redisAsyncContext *ac);', 1]
['* by reference to the number of tokens returned.', 1]
['assert(ch->owner == ch->slot);', 1]
['bool cmp_object_is_double(cmp_object_t *obj);', 1]
['* replies to return and returns one if so. Otherwise, it flushes the output', 1]
['redisReply *r = calloc(1,sizeof(*r));', 1]
['#define cmp_write_int      cmp_write_integer', 1]
['static ngx_inline ngx_uint_t nchan_hash_str(u_char *src, size_t n) {', 1]
['fwd_buf_to_str(mpbuf, sz, str);', 1]
['ngx_free(sdata);', 1]
['size_t                          shm_size;', 1]
['"if numsub > 0 then\\n"', 1]
['examples: $(EXAMPLES)', 1]
['#if defined(__sun__)', 1]
['publish_msg->prev_id.tag.fixed[0] = 0;', 1]
['static ngx_int_t channel_info_callback(ngx_int_t status, void *rptr, ngx_http_request_t *r) {', 1]
['ERR("Couldn\'t allocate memory for alert glob data.");', 1]
['#define CLOSE_MESSAGE_TOO_BIG        1009', 1]
['#define _BSD_SOURCE', 1]
['if (!write_type_marker(ctx, STR32_MARKER))', 1]
['if (obj.type != CMP_TYPE_EXT8) {', 1]
['redisReader *r;', 1]
['DBG("might want msgid %V from chan_index %i", msgid_to_str(&req_msgid[i]), i);', 1]
['s[j] = to[i];', 1]
['wb->overflow_n++;', 1]
['_thh->hh_prev, _prev );                                      \\', 1]
['typedef struct dictIterator {', 1]
['static void redisAeDelWrite(void *privdata) {', 1]
['#define REDIS_SUBSCRIBED 0x20', 1]
['ERR("can\'t allocate memory for publisher auth subrequest body");', 1]
['bool cmp_write_u32(cmp_ctx_t *ctx, uint32_t i);', 1]
['ngx_int_t                    multi_subs;', 1]
["static u_char           chunk_start[15]; //that's enough", 1]
['test_cond("sdsIncrLen() -- free", sh->free == oldfree-1);', 1]
['int port;', 1]
['bool cmp_object_is_int(cmp_object_t *obj);', 1]
['ERR("got chanhead %p for id %V", ch, chid);', 1]
['if(CHECK_REPLY_INT(el)) {', 1]
['/* Custom reply functions are not supported for pub/sub. This will fail', 1]
['static const subscriber_fn_t longpoll_fn = {', 1]
['ngx_http_request_t            *r = fsub->sub.request;', 1]
['&internal_enqueue,', 1]
['void                           *data;', 1]
['* If no reply could be parsed, continue at *2*', 1]
['debug_pool_str.len = 0;', 1]
['#define IPC_SUBSCRIBER_KEEPALIVE    17', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_ALLOW_ORIGIN,  allow_origin);', 1]
['32bit:', 1]
['lock->write_pid=ngx_pid;', 1]
['for i = 1, #nearly_departed do', 1]
['ngx_int_t         ret;', 1]
['"  channel.max_stored_messages =tonumber(channel.max_stored_messages)\\n"', 1]
['d->channel_id=channel_id;', 1]
['owner = memstore_channel_owner(chid);', 1]
['cd->allocd=1;', 1]
['d->n = n;', 1]
['#define MEMSTORE_REDIS_SUBSCRIBER_TIMEOUT 10', 1]
['ht->type = type;', 1]
['static redis_connect_params_t *parse_redis_url(ngx_str_t *url) {', 1]
['#ifdef _MSC_VER', 1]
['for (j = 0; j < 10; j++) {', 1]
['current = sdscatlen(current,"\'",1);', 1]
["* in a Redis client you can't afford to test if you have IPv6 connectivity", 1]
['fsub->data.timeout_handler(&fsub->sub, fsub->data.timeout_handler_data);', 1]
['#ifndef NCHAN_RBTREE_UTIL_HEADER', 1]
['ngx_msec_t              t;', 1]
['ngx_int_t chanhead_gc_withdraw(nchan_store_channel_head_t *ch, const char *reason) {', 1]
['ngx_uint_t                  key = ngx_hash_key(channel_id_var_name.data, channel_id_var_name.len);', 1]
["if (*s == '-') {", 1]
['#include <util/nchan_thingcache.h>', 1]
['keyptr,keylen,out);                                      \\', 1]
['FIXARRAY_SIZE        = 0xF,', 1]
["void *key;                        /* ptr to enclosing struct's key  */", 1]
['ngx_int_t nchan_thingcache_shutdown(void *tcv);', 1]
['a new connection.', 1]
['redisAsyncContext               *sub_ctx;', 1]
['if (i < 0) {', 1]
['s = sdscatlen(s,"\\"",1);', 1]
['obj->type = CMP_TYPE_FLOAT;', 1]
['Pieter Noordhuis (pcnoordhuis at gmail) and is released under the BSD license.', 1]
["traverse_order=((Hash === opt) && opt[:getfirst]) ? 'FIFO' : 'FILO'", 1]
['if(use_redis) {', 1]
['offsetof(nchan_loc_conf_t, longpoll_multimsg),', 1]
['cur = &whole->ll;', 1]
['To disconnect and free the context the following function can be used:', 1]
["/* Hold the regular context, so it can be realloc'ed. */", 1]
['bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s) {', 1]
['len = ngx_buf_size(chain->buf);', 1]
["//double-check that it's gone", 1]
['c = redisConnect(config.tcp.host, config.tcp.port);', 1]
['websocket_publish(fsub, &msgbuf);', 1]
['else if(rp->first == cur) {', 1]
['"local pubsub=     \'channel:pubsub:\'..id\\n"', 1]
['msg = arg.first', 1]
["* do it all at once. So we must guess all the workers' ngx_process_slots in", 1]
['CHAN_PUBLISH, CHAN_DELETE', 1]
['char *publish_status;', 1]
['spool_remove_subscriber(spool, d->ssub);', 1]
['nchan_msg_id_t *nchan_subscriber_get_msg_id(ngx_http_request_t *r) {', 1]
['ctx->sub = &fsub->sub; //gonna need this for recv', 1]
['#define dictGetEntryVal(he) ((he)->val)', 1]
['#include <ngx_sha1.h>', 1]
['alert= &overflow->alert;', 1]
["//subscriber channel is not given, because we don't care to subscribe", 1]
['#define WEBSOCKET_OPCODE_PONG               0xA', 1]
['ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */', 1]
['* A spontaneous reply in a not-subscribed context can be the error', 1]
['spooled_subscriber_t         *next;', 1]
['bool cmp_read_fixext4_marker(cmp_ctx_t *ctx, int8_t *type) {', 1]
['ngx_int_t nchan_reaper_stop(nchan_reaper_t *rp);', 1]
['hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] << 8 )                         \\', 1]
['if lasttime==msg.time then', 1]
['channel_spooler_t  *spooler;', 1]
['//destroy channel tree in shared memory', 1]
['HASH_MAKE_TABLE(hh,head);                                                    \\', 1]
['u_char         *last = cur + id->len;', 1]
["//we know the entity length, and we're using just one buffer. so no chunking please.", 1]
['nchan_reloading_channel_t   *rlch;', 1]
['ngx_int_t msg_reserve(nchan_msg_t *msg, char *lbl) {', 1]
['"if code==nil then\\n"', 1]
["/* Like sdscpylen() but 't' must be a null-termined string so that the length", 1]
['sub_data_t *d = (sub_data_t *)ev->data;', 1]
['ctx->channel_event_name = &evt_sub_recvsts;', 1]
['if (cb == list->tail)', 1]
['/* The following lines make up our testing "framework" :) */', 1]
['obj->type = CMP_TYPE_ARRAY16;', 1]
['/* List of callbacks for either regular replies or pub/sub */', 1]
['DBG("%s rotatey max notready %i", rp->name, max_notready);', 1]
['ngx_int_t memstore_ipc_send_publish_message(ngx_int_t dst, ngx_str_t *chid, nchan_msg_t *shm_msg, nchan_loc_conf_t *cf, callback_pt callback, void *privdata) {', 1]
['int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {', 1]
['ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "request timed out");', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:INTERVALPOLL:" fmt, ##arg)', 1]
['nchan_auth_subrequest_data_t  *d = data;', 1]
['head->multi_count = n;', 1]
['#define _POSIX_C_SOURCE 200112L', 1]
['frame->mask = (frame->header[1] >> 7) & 1;', 1]
['s = seekNewline(p,(r->len-r->pos));', 1]
['num = 10000;', 1]
['sign = -1;', 1]
['value: ["oldest", "newest"],', 1]
['thing_t              t;', 1]
['ngx_rbtree_node_t              node;', 1]
['sdslen(x) == 3 && memcmp(x,"123\\0",4) ==0)', 1]
['nchan_loc_conf_t       *lcf = ngx_pcalloc(cf->pool, sizeof(*lcf));', 1]
['bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c) {', 1]
['if (u <= 0xFFFF)', 1]
['(head).count--;                                                              \\', 1]
['test_cond("sdsrange(...,1,-1)",', 1]
['if(!is_multi_id(channel_id)) {', 1]
['* multiplier is to reduce bucket expansions, since they are expensive, in', 1]
['ngx_int_t                       slot;', 1]
['cur = ret;', 1]
['ngx_int_t        http_response_code;', 1]
['mmsg->next = NULL;', 1]
['ngx_int_t nchan_msg_buf_open_fd_if_needed(ngx_buf_t *buf, ngx_file_t *file, ngx_http_request_t *r);', 1]
['float df = (double)f;', 1]
['nchan_subscriber_subscribe(d->sub, d->ch_id);', 1]
['/*if(memstore_slot() != owner) {', 1]
["redis.call('EXPIRE', key.messages, channel.ttl)", 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "THINGCACHE: " fmt, ##args)', 1]
['test_cond("sdsIncrLen() -- len", sh->len == 2);', 1]
['lcf->sub.websocket=0;', 1]
['target_ch->spooler.fn->add(&target_ch->spooler, sub);', 1]
['va_arg(ap,long);', 1]
['self->last_responded_subscriber_count = responded_subs;', 1]
['return {200, ttl, tonumber(ntime) or "", tonumber(ntag) or "", tonumber(prev_time) or "", tonumber(prev_tag) or "", ndata or "", ncontenttype or "", neventsource_event or "", subs_count}', 1]
['const ngx_str_t NCHAN_CHANNEL_INFO_JSON = ngx_string(', 1]
['ngx_uint_t                  non_internal_sub_count;', 1]
['if(status == NGX_OK) {', 1]
['if (len >= content_length) {', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "unknown concurrency setting");', 1]
['bool cmp_object_as_map(cmp_object_t *obj, uint32_t *size);', 1]
['ngx_free(cd);', 1]
['redisReaderFeed(reader,(char*)"$5\\r\\nhello\\r\\n",11);', 1]
['static int redisLibuvAttach(redisAsyncContext* ac, uv_loop_t* loop) {', 1]
['if (!((tbl)->bloom_bv))  { uthash_fatal( "out of memory"); }                   \\', 1]
['return nearly_departed', 1]
['/* Try to add the element. If the key', 1]
['cur_out = (u_char *)&params[1];', 1]
['nchan_loc_conf_t   cf;', 1]
['//ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0, "http writer output filter: %d, \\"%V?%V\\"", rc, &r->uri, &r->args);', 1]
['PREFIX?=/usr/local', 1]
['return cmp_object_as_long(obj, d);', 1]
["/* We need to save the 'next' here, the iterator user", 1]
['CMP_TYPE_FLOAT,           /* 12 */', 1]
['ngx_pool_t                  *original_pool;', 1]
['void sdstrim(sds s, const char *cset);', 1]
['d->name = "find_channel";', 1]
['ngx_memcpy(msg_buf, msg->buf, sizeof(*msg_buf));', 1]
['nchan_match_channel_info_subtype(sizeof("application/")-1, cur, rem, &priority, &format, &channel_info_content_type);', 1]
['ERR("failed to allocate new sub for spool");', 1]
['/* Not used by hiredis */', 1]
['static void redisAeAddWrite(void *privdata) {', 1]
['{ ngx_string("push_store_messages"), //legacy for nchan_store_messages', 1]
['static void nchan_publisher_body_handler(ngx_http_request_t *r);', 1]
['#define IPC_SUBSCRIBER_KEEPALIVE_REPLY 18', 1]
['if(buf->last_buf == 1) {', 1]
['DBG("found message %V", msgid_to_str(&first->msg->id));', 1]
['bool cmp_write_bin_marker(cmp_ctx_t *ctx, uint32_t size) {', 1]
['hashv += hashv >> 5;                                                         \\', 1]
['//output: msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, channel_subscriber_count', 1]
['fsub->data.multimsg_first = NULL;', 1]
['ch.subscribers = d->subscribers;', 1]
['else if(cf->pub.http) {', 1]
['if(ngx_process_slot == shdata->procslot[i]) {', 1]
['return cur', 1]
['"  channel={}\\n"', 1]
['* To prevent the error from being overwritten by an EOF error the', 1]
['while(len--) {', 1]
['u_char       *host;', 1]
['cur[2]=NCHAN_MULTI_SEP_CHR;', 1]
['cln->handler = ngx_pool_cleanup_file;', 1]
['if (obj->type == CMP_TYPE_FLOAT)', 1]
['store_message_t                *msg_first;', 1]
['nchan_copy_new_msg_id(&data->msgid, &spool->id);', 1]
['redisContext c;', 1]
['DBG("start reaper %s with tick time of %i sec", name, tick_sec);', 1]
['nchan_msg_id_t                  prev_id;', 1]
['static u_char *fwd_buf(ngx_buf_t *buf, size_t sz) {', 1]
['&longpoll_respond_status,', 1]
['int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);', 1]
['data->n++;', 1]
['memcpy(dup,src,sizeof(*dup));', 1]
['callback_pt             respond_status;', 1]
['websocket_frame_header(hdr_buf, opcode, len);', 1]
['static void nchan_publisher_body_handler_continued(ngx_http_request_t *r, ngx_str_t *channel_id, nchan_loc_conf_t *cf) {', 1]
['static ngx_int_t chunked_respond_message(subscriber_t *sub,  nchan_msg_t *msg) {', 1]
['[:loc_conf, :storage_engine],', 1]
['reply = redisCommand(context, "SET foo bar");', 1]
['nchan_loc_conf_t          *cf = fsub->sub.cf;', 1]
['len = 0;', 1]
['if(buf->in_file) {', 1]
['sds sdscat(sds s, const char *t) {', 1]
['Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>', 1]
['if (d >= 0)', 1]
['"local channel\\n"', 1]
['u_char                         *start = cur + off;', 1]
['u_char   *cur;', 1]
['//reply->element[1] is the pubsub channel name', 1]
['shdata = d;', 1]
['bool cmp_write_s32(cmp_ctx_t *ctx, int32_t i);', 1]
['ngx_http_complex_value(r, idcf->cv[i], &id[n_out]);', 1]
['redisContext *c = redisContextInit();', 1]
['recycloc_t rec = NULL;', 1]
['else { //shorthand', 1]
['DBG("%p (%V) keepalive reply - renew: %i.", d->sub, d->chid, renew);', 1]
["local subs_key = 'channel:subscribers:'..id", 1]
['ngx_atomic_int_t  lock;', 1]
['ngx_event_t                *rev;', 1]
['totlen = sh->len+sh->free;', 1]
['bool cmp_read_fixext2_marker(cmp_ctx_t *ctx, int8_t *type) {', 1]
['if (sdslen(c->obuf) > 0) {', 1]
['typedef struct nchan_msg_s nchan_msg_t;', 1]
['va_list _cpy;', 1]
['if(wb->n < IPC_WRITEBUF_SIZE) {', 1]
['if (r->ridx == 8) {', 1]
['int redisContextSetTimeout(redisContext *c, const struct timeval tv) {', 1]
['int err = 0;', 1]
['buf = msg->buf;', 1]
['if(buf->pos + limit > buf->last){', 1]
['recycloc_llist_s *tail;', 1]
['/* Process items in reply. */', 1]
['sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);', 1]
['ngx_int_t nchan_copy_msg_id(nchan_msg_id_t *dst, nchan_msg_id_t *src, int16_t *largetags) {', 1]
["while ((c = *(s++)) != '\\r') {", 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_SUBSCRIBE, &data, sizeof(data));', 1]
['//ERR("send alert at %i", i % IPC_WRITEBUF_SIZE );', 1]
['use `strlen(3)` on every argument to determine its length. Obviously, when any of the arguments', 1]
['bool cmp_write_array32(cmp_ctx_t *ctx, uint32_t size) {', 1]
['"      dbg(\\"get oldest\\")\\n"', 1]
['spool->msg_status = MSG_EXPECTED;', 1]
['mid->tagcount = i;', 1]
['fsub->dequeue = empty_callback;', 1]
['* very hard when they are used... */', 1]
['cd->d = d;', 1]
['conf->shm_size=NCHAN_DEFAULT_SHM_SIZE;', 1]
['ngx_http_core_loc_conf_t               *clcf;', 1]
['if (hash < node->key) {', 1]
['do {                                                                   \\', 1]
['if (l1 != l2) return 0;', 1]
['r = createReplyObject(REDIS_REPLY_ARRAY);', 1]
['sdslen(x) == 2 && memcmp(x,"fo\\0",3) == 0)', 1]
['newlen = (len+addlen);', 1]
['assert(spool->id.time == msgid->time);', 1]
['//input:  keys: [], values: [channel_id, time, message, content_type, eventsource_event, msg_ttl, max_msg_buf_size]', 1]
['#define NCHAN_MESSAGE_QUEUED    9001', 1]
['fp = (ngx_flag_t *) (p + cmd->offset);', 1]
['(head)->hh.tbl->tail = _hs_tail;                                   \\', 1]
['*u = obj->as.u64;', 1]
['*b = 0;', 1]
['if(! tc->gc_timer.timer_set) {', 1]
['int msglen = 0;', 1]
['0, //stick around after response', 1]
['bool cmp_object_is_map(cmp_object_t *obj) {', 1]
['* We want that to work, but by changing the head (users) below', 1]
['|N|V|V|V|       |S|             |   (if payload len==126/127)   |', 1]
['if(d->msg) {', 1]
['-- have a solution to this, please help.', 1]
['CMP_TYPE_FIXSTR,          /*  3 */', 1]
['--input:  keys: [], values: [channel_id, status_code]', 1]
['} redisReader;', 1]
['if (temp_pool == NULL) {', 1]
['if(ctx) ctx->publisher_type = &publisher_name;', 1]
['(HASH_BLOOM_BYTELEN)))', 1]
['/examples/hiredis-example*', 1]
["key.last_message=('channel:msg:%s:%s'):format(channel.current_message, id)", 1]
['static redisAsyncContext * rds_ctx(void);', 1]
['ngx_int_t                       subscribers;', 1]
['alert.time_sent = ngx_time();', 1]
['nchan_request_ctx_t  *ctx = ngx_http_get_module_ctx(fsub->sub.request, nchan_module);', 1]
['ac->sub.patterns = dictCreate(&callbackDict,NULL);', 1]
['memstore_ipc_send_delete(owner, channel_id, callback, privdata);', 1]
['ngx_int_t nchan_detect_chunked_subscriber_request(ngx_http_request_t *r);', 1]
['sign=1;', 1]
['msg->eventsource_event = *eventsource_event;', 1]
['ngx_str_t   *tmp_etag = msgid_to_str(&msg->id);', 1]
['ev_loop(EV_DEFAULT_ 0);', 1]
['extern const ngx_str_t NCHAN_HEADER_SEC_WEBSOCKET_ACCEPT;', 1]
['ngx_int_t memstore_redis_subscriber_destroy(subscriber_t *sub) {', 1]
['msg_tag=0 if msg_time && msg_tag.nil?', 1]
['struct resp_s {', 1]
['spooler_respond_status,', 1]
['ngx_str_t    *content_type = (r->headers_in.content_type ? &r->headers_in.content_type->value : NULL);', 1]
['cmp_init(&cmp, &mpbuf, ngx_buf_reader, ngx_buf_writer);', 1]
['if(nchan_parse_compound_msgid(&id, &str) == NGX_OK) {', 1]
['uint16_t        messages;', 1]
['if (!cmp_read_bin_size(ctx, &bin_size))', 1]
['--set expiration times for all the things', 1]
['ngx_free(smsg);', 1]
['ngx_pool_t                 *temp_pool = NULL;', 1]
['obj->as.map_size = type_marker & FIXMAP_SIZE;', 1]
['typedef struct UT_hash_bucket {', 1]
['DBG("get multi msg %V (count: %i)", msgid_to_str(msg_id), n);', 1]
['chanhead_cleanlink->data=(void *)head;', 1]
['#define ERR(...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, __VA_ARGS__)', 1]
['replies[i] = redisCommand(c,"LRANGE mylist 0 499");', 1]
['rp->prev_ptr_offset = prev;', 1]
['{ ngx_string("push_max_channel_id_length"), //legacy for nchan_max_channel_id_length', 1]
['#include <subscribers/websocket.h>', 1]
['{ ngx_string("nchan_storage_engine"),', 1]
['return rec;', 1]
['#define HTTP_MULTIPART_STRINGS "multipart", "multipart/mixed", "http-multipart", "multipart-mixed"', 1]
['if status == 404', 1]
['nchan_msg_t               *shm_msg;', 1]
['bool cmp_object_is_char(cmp_object_t *obj) {', 1]
['u_char              *cur;', 1]
['if (!write_type_marker(ctx, BIN32_MARKER))', 1]
['void sdsclear(sds s);', 1]
['The function `redisAsyncConnect` can be used to establish a non-blocking connection to', 1]
['while (_thh) {                                                       \\', 1]
['* Redistributions of source code must retain the above copyright notice,', 1]
["if (s[pos] != '\\r') {", 1]
['data= ARGV[3],', 1]
['conf->publisher_upstream_request_url = prev->publisher_upstream_request_url;', 1]
['#define NCHAN_RBTREE_UTIL_HEADER', 1]
['u_char *nchan_strsplit(u_char **s1, ngx_str_t *sub, u_char *last_char);', 1]
['static void nchan_parse_msg_tag(u_char *first, u_char *last, nchan_msg_id_t *mid) {', 1]
['"Specified array length is too long (> 0xFFFFFFFF)",', 1]
['if(t[i] != -1) {', 1]
['static ngx_int_t chanhead_delete_message(nchan_store_channel_head_t *ch, store_message_t *msg) {', 1]
['* the output will be "6" as the string was modified but the logical length', 1]
['static ngx_int_t spool_rbtree_compare(void *v1, void *v2) {', 1]
['"5657fcddff1bf91ec96053ba2d4ba31c88d0cc71",', 1]
['void * recycloc_alloc(recycloc_t *self);', 1]
['static void redisLibevCleanup(void *privdata) {', 1]
["local num_messages = redis.call('llen', key.messages)", 1]
['rp->timer.handler = reaper_timer_handler;', 1]
['"No support for nested multi bulk replies with depth > 7");', 1]
['ngx_int_t                owner = memstore_channel_owner(channel_id);', 1]
['void ngx_rwlock_release_write(ngx_rwlock_t *lock) {', 1]
['if (dictCompareHashKeys(ht,key,de->key)) {', 1]
['if(spool->type == SHORTLIVED) {', 1]
['redis_subscriber_unregister(&head->id, sub);', 1]
['{ ngx_string("nchan_prev_message_id"),    nchan_prev_message_id_variable, 0},', 1]
['old_shared = head->shared;', 1]
['static void __redisReaderSetErrorOOM(redisReader *r) {', 1]
['int n = sizeof(store_rds_lua_hashes)/sizeof(char*);', 1]
['int redisGetReply(redisContext *c, void **reply) {', 1]
['* Returns the reply when a reply was succesfully retrieved. Returns NULL', 1]
['lcf->pub.websocket=0;', 1]
['sds.o: sds.c sds.h', 1]
['/* Read a long long value starting at *s, under the assumption that it will be', 1]
['ERR("chanhead %p (%V) is still in use.", ch, &ch->id);', 1]
['DBG("Chanhead churn add %p %V", ch, &ch->id);', 1]
["* on an error. valgrind will bark when this doesn't happen. */", 1]
['pidfile /tmp/hiredis-test-redis.pid', 1]
['unsigned _hd_bkt;                                                            \\', 1]
['ngx_int_t nchan_store_redis_connection_close_handler(redisAsyncContext *ac);', 1]
['/* Functions to format a command according to the protocol. */', 1]
['static ngx_str_t        data_prefix=ngx_string("data: ");', 1]
['* The command replied with a **nil** object. There is no data to access.', 1]
['if(ipc_sub) {', 1]
['ac->ev.addWrite = redisAeAddWrite;', 1]
['else if (spl->bulk_dequeue_handler){', 1]
['DBG("IPC: received publish request for channel %V  msg %p", d->shm_chid, d->shm_msg);', 1]
['bool      boolean;', 1]
['chanhead_messages_gc(chead);', 1]
['ac->onConnect = fn;', 1]
['int nchan_timeval_subtract(struct timeval *result, struct timeval *x, struct timeval *y) {', 1]
['nchan_reaper_withdraw(&mpt->chanhead_reaper, ch);', 1]
["sh->buf[0] = '\\0';", 1]
['return cmp_write_map32(ctx, size);', 1]
['char *cstr, *astr;', 1]
['ngx_connection_t        *c = ev->data;', 1]
['static nchan_msg_t * msg_from_redis_get_message_reply(redisReply *r, uint16_t offset, void *(*allocator)(size_t size));', 1]
['ngx_memzero(&rdt.cleanup_timer, sizeof(rdt.cleanup_timer));', 1]
['#define IPC_GET_MESSAGE_REPLY       10', 1]
['static ngx_str_t  sub_name = ngx_string("memstore-multi");', 1]
['MAP32_MARKER           = 0xDF,', 1]
['str.data = buf;', 1]
['if(slot_callback) {', 1]
['if((tmp = nchan_get_header_value(r, NCHAN_HEADER_CONNECTION))) {', 1]
['{ ngx_string("nchan_pub_channel_id"), //alt for nchan_publisher_channel_id', 1]
['(head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;              \\', 1]
['if (ac->onConnect == NULL) {', 1]
['struct recycloc_page_t  *next;', 1]
['u_char                  *cur;', 1]
["pvariant = (tolower(cstr[0]) == 'p') ? 1 : 0;", 1]
['static void memstore_reap_chanhead(nchan_store_channel_head_t *ch) {', 1]
['head=ngx_calloc(sizeof(*head) + sizeof(u_char)*(channel_id->len), ngx_cycle->log);', 1]
["else if(chr_int == (int )'\\n') {", 1]
['DBG("respond msg id transformed into %p %V", &retmsg, msgid_to_str(&retmsg.id));', 1]
['tbl->ineff_expands = (tbl->nonideal_items > (tbl->num_items >> 1)) ?         \\', 1]
['if ((ht)->type->keyDup) \\', 1]
['sds sdscatlen(sds s, const void *t, size_t len) {', 1]
['shm_size = ngx_align(shm_size, ngx_pagesize);', 1]
['HASH_FCN(keyptr,keylen_in, (head)->hh.tbl->num_buckets,                         \\', 1]
['DBG("Chanhead gc add %p %V: %s", head, &head->id, reason);', 1]
['return cmp_read_pfix(ctx, c);', 1]
['#define NCHAN_RBTREE_DBG 1', 1]
['nchan_reaper_start(&m->chanhead_churner,', 1]
['msg->msg->prev_id.tagcount = 1;', 1]
['/////////// FLOOD TEST ///////////', 1]
['"--  \'concurrency\' can be \'FIFO\', \'FILO\', or \'broadcast\'\\n"', 1]
['//else {', 1]
['void freeReplyObject(void *reply) {', 1]
['void *obj = NULL;', 1]
['sub->type = EVENTSOURCE;', 1]
['return i;', 1]
['nchan_llist_timed_t  *sub_link;', 1]
['bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c);', 1]
['if((cln = ngx_pool_cleanup_add(pool, sizeof(*clnf))) == NULL) {', 1]
['*_da_dst = (char*)(src);                                                       \\', 1]
['ERR("nchan: unable to allocate memory for callback data for message hmget");', 1]
['sr->request_body = ngx_pcalloc(sub->request->pool, sizeof(ngx_http_request_body_t)); //dummy request body', 1]
['nchan_reaper_t                  chanhead_reaper;', 1]
['bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size);', 1]
['return cmp_error_messages[ctx->error];', 1]
['*      ceil(n/b) = (n/b) + ((n%b)?1:0)', 1]
['## UPGRADING', 1]
['struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */', 1]
['s = n = cn = ln = 0;', 1]
['head->spooler.fn->add(&head->spooler, ipc_sub);', 1]
['ac->ev.addRead = redisLibevAddRead;', 1]
['return id', 1]
["//this is not a safe function -- it doesn't check if the thing is actually being reaped.", 1]
['[:loc_conf, :subscribe_only_existing_channel],', 1]
['if(err) {', 1]
['#define HASH_EXPAND_BUCKETS(tbl)                                                 \\', 1]
['ngx_shm_zone_t        *zone;', 1]
['sr->method = method;', 1]
["/* Create a new sds string with the content specified by the 'init' pointer", 1]
['data->overflow = overflow;', 1]
['ngx_buf_t       buf;', 1]
['fsub->cln->handler = (ngx_http_cleanup_pt )sudden_abort_handler;', 1]
['*size = obj.as.array_size;', 1]
['ERR("IPC_READ_SOCKET failed: bad connection. This should never have happened, yet here we are...");', 1]
['ngx_int_t nchan_store_redis_connection_close_handler(redisAsyncContext *ac) {', 1]
['sub = cur->sub;', 1]
['(head)->hh.tbl->hho = (char*)(&(head)->hh) - (char*)(head);                    \\', 1]
['static int processMultiBulkItem(redisReader *r) {', 1]
['d->n--;', 1]
['"redis.call(\'HSET\', key.channel, \'current_message\', msg.id)\\n"', 1]
['char *hash = &reply->str[script_error_start.len];', 1]
['rp->first = thing;', 1]
['bc[3].buf.last = bc[3].buf.end;', 1]
['DBG("%p (%V), timeout event. Ping originator to see if still needed.", d->sub, d->chid);', 1]
['nchan_publisher [:srv, :loc, :if],', 1]
['m << Msg.new(id, data: "whatever",ttl: 100, content_type: "X-fruit/banana")', 1]
['}; //msg_rsv_dbg_s', 1]
['assert(reply->elements >= 2);', 1]
['buf = malloc(len+1);', 1]
['while (pos < _len) {', 1]
['[:loc_conf, :eventsource_event],', 1]
['ngx_int_t                      owner = head->owner;', 1]
['if(msg_already_in_shm) {', 1]
['if(t1 > t2){', 1]
['if ((body = request_body)!=NULL) {', 1]
['info: "Enable sending multiple messages in a single longpoll response, separated using the multipart/mixed content-type scheme. If there is only one available message in response to a long-poll request, it is sent unmodified. This is useful for high-latency long-polling connections as a way to minimize round-trips to the server."', 1]
['found = rbtree_find_node_generic(seed, id, seed->hash(id), NULL, NULL);', 1]
['callback(NGX_OK, &chaninfo, privdata);', 1]
['minor = strtol(p,&eptr,10);', 1]
['} else {                                                                     \\', 1]
['return id;', 1]
[':ngx_conf_enable_redis,', 1]
['ngx_str_t               chid = ngx_null_string;', 1]
['} cmp_ctx_t;', 1]
['code using hiredis should not be a big pain. The key thing to keep in mind when', 1]
['return cmp_write_bin8_marker(ctx, size);', 1]
['va_start(args, n);', 1]
['extern const ngx_str_t NCHAN_HEADER_EVENTSOURCE_EVENT;', 1]
['if(publish_msg->buf && publish_msg->buf->file) {', 1]
['ngx_sha1_init(&sha1);', 1]
['ERR("IPC_DATA_SIZE too small. wanted %i, have %i", data_size, IPC_DATA_SIZE);', 1]
['"  return {err=\\"fakesub number not given\\"}\\n"', 1]
['} redisReply;', 1]
['head->channel.messages = 0;', 1]
['switch (_sfh_rem) {                                                            \\', 1]
['bc[2].buf.flush = 0;', 1]
['last = ws_pub_head.prev;', 1]
['_mur_h1 = MUR_ROTL32(_mur_h1,13);                                  \\', 1]
['sz += 3 + n_out; //space for null-separators and "m/<SEP>" prefix for multi-chid', 1]
['//content-type', 1]
['connection->read->handler = redis_nginx_read_event;', 1]
['_dst_hh->keylen = _src_hh->keylen;                                   \\', 1]
['//want websocket?', 1]
['x = sdsnew("xxciaoyyy");', 1]
['time_t                       time = msg_id->time;', 1]
['if (r->buffered || r->postponed || (r == r->main && c->buffered)) {', 1]
['if (ctx->read(ctx, data, 8))', 1]
['//ensure this message is present only once', 1]
['DBG("%p created memstore-redis subscriber created with privdata %p", d->sub, d);', 1]
["case ' ':", 1]
['rbtree_seed_t    *seed = (rbtree_seed_t *)((char *)sentinel - offset);', 1]
['_hs_nmerges = 0;                                                       \\', 1]
['return nchan_subscriber_subscribe(sub, ch_id);', 1]
['fsub->hdr_chain.next = &fsub->msg_chain;', 1]
['HASH_ADD_KEYPTR(hh,head,&((add)->fieldname),keylen_in,add)', 1]
['typedef struct redisAsyncContext {', 1]
['bool cmp_read_fixext1(cmp_ctx_t *ctx, int8_t *type, void *data) {', 1]
['//inrange', 1]
['if(mcount > NCHAN_FIXED_MULTITAG_MAX) {', 1]
['ngx_int_t memstore_fakeprocess_pop(void) {', 1]
['size_t                        len;', 1]
['str << "  //#{cmt[1]}"', 1]
['#define HASH_DEL(head,delptr)                                                    \\', 1]
['bool cmp_read_fixext4(cmp_ctx_t *ctx, int8_t *type, void *data) {', 1]
['seed->name=name;', 1]
['void redisAsyncDisconnect(redisAsyncContext *ac) {', 1]
['chanhead_gc_withdraw(head, "readying INACTIVE");', 1]
['b->end = body->data + body->len;', 1]
['"  redis.call(\'PUBLISH\', channel_pubsub, msgpacked)\\n"', 1]
['*thing_next_ptr(rp, rp->last) = cur;', 1]
['//just host', 1]
['void *redisvCommand(redisContext *c, const char *format, va_list ap) {', 1]
['((ipc_t *)c->data)->handler(alert.src_slot, alert.code, alert.data);', 1]
['uint8_t *bloom_bv;', 1]
['// if buffer is equal to content length all the content is in this buffer', 1]
['ctx->error = TYPE_MARKER_READING_ERROR;', 1]
['void *(*createString)(const redisReadTask*, char*, size_t);', 1]
['if(self->first == ssub) {', 1]
['* all the non-printable characters (tested with isprint()) are turned into', 1]
['ngx_free(shm);', 1]
['d->name = "get_message_from_key";', 1]
['void msg_debug_assert_isempty(void) {', 1]
['struct timeval           tv;', 1]
['"for k,channel_key in pairs(redis.call(\'SMEMBERS\', subscribers)) do\\n"', 1]
['obj->type = CMP_TYPE_FIXEXT16;', 1]
['extern const  ngx_str_t NCHAN_HTTP_STATUS_101;', 1]
['ngx_int_t                     originator;', 1]
['static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {', 1]
['if (p == NULL) return NULL;', 1]
['/* Reads an unsigned integer that fits inside an unsigned int */', 1]
['ngx_memcpy(dst->tag.allocd, src->tag.allocd, sz);', 1]
['return spool_respond_general(spool, d->msg, d->code, d->line);', 1]
['chanhead_gc_add(ch, "forced delete");', 1]
['#define redisReplyReaderFree redisReaderFree', 1]
['/* add the token to the vector */', 1]
['"return redis.call(\'HGET\', chan_key, \'subscribers\') or 0",', 1]
['was received:', 1]
['"<channel>" CRLF', 1]
["#define NCHAN_MULTI_SEP_CHR '\\0'", 1]
['cur = sep + 1;', 1]
['//not time yet', 1]
['int8_t    s8;', 1]
['cf->storage_engine->publish(channel_id, msg, cf, (callback_pt) &publish_callback, r);', 1]
['* sdsfreesplitres().', 1]
['if (wev->delayed || r->aio) {', 1]
['static ngx_int_t internal_set_timeout_callback(subscriber_t *self, subscriber_callback_pt cb, void *privdata) {', 1]
['/* nonideal_items is the number of items in the hash whose chain position', 1]
['"  redis.call(\'HSET\', key.channel, \'time\', time)\\n"', 1]
['When this function is called, the connection is **not** immediately terminated. Instead, new', 1]
['ngx_uint_t                   renew;', 1]
['} dictIterator;', 1]
['spooler_set_bulk_post_subscribe_handler', 1]
['ngx_memzero(spl, sizeof(*spl));', 1]
['* always a power of two. We keep its base 2 log handy (call it lb),', 1]
['p->context     = ac;', 1]
['if (!write_type_marker(ctx, MAP32_MARKER))', 1]
['if(newid->tagcount > NCHAN_FIXED_MULTITAG_MAX && oldid->tagcount < newid->tagcount) {', 1]
['info: "Set the [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) `Access-Control-Allow-Origin` header to this value. If the publisher or subscriber request\'s `Origin` header does not match this value, respond with a `403 Forbidden`."', 1]
['redisAsyncContext* context;', 1]
['fsub->msg_chain.buf = &fsub->msg_buf;', 1]
['if (!ctx->read(ctx, &ext_size, sizeof(uint16_t))) {', 1]
['reply = redisCommand(c,"DEL mylist");', 1]
['nchan_free_msg_id(&d->wanted_msgid);', 1]
['redisReply                    *reply=r;', 1]
['else if(ngx_strmatch(&alerttype, "unsub one") && array_sz > 3) {', 1]
['static void test_append_formatted_commands(struct config config) {', 1]
['ngx_add_timer(&data->timeout_ev, MEMSTORE_REDIS_SUBSCRIBER_TIMEOUT * 1000);', 1]
['ngx_event_t               *wev;', 1]
['unsigned long used;', 1]
['if(max->time > id->time || (max->time == id->time && max->tag.fixed[0] > id->tag.fixed[0])) {', 1]
['#define WEBSOCKET_FRAME_HEADER_MAX_LENGTH   146 //144 + 2 for possible close status code', 1]
['unprevid.tag[i] = msg->prev_id.tag[i];', 1]
['seed->active_nodes = 0;', 1]
['ctx->start_tv = tv;', 1]
["-- 'subscriber_id' is an existing id", 1]
['u_char *nchan_strsplit(u_char **s1, ngx_str_t *sub, u_char *last_char) {', 1]
['typedef struct nchan_longpoll_multimsg_s nchan_longpoll_multimsg_t;', 1]
['he->next = n.table[h];', 1]
['ipc_writebuf_overflow_t  *of, *of_next;', 1]
['nchan_llist_timed_t   *cur = tc->thing_head;', 1]
['ngx_str_t                     *subscriber_type;', 1]
['static ngx_int_t subscribe_existing_channel_callback(ngx_int_t status, void *ch, void *d) {', 1]
['/* Helper function for the redisAsyncCommand* family of functions. Writes a', 1]
['static redisAsyncContext *redisAsyncInitialize(redisContext *c) {', 1]
['l1 = sdslen(s1);', 1]
['ngx_int_t nchan_respond_string(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *content_type, const ngx_str_t *body, ngx_int_t finalize);', 1]
['case NGX_HTTP_NO_CONTENT: //message expired', 1]
['documentation and/or other materials provided with the distribution.', 1]
['size_t                      sz;', 1]
['static ngx_buf_t        data_prefix_real_buf;', 1]
['void               *privdata;', 1]
['if((dst->tag.allocd = ngx_alloc(sz, ngx_cycle->log)) == NULL) {', 1]
['ngx_uint_t                    channels; //# of channels being used', 1]
['sent << publish(Msg.new(id, data: "foo", ttl: 3))', 1]
['offsetof(nchan_store_channel_head_t, churn_next),', 1]
['if(self->cf->subscriber_timeout > 0) {', 1]
['"memstore message",', 1]
['bool cmp_read_map(cmp_ctx_t *ctx, uint32_t *size);', 1]
['#include <uv.h>', 1]
['const char *c = format;', 1]
['static float befloat(float x) {', 1]
['if (*p) {', 1]
['if (nwritten == -1) {', 1]
['* Output will be just "Hello World".', 1]
['//this is a rather convoluted description... but basically this is ok.', 1]
['CMP_TYPE_BIN32,           /*  8 */', 1]
['rc= nchan_output_filter(r, chain);', 1]
["if(conf->last_message_id.n == 0) { //if it's still null", 1]
['cv = &chid->cv[i-1];', 1]
['if(fsub->upstream_stuff && fsub->upstream_stuff->psr_data.tmp_pool) {', 1]
['void subscriber_debug_assert_isempty(void);', 1]
['aeDeleteFileEvent(loop,e->fd,AE_READABLE);', 1]
['require "minitest/autorun"', 1]
['ERR("Not accepting new subscribers right now. want to stop.");', 1]
['sub = ssub->sub;', 1]
['unsigned long long v;', 1]
['buf->start = buf->pos = cur;', 1]
['nchan_channel_t         ch;', 1]
['nchan_channel_id [:srv, :loc, :if],', 1]
['return cur->next;', 1]
['subscribers = ch->subscribers;', 1]
['if(verify_msg_id(&sub->last_msgid, &msg->prev_id, &msg->id) == NGX_ERROR) {', 1]
['ngx_memcpy(cur, id[i].data, id[i].len);', 1]
['ngx_int_t             rc;', 1]
['ac->ev.addWrite = redis_nginx_add_write;', 1]
['callbackValDup,', 1]
['typedef struct redisLibuvEvents {', 1]
['#if __APPLE__ && __MACH__', 1]
['//ngx_handle_write_event(ipc->c[slot]->write, 0);', 1]
['return memcmp(key1,key2,l1) == 0;', 1]
['memstore_ipc_send_get_message(d->channel_owner, d->channel_id, &d->msg_id, d);', 1]
['bc[1].buf.flush = 0;', 1]
['/* Set the hash entry fields. */', 1]
['typedef struct full_subscriber_s full_subscriber_t;', 1]
['assert(shm_msg->temp_allocd == 0);', 1]
["//don't reply with status info, this websocket is used for subscribing too,", 1]
['unit = (u_char *) "MB";', 1]
['/* Abort if there is not target to set */', 1]
['* I tested a few and this was the best. */', 1]
['if (obj->type == CMP_TYPE_DOUBLE) {', 1]
['* doing unnecessary calls to memmove() in sds.c. */', 1]
['c -= a; c -= b; c ^= ( b >> 15 );                                              \\', 1]
['} ngx_rwlock_t;', 1]
["s[sh->len] = '\\0';", 1]
['* and in fact a previous version of this hash did just that.', 1]
['#define dictFreeEntryKey(ht, entry) \\', 1]
['//initialize pipes for workers in advance.', 1]
['fsub->data.multimsg_last = mmsg;', 1]
['char _format[16];', 1]
['DBG("%s keep_place max notready %i, cur %p", rp->name, max_notready, cur);', 1]
['rp->next_ptr_offset = next;', 1]
['script_table << "  //#{name}\\n#{cquote(script)}"', 1]
['nchan_msg_t              *msg;', 1]
['rc = nchan_output_filter(fsub->sub.request, websocket_msg_frame_chain(fsub, msg));', 1]
["for a command is non-`NULL`, the memory is free'd immediately following the callback: the reply is only", 1]
['def time=(t)', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "can\'t allocate memory for (new) channel subscriber head");', 1]
['redisLibeventEvents *e;', 1]
['ngx_int_t memstore_ipc_send_unsubscribed(ngx_int_t dst, ngx_str_t *chid, void* privdata);', 1]
['ngx_memcpy(&conf->sub_chid, &prev->sub_chid, sizeof(prev->sub_chid));', 1]
['cf.use_redis  =   rlch->use_redis;', 1]
['ws_pub_head.next = &ws_pub_head;', 1]
['//     test("redisBufferWrite against closed fd: ");', 1]
['redis_subscribe_data_t       *data = (redis_subscribe_data_t *)d;', 1]
['test_cond("sdscpy() against an originally shorter string",', 1]
['info: "Because settings are bound to locations and not individual channels, it is useful to be able to have channels that can be reached only from some locations and never others. That\'s where this setting comes in. Think of it as a prefix string for the channel id."', 1]
['* the hash function as it applies to the key domain).', 1]
['b->temporary = 0;', 1]
["messages=     'channel:messages:'..id,", 1]
['bool cmp_read_int(cmp_ctx_t *ctx, int32_t *i) {', 1]
['int16_t   s16;', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "MEMSTORE:%02i: " fmt, memstore_slot(), ##args)', 1]
['return chanhead_messages_gc_custom(ch, ch->max_messages);', 1]
['static ngx_str_t  sub_name = ngx_string("longpoll");', 1]
['sdsrange(y,2,1);', 1]
['bool cmp_object_as_ushort(cmp_object_t *obj, uint16_t *s);', 1]
['static const uint32_t version = 14;', 1]
['legacy: "push_message_timeout",', 1]
['obj->as.ext.size = 2;', 1]
['if(!cmp_to_str(&cmp, &alerttype)) {', 1]
['x = sdscpy(x,"a");', 1]
['msg->lbl.data = (u_char *)stuff + (total_sz - debug_sz);', 1]
['if (test_inherit_fd) {', 1]
['int oldfree;', 1]
['+ - - - - - - - - - - - - - - - +-------------------------------+', 1]
['assert(psr_stuff != NULL);', 1]
['"--input:  keys: [], values: [channel_id, number]\\n"', 1]
['//is the subscriber', 1]
['//ERR("request %p tmp pool %p", r, r->pool);', 1]
['static ngx_inline void reap_ready_thing(nchan_reaper_t *rp, void *cur, void *next) {', 1]
['/*static ngx_int_t websocket_msg_frame_header(ngx_buf_t *buf, off_t len) {', 1]
['void       *buf;', 1]
['ipc_alert_t        alert;', 1]
['!memcmp(reply->element[1]->str,"foo",3))', 1]
['ngx_int_t stop_spooler(channel_spooler_t *spl, uint8_t dequeue_subscribers) {', 1]
['return ctx->write(ctx, &l, sizeof(int64_t));', 1]
['value for an idle buffer, so the buffer will never get freed.', 1]
['msg.content_type.len = r->headers_in.content_type->value.len;', 1]
['} unsubscribed_data_t;', 1]
['ipc_writebuf_t     *wb = &proc->wbuf;', 1]
['ngx_str_t                     *channel_event_name;', 1]
['bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i);', 1]
['ch->subscribers = r->element[2]->integer;', 1]
['return cmp_write_bin32_marker(ctx, size);', 1]
['while (__redisShiftCallback(&ac->replies,&cb) == REDIS_OK)', 1]
['char *delete;', 1]
['channel_spooler_t *start_spooler(channel_spooler_t *spl, ngx_str_t *chid, chanhead_pubsub_status_t *channel_status, nchan_store_t *store) {', 1]
['subscriber_pool_t      *newspool;', 1]
['STR16_MARKER           = 0xDA,', 1]
['spool->spooler = spl;', 1]
['return lcf;', 1]
['static unsigned long _dictNextPower(unsigned long size) {', 1]
['spooled_subscriber_t       *nsub, *nnext;', 1]
['* positions. If this happens on two consecutive expansions we inhibit any', 1]
['while((spool = spoolcollector_unwind_nextspool(&srdata)) != NULL) {', 1]
['p = ngx_palloc(r->pool, NGX_OFF_T_LEN);', 1]
['cur->idx++;', 1]
['case \'\\b\': s = sdscatlen(s,"\\\\b",2); break;', 1]
['obj->type = CMP_TYPE_FIXSTR;', 1]
['return str;', 1]
['mid->tag.allocd=tags;', 1]
['nchan_msg_t       *msg=NULL;', 1]
['struct msg_rsv_dbg_s           *rsv;', 1]
['if((msg=create_shm_msg(m)) == NULL ) {', 1]
['/* The Bernstein hash function, used in Perl prior to v5.6. Note (x<<5+x)=x*33. */', 1]
['chanhead_cleanlink->prev=rdt.chanhead_cleanup_tail;', 1]
['ngx_atomic_t                sub_count;', 1]
['redisLibevAttach(EV_DEFAULT_ c);', 1]
['/* Copy all the elements from the old to the new table:', 1]
['* ... with some allowances for already-opened sockets...', 1]
['store_message_t   *cur = ch->msg_first;', 1]
['*size = obj.as.str_size;', 1]
['#define CLOSE_UNSUPPORTED_DATA       1003', 1]
['ssize_t n;', 1]
['if (c >= 0)', 1]
['"    table.insert(bulk, v)\\n"', 1]
['info: "Set the EventSource `event:` line to this value. When used in a publisher location, overrides the published message\'s `X-EventSource-Event` header and associates the message with the given value. When used in a subscriber location, overrides all messages\' associated `event:` string with the given value."', 1]
['iter->nextEntry = NULL;', 1]
['ngx_buf_t             *buf;', 1]
['custom_close_msg.len = ngx_sprintf(msgbuf,"%i %v", status_code, (status_line ? status_line : &empty)) - msgbuf;', 1]
['static int redisLibevAttach(EV_P_ redisAsyncContext *ac) {', 1]
['static int _dictExpandIfNeeded(dict *ht) {', 1]
['"  return {err=\\"Argument 7, max_msg_buf_size, can\'t be empty\\"}\\n"', 1]
['if(ngx_strncmp(cur, delim, delim_sz) == 0) {', 1]
['The return value has the same semantic as `redisCommand`.', 1]
['head->sub_count--;', 1]
['unsigned _klen = fieldlen;                                                   \\', 1]
['memstore_fakeprocess_push(d->owner);', 1]
['ERR("%i channels still present in churner at exit  (slot %i)", mpt->chanhead_churner.count, ngx_process_slot);', 1]
["//It's ALIIIIIVE! ... erm.. active...", 1]
['rchain->buf = rbuffer;', 1]
['[IPC_SUBSCRIBE] =                   (ipc_handler_pt )receive_subscribe,', 1]
['rp->last = NULL;', 1]
['bool cmp_write_fixext4(cmp_ctx_t *ctx, int8_t type, const void *data) {', 1]
['/* Sets a pointer to the first argument and its length starting at p. Returns', 1]
['return internal_subscriber_destroy(sub);', 1]
['static void redisLibevAddWrite(void *privdata) {', 1]
["//maybe TODO: simplify this stuff, but probably not as it's not a performance penalty and the code is simple", 1]
['redis_connect_params_t          *connect_params;', 1]
['//for(; i < NCHAN_MULTITAG_REQUEST_CTX_MAX; i++) {', 1]
['//static char         buf[sizeof(ipc_alert_t) * 2];', 1]
['ngx_buf_t                      *b = &channel_info_buf;', 1]
['pos += sprintf(cmd+pos,"$%zu\\r\\n",len);', 1]
['memstore_data_t   *cur;', 1]
['mult = 1;', 1]
['static char *nchan_store_messages_directive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SPOOL:" fmt, ##arg)', 1]
['assert(rev_count == 0);', 1]
['sds sdsRemoveFreeSpace(sds s);', 1]
['nchan_store_channel_head_t *chanhead = (nchan_store_channel_head_t *)privdata;', 1]
['struct timeval    tv;', 1]
['req_msgid[i].time = time;', 1]
['#    [:loc_conf, :subscriber_concurrency],', 1]
['//DBG("retry write after squeezing in overflow");', 1]
['/* process typed item */', 1]
['/* Helper function for the redisCommand* family of functions.', 1]
['assert_equal cur, sent[1]', 1]
['ngx_uint_t                   generation; //subscriber pool generation.', 1]
['obj->as.array_size = be16(obj->as.u16);', 1]
['void *prev;                       /* prev element in app order      */', 1]
['ngx_str_t                      *channel_id;', 1]
['"      \\n"', 1]
['"    ch[i]=tonumber(ch[i]) or 0\\n"', 1]
['int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap);', 1]
['chanhead_cleanlink->next=NULL;', 1]
['if (obj->type == CMP_TYPE_BOOLEAN)', 1]
['DBG("Chanhead gc add %p %V: %s", ch, &ch->id, reason);', 1]
['bool cmp_read_fixext8_marker(cmp_ctx_t *ctx, int8_t *type) {', 1]
['m->nobuffer_msg_reaper.strategy = KEEP_PLACE;', 1]
['for (j = 0; j < (len-(seplen-1)); j++) {', 1]
['ngx_atomic_fetch_add(&ch->shared->stored_message_count, 1);', 1]
['local cur = 0', 1]
['//DBG("first now at %i, %i alerts remain", i, proc->wbuf.n);', 1]
['fmt_invalid:', 1]
['&longpoll_reserve,', 1]
['while((msg = ch->msg_first) != NULL) {', 1]
['"local key = KEYS[1]\\n"', 1]
['elsif status == 418 #not ready', 1]
['//close file on cleanup', 1]
['--output: result_code, msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, channel_subscriber_count', 1]
['_hj_i +=    (_hj_key[0] + ( (unsigned)_hj_key[1] << 8 )                      \\', 1]
['d->n = max;', 1]
['etag->len = tmp_etag->len;', 1]
['redisAsyncContext *ac = NULL;', 1]
['ngx_conf_merge_value(conf->longpoll_multimsg, prev->longpoll_multimsg, 0);', 1]
['DBG("no spools in range %V -- ", msgid_to_str(&msg->prev_id));', 1]
['ngx_atomic_t  *mutex = &lock->mutex;', 1]
['//sdata->sub->id = reply->element[1]->integer;', 1]
['_he_thh = _he_hh_nxt;                                                 \\', 1]
['sentinel = tree->sentinel;', 1]
['shm_init(shm);', 1]
['char cbuf[8], sbuf[128];', 1]
['if(cf->sub.eventsource && nchan_detect_eventsource_request(r)) {', 1]
['/* Reads a signed integer that fits inside a signed short */', 1]
['test_cond("sdscatrepr(...data...)",', 1]
['hex_digit_to_int(*(p+3));', 1]
['rbtree_destroy_node(seed, cur);', 1]
['evcf->use_redis = cf->use_redis;', 1]
['pd->n = n;', 1]
["* characters specified in the 'from' string to the corresponding character", 1]
['static inline size_t sdsavail(const sds s) {', 1]
['unsigned long realsize = _dictNextPower(size), i;', 1]
['nchan_msg_status_t           findmsg_status;', 1]
['p = (node->key < temp->key) ? &temp->left : &temp->right;', 1]
['/* Writes a signed integer to the backend */', 1]
['"      --dbg(k..\\"=\\"..v)\\n"', 1]
['double_newline_buf.pos = double_newline_buf.start;', 1]
['sh->free += sh->len;', 1]
['static ngx_int_t chanhead_gc_add(nchan_store_channel_head_t *head, const char *reason);', 1]
['ngx_str_t          *tmp, *ws_key;', 1]
['else out = NULL;                                                             \\', 1]
['unsigned long sizemask;', 1]
['n = parse_multi_id(channel_id, ids);', 1]
['"--output: current_subscribers\\n"', 1]
['dequeue_maybe(sub);', 1]
['//     test_cond(__test_callback_flags == 1);', 1]
['[:loc_conf, :buffer_timeout],', 1]
['hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                     \\', 1]
['ngx_str_t                       channel_group;', 1]
['assert(cur != next);', 1]
['case 410:', 1]
['ngx_close_file(file->fd);', 1]
['subscriber_pool_t    *spool;', 1]
['//nchan_channel_t * channel = (nchan_channel_t *)privdata;', 1]
['while (n--) {', 1]
['if((fsub->cln = ngx_http_cleanup_add(r, 0)) == NULL) {', 1]
['#define CHECK_REPLY_INTVAL(reply, v) ( CHECK_REPLY_INT(reply) && (reply)->integer == v )', 1]
['ngx_str_t *msgid_to_str(nchan_msg_id_t *id);', 1]
['msg_time, msg_tag = msg_id.split(":")', 1]
['"  sub_count=redis.call(\'hincrby\', keys.channel, \'subscribers\', 1)\\n"', 1]
['"      redis.call(\'del\', v)\\n"', 1]
['*size = obj->as.ext.size;', 1]
['r->rstack[0].obj = NULL;', 1]
['shmem_t *nchan_memstore_get_shm(void);', 1]
['#include <inttypes.h>   /* uint32_t */', 1]
['} store_channel_head_shm_t;', 1]
['msg_release(d->shm_msg, "publish_message");', 1]
['int redisBufferWrite(redisContext *c, int *done) {', 1]
['next = ssub->next;', 1]
['procslot_found = 1;', 1]
['/* Increment the sds length and decrements the left free space at the', 1]
['nchan_channel_t *ch = (nchan_channel_t *)rptr;', 1]
['"local key_msg=    \'channel:msg:%s:\'..id --not finished yet\\n"', 1]
['r->len = len;', 1]
['bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size) {', 1]
['memstore_pub_debug_start();', 1]
['uintptr_t                   data;', 1]
['r->pos += bytes;', 1]
['For example, [hiredis-rb](https://github.com/pietern/hiredis-rb/blob/master/ext/hiredis_ext/reader.c)', 1]
['#define NCHAN_DEFAULT_MAX_MESSAGES 10', 1]
['nchan_output_init();', 1]
['ngx_int_t      i, max = head->multi_count;', 1]
['#define LONGPOLL_STRINGS_N 2', 1]
['} else if (argc >= 1 && !strcmp(argv[0],"--skip-inherit-fd")) {', 1]
['bool cmp_read_ext8(cmp_ctx_t *ctx, int8_t *type, uint8_t *size, void *data) {', 1]
['"  if(ch[4]) then\\n"', 1]
['"  redis.call(\'EXPIRE\', key.channel, channel.ttl)\\n"', 1]
['static void dictReleaseIterator(dictIterator *iter) {', 1]
['else if(cf->sub.poll || cf->sub.longpoll || cf->sub.eventsource || cf->sub.websocket) {', 1]
['shmem_t *nchan_memstore_get_shm(void){', 1]
['DBG("maybe subscribe again?...");', 1]
['CMP_TYPE_MAP16,           /* 32 */', 1]
['ngx_snprintf(rdt.subscriber_id, 255, "worker:%i:time:%i", ngx_pid, ngx_time());', 1]
['ngx_destroy_pool(nchan_pool);', 1]
['ht->size = 0;', 1]
['ngx_int_t           n;', 1]
['frame->payload_len = frame->header[1] & 0x7f;', 1]
['time_t                          websocket_ping_interval;', 1]
["sh->buf[len] = '\\0';", 1]
['{ "json"  , 4, &NCHAN_CHANNEL_INFO_JSON },', 1]
['NULL', 1]
['alerts[i % IPC_WRITEBUF_SIZE] = of->alert;', 1]
['bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size);', 1]
['ngx_buf_t           *tmp_buf;', 1]
['INTEGER_WIDTH_TEST("llu", unsigned long long);', 1]
['if (!ctx->read(ctx, &ext_size, sizeof(uint8_t))) {', 1]
['char *get_message;', 1]
['if (status != 0) {', 1]
['int', 1]
['sh->free += (sh->len-reallen);', 1]
['default: "32M",', 1]
['v->get_handler = var->handler;', 1]
['info: "Development directive to completely replace default storage engine. Don\'t use unless you are an Nchan developer."', 1]
['ngx_http_complex_value(r, authorize_request_url_ccv, &auth_request_url);', 1]
['test_cond("sdscpy() against an originally longer string",', 1]
['chanhead_push_message(ch, smsg);', 1]
['* until its chain length reaches a *multiple* of HASH_BKT_CAPACITY_THRESH.', 1]
['bool cmp_object_as_ushort(cmp_object_t *obj, uint16_t *s) {', 1]
['store_channel_head_shm_t        dummy_shared_chaninfo;', 1]
['} publish_status_data_t;', 1]
['struct UT_hash_handle *_thh;                                                 \\', 1]
['default: 512,', 1]
['* copy the deletee pointer, then the latter references are via that', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REAPER: " fmt, ##args)', 1]
['static void sub_empty_callback(){ }', 1]
['if((ctx=rds_sub_ctx())!=NULL)', 1]
['ngx_connection_t *connection;', 1]
['"  redis.call(\'EXPIRE\', key.channel, create_channel_ttl)\\n"', 1]
['pd->n--;', 1]
['if (free >= addlen) return s;', 1]
['redisEchoCallback(c, el, NULL);', 1]
['//fallback to legacy $push_channel_id', 1]
['static int msg_ids_equal(nchan_msg_id_t *id1, nchan_msg_id_t *id2) {', 1]
['redis_nginx_del_write(privdata);', 1]
['h->key.len = header_name->len;', 1]
['if(d->multi_chanhead->multi_waiting == 0) {', 1]
['msg->eventsource_event.len=es_event_len;', 1]
['obj->as.s8 = type_marker;', 1]
['buffer to zero (unlimited) just with:', 1]
['hiredis-example-ae:', 1]
['assert(ch->shared);', 1]
['/* delete "delptr" from the hash table.', 1]
['* the number of bytes to skip to get to the following argument. */', 1]
['fname = fn_buf;', 1]
['else if((timcur == timmax && (max_cmp = msgid_tag_compare(&spool->id, &data->max)) < 0)', 1]
['redisReaderFeed(reader,(char*)"+OK\\r\\n",5);', 1]
['ngx_int_t ipc_open(ipc_t *ipc, ngx_cycle_t *cycle, ngx_int_t workers, void (*slot_callback)(int slot, int worker)) {', 1]
['fsub->data.awaiting_destruction = 0;', 1]
['nchan_msg_id_t               *msg_id;', 1]
['//output: result_code, msg_time, msg_tag, message, content_type,  channel-subscriber-count', 1]
['bool cmp_write_str32(cmp_ctx_t *ctx, const char *data, uint32_t size);', 1]
['/* Pass to the next element */', 1]
['subscribe_data_t   *data = (subscribe_data_t *)d;', 1]
['//nchan_store_channel_head_t *chanhead = d->chanhead;', 1]
['ngx_rbtree_node_t    *node = rbtree_node_from_data(spool);', 1]
['ngx_http_finalize_request(r, nchan_response_channel_ptr_info( (nchan_channel_t *)rptr, r, 0));', 1]
['self->dequeue_after_response = 1;', 1]
['// static long __test_callback_flags = 0;', 1]
['if (c->fd > 0)', 1]
['ngx_int_t            rbtree_insert_node(rbtree_seed_t *, ngx_rbtree_node_t *);', 1]
['static void test_throughput(struct config config) {', 1]
['u_char         *p = buf;', 1]
['On a disconnect, the `status` argument is set to `REDIS_OK` when disconnection was initiated by the', 1]
['cbuf->last_buf = 1;', 1]
['genhtml --legend -o tmp/lcov/report tmp/lcov/hiredis.info', 1]
['if (ch->sub_count == 0) { //still no subscribers here', 1]
['de = de->next;', 1]
['ERR("can\'t allocate memory for (new) chanhead");', 1]
['static const char intfmts[] = "diouxX";', 1]
['"  msg.prev_tag = 0\\n"', 1]
['//workers = shdata->max_workers;', 1]
['is being disconnected per user-request, no new commands may be added to the output buffer and `REDIS_ERR` is', 1]
['ngx_http_request_t        *r = fsub->sub.request;', 1]
['char              *subtype;', 1]
['Send POST request to internal location (which may proxy to an upstream server) with published message in the request body. Useful for bridging websocket publishers with HTTP applications, or for transforming message via upstream application before publishing to a channel.', 1]
['el; (el)=(tmp),(tmp)=DECLTYPE(el)((tmp)?(tmp)->hh.next:NULL))', 1]
['assert(msgid->tagcount == 1 && first->msg->id.tagcount == 1);', 1]
['ngx_int_t                       msg_in_etag_only;', 1]
['static int _dictKeyIndex(dict *ht, const void *key);', 1]
['bool cmp_write_str32(cmp_ctx_t *ctx, const char *data, uint32_t size) {', 1]
['if (cb->fn != NULL) {', 1]
['*size = obj->as.array_size;', 1]
['"      dbg(\\"NEXT MESSAGE NOT FOUND\\")\\n"', 1]
['chaninfo_copy.last_published_msg_id = ch->latest_msgid;', 1]
['fsub->enqueue(fsub->sub.cf->buffer_timeout, NULL, fsub->privdata);', 1]
['bool cmp_write_ext32(cmp_ctx_t *ctx, int8_t type, uint32_t size,', 1]
['//ngx_http_request_t            *fake_parent_req = fake_cloned_parent_request(sub->request);', 1]
['extern const ngx_str_t NCHAN_HEADER_VARY;', 1]
['redisContextConnectBindTcp(c,ip,port,NULL,source_addr);', 1]
['"255a859f9c67c3b7d6cb22f0a7e2141e1874ab48"', 1]
['clnf->name = file->name.data;', 1]
['ngx_int_t memstore_ipc_send_flood_test(ngx_int_t dst);', 1]
['//DBG("re-add event because the write failed");', 1]
['//ngx_buf_t     *msg_buf = &fsub->msg_buf;', 1]
['_hs_qsize = _hs_insize;                                            \\', 1]
['#include "nchan_defs.h"', 1]
['store_message_t                *msg_last;', 1]
['*i = obj->as.s16;', 1]
['static ngx_int_t nchan_strmatch(ngx_str_t *val, ngx_int_t n, ...) {', 1]
['* printf("%s\\n", s);', 1]
['S8_MARKER              = 0xD0,', 1]
['The return value of `redisCommand` holds a reply when the command was', 1]
['"if max_stored_msgs < 0 then --no limit\\n"', 1]
["/* The MurmurHash exploits some CPU's (x86,x86_64) tolerance for unaligned reads.", 1]
['else if (type_marker == U32_MARKER) {', 1]
['if(fsub->sub.reserved > 0) {', 1]
['if(nchan_strmatch(val, 1, "memory")) {', 1]
['static ngx_int_t nchan_process_multi_channel_id(ngx_http_request_t *r, nchan_complex_value_arr_t *idcf, nchan_loc_conf_t *cf, ngx_str_t **ret_id) {', 1]
['if (!cmp_write_bin8_marker(ctx, size))', 1]
['chid_conf = what == PUB ? &cf->pub_chid : &cf->sub_chid;', 1]
['sdata->sub = sub;', 1]
['void *aux = NULL;', 1]
['head->multi=NULL;', 1]
['bool cmp_object_as_uint(cmp_object_t *obj, uint32_t *i);', 1]
["case '0': return 0;", 1]
['nchan_exit_worker,             /* exit process */', 1]
['#ifndef NGX_HTTP_CONFLICT', 1]
['cur = &msgtag_str_buf[l1];', 1]
['int                events;', 1]
['chr_int = getc(stream);', 1]
['//a ring buffer with a linked-list overflow for writing alerts,', 1]
['redisAsyncHandleWrite(connection->data);', 1]
['info: "Defines a server or location as a pubsub endpoint. For long-polling, GETs subscribe. and POSTs publish. For Websockets, publishing data on a connection does not yield a channel metadata response. Without additional configuration, this turns a location into an echo server."', 1]
['typedef enum {PUB, SUB} pub_or_sub_t;', 1]
['info: "Defines a server or location as a channel subscriber endpoint. This location represents a subscriber\'s interface to a channel\'s message queue. The queue is traversed automatically, starting at the position defined by the `nchan_subscriber_first_message` setting.  \\n The value is a list of permitted subscriber types."', 1]
['lcf->use_redis=NGX_CONF_UNSET;', 1]
['/* hash == node->key */', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "nchan: can\'t allocate memory for message from redis reply");', 1]
['{ ngx_string("push_max_channel_subscribers"), //legacy for nchan_max_channel_subscribers', 1]
['if(msg->id.time==0) {', 1]
['DBG("handle_chanhead_gc_queue");', 1]
['} nchan_buf_and_chain_t;', 1]
['return thing ? thing->data : NULL;', 1]
['if (obj->as.u32 <= 2147483647) {', 1]
['DBG("prev: %V", msgid_to_str(&publish_msg->prev_id));', 1]
['/* traverse hh in app order; check next/prev integrity, count */         \\', 1]
['nchan_msg_t            *msg = (nchan_msg_t *) ptr;', 1]
['self->dequeue_handler = handler;', 1]
['for(ssub = spool->first; ssub!=NULL; ssub=ssub->next) {', 1]
['len = redisFormatCommandArgv(&cmd,argc,argv,NULL);', 1]
['* s = sdscatprintf(sdsempty(), "... your format ...", args);', 1]
['_sfh_tmp       = (uint32_t)(get16bits (_sfh_key+2)) << 11  ^ hashv;          \\', 1]
['static ngx_int_t internal_set_dequeue_callback(subscriber_t *self, subscriber_callback_pt cb, void *privdata) {', 1]
['* c->errstr to hold the appropriate error string.', 1]
['ngx_null_command', 1]
['case STUBBED:', 1]
['if(wb->overflow_last) {', 1]
['char                      *err = NULL;', 1]
['} else if (errno == EINPROGRESS && !blocking) {', 1]
['* even if you create an sds string with:', 1]
['case NCHAN_SUBSCRIBER_CONCURRENCY_BROADCAST:', 1]
['for(j=0; j < max; j++) {', 1]
['totlen += 1+intlen(argc)+2;', 1]
["int insq=0; /* set to 1 if we are in 'single quotes' */", 1]
['if(head->stub) {', 1]
['DBG("%p create %V with privdata %p", fsub, fsub->sub.name, privdata);', 1]
['static void receive_get_channel_info(ngx_int_t sender, channel_info_data_t *d) {', 1]
['test_cond("sdsrange(...,2,1)",', 1]
['def getmsg(msg, opt={})', 1]
['if (r->pos+bytelen <= r->len) {', 1]
['sdsIncrLen(x,1);', 1]
['/*.so', 1]
['dictReplace(ac->sub.patterns,sname,&cb);', 1]
['lcf->storage_engine = &nchan_store_memory;', 1]
['cd $(INSTALL_LIBRARY_PATH) && ln -sf $(DYLIB_MINOR_NAME) $(DYLIB_MAJOR_NAME)', 1]
['//static ngx_str_t            empty_string = ngx_string("");', 1]
['"    key.last_message=nil\\n"', 1]
['* mystring = sdsnewlen("abc",3");', 1]
['redisContext *redisConnectUnix(const char *path);', 1]
['ngx_uint_t                      len;', 1]
['if (hh_del->hh_prev) {                                                       \\', 1]
['event_base_dispatch(base);', 1]
["redis.call('DEL', key_channel, messages, subscribers)", 1]
['static void redisCheckErrorCallback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['static ngx_int_t websocket_publish(full_subscriber_t *fsub, ngx_buf_t *buf) {', 1]
['head = (add);                                                                \\', 1]
['urnode->smallmsg.len = 0;', 1]
['sz = ngx_buf_size(buf);', 1]
['int                             i;', 1]
['notice, this list of conditions and the following disclaimer in the', 1]
['nchan_store_redis.create_main_conf(cf, mcf);', 1]
['of the context. This output buffer is dynamic, so it can hold any number of commands.', 1]
['id_out->data = (u_char *)&id_out[1];', 1]
['if (!connection->write->active && redis_nginx_fd_is_valid(connection->fd)) {', 1]
['//r->headers_out.content_type.len = content_type.len;', 1]
['rp->max_notready_ratio = 0; //disabled', 1]
['local unpacked', 1]
['if((spool = find_spool(data->spooler, &data->msgid)) == NULL) {', 1]
['static nchan_store_channel_head_t * nchan_store_get_chanhead(ngx_str_t *channel_id) {', 1]
['n = write(fd, alert, sizeof(*alert));', 1]
['if (ctx->write(ctx, data, 4))', 1]
['immediately after creating the `redisReader`.', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:LONGPOLL:" fmt, ##arg)', 1]
['c->err == REDIS_ERR_IO && errno == EAGAIN);', 1]
['int totlen, j;', 1]
['* right-trim the string.', 1]
['str->data = fwd_buf(buf, sz);', 1]
['#elif defined(__linux__) || defined(__OpenBSD__) || defined(__NetBSD__)', 1]
['--output: msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, channel_subscriber_count', 1]
['clcf->if_modified_since = NGX_HTTP_IMS_OFF;', 1]
['ngx_int_t     i, max = head->multi_count;', 1]
["redis.call('PUBLISH', pubsub, del_msgpack)", 1]
['static const subscriber_t new_internal_sub;', 1]
['if (*p == sentinel) {', 1]
['else if (type_marker == STR16_MARKER) {', 1]
['#define HASH_KEYCMP(a,b,len) memcmp(a,b,len)', 1]
['int (*keyCompare)(void *privdata, const void *key1, const void *key2);', 1]
['bc[0].buf.end = ngx_snprintf(chunk_start, 15, "%xi\\r\\n", ngx_buf_size(msg_buf));', 1]
['if (obj.type != CMP_TYPE_SINT64) {', 1]
['case MSG_CHANNEL_NOTREADY:', 1]
['#if !defined (get16bits)', 1]
['HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,', 1]
['buf = ngx_create_temp_buf(r->pool, 0);', 1]
['obj = r->fn->createInteger(cur,readLongLong(p));', 1]
['ERR("nextmsg id same as curmsg (%V)", msgid_to_str(&spool->id));', 1]
['/* Integer conversion (without modifiers) */', 1]
['id.data = idbuf;', 1]
['if(ngx_exiting) {', 1]
['local sub_count', 1]
['uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                      \\', 1]
['{ ngx_string("nchan_channel_event"),      nchan_channel_event, 0},', 1]
['static ngx_int_t internal_notify(subscriber_t *self, ngx_int_t code, void *data) {', 1]
['rp->reap(thing);', 1]
["if(*last == '\\0' || (len > 0 && *(last - 1) == '\\0')) {", 1]
['chan.last_published_msg_id = d->last_msgid;', 1]
['unsigned                    want_to_stop:1;', 1]
['fsub->hdr_buf.start = ngx_pcalloc(r->pool, WEBSOCKET_FRAME_HEADER_MAX_LENGTH);', 1]
['unsigned char *_hj_key=(unsigned char*)(key);                                  \\', 1]
['if (!cmp_write_str32_marker(ctx, size))', 1]
['(head).hh_head=addhh;                                                           \\', 1]
['spl->publish_events = 1;', 1]
['ngx_memcpy(&fsub->sub, &new_longpoll_sub, sizeof(new_longpoll_sub));', 1]
['static memstore_data_t fake_default_mdata;', 1]
['evcf->subscriber_start_at_oldest_message = 0;', 1]
['+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +', 1]
['len_net = ws_htonll(len);', 1]
['if(subdebug_head == NULL) {', 1]
["return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||", 1]
['DBG("IPC: publish message reply to %i", cd->sender);', 1]
['} else {                                                                        \\', 1]
['obj->as.ext.size = 4;', 1]
['"delete",', 1]
['bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i) {', 1]
['ngx_int_t internal_subscriber_set_notify_handler(subscriber_t *sub, callback_pt handler) {', 1]
['newlen = 0;', 1]
['DBG("gc_add chanhead %V: already added", &ch->id);', 1]
['void redisAsyncFree(redisAsyncContext *ac);', 1]
['bc[3].buf.start = boundary;', 1]
['Together with `redisCommand`, the function `redisCommandArgv` can be used to issue commands.', 1]
['*l = obj.as.s64;', 1]
['ngx_int_t                   last_responded_subscriber_count;', 1]
['if (_hs_psize == 0) {                                          \\', 1]
['#define NCHAN_MESSAGE_RECEIVED  9000', 1]
['if((d=ngx_calloc(sizeof(*d) + sizeof(ngx_str_t) + channel_id->len, ngx_cycle->log))==NULL) {', 1]
['/* Find out Redis version to determine the path for the next test */', 1]
['if (iter->entry) {', 1]
['result->tv_usec = x->tv_usec - y->tv_usec;', 1]
['"   sub_count = redis.call(\'hincrby\', keys.channel, \'subscribers\', -1)\\n"', 1]
['ctx->channel_event_name = &evt_sub_recvmsg;', 1]
['int32_t     ttl;', 1]
['d->callback(d->renew, NULL, d->privdata);', 1]
['nchan_request_ctx_t    *ctx = ngx_http_get_module_ctx(sub->request, nchan_module);', 1]
['config.tcp.timeout.tv_usec = 10000001;', 1]
['#define NCHAN_ZERO_MSGID {0, {{0}}, 0, 0}', 1]
['boundary[i].end = char_boundary_last;', 1]
['typedef struct UT_hash_table {', 1]
['* but do it anyway to be as defensive as possible. */', 1]
['"if #msg.data < 5*1024 then\\n"', 1]
['uint64_t ws_htonll(uint64_t value) {', 1]
['"local numsub = redis.call(\'PUBSUB\',\'NUMSUB\', channel_pubsub)[2]\\n"', 1]
['ev_io_start(EV_A_ &e->rev);', 1]
['_thh =  &(head)->hh;                                                     \\', 1]
['_hd_hh_del = &((delptr)->hh);                                            \\', 1]
['net.o: net.c fmacros.h net.h hiredis.h', 1]
['content_type = (r->headers_in.content_type ? &r->headers_in.content_type->value : NULL);', 1]
['if(!ch->in_churn_queue) {', 1]
['static void receive_delete(ngx_int_t sender, delete_data_t *d) {', 1]
['else if (cur == last){', 1]
['ngx_rbtree_node_t *rbtree_create_node(rbtree_seed_t *seed, size_t data) {', 1]
['if ((res = poll(wfd, 1, msec)) == -1) {', 1]
['* code to see why), and the module initialization callbacks occur before', 1]
['while (_hj_k >= 12) {                                                          \\', 1]
['void                       *dequeue_handler_privdata;', 1]
['ptrdiff_t _dst_hho = ((char*)(&(dst)->hh_dst) - (char*)(dst));                 \\', 1]
['u_char                       buf[128];', 1]
['if (connection->write->active && redis_nginx_fd_is_valid(connection->fd)) {', 1]
['else if(head->foreign_owner_ipc_sub != NULL && head->status == WAITING) {', 1]
['ngx_add_timer(&fsub->data.timeout_ev, self->cf->subscriber_timeout * 1000);', 1]
['rbtree_walk_direction_t  dir;', 1]
['void              shm_free_immutable_string(shmem_t *shm, ngx_str_t *str);', 1]
['strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);', 1]
['assert(head->channel.last_published_msg_id.tagcount <= 1);', 1]
['else if (type_marker == STR8_MARKER) {', 1]
['if(sub->type != INTERNAL) {', 1]
['static ngx_int_t nchan_publisher_upstream_handler(ngx_http_request_t *sr, void *data, ngx_int_t rc) {', 1]
['#define ERR(fmt, args...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "MEMSTORE:(fake)%02i: " fmt, memstore_slot(), ##args)', 1]
['last_chain = &chains[1];', 1]
['cf.use_redis = 0;', 1]
['"last_message_id: %V" CRLF', 1]
['chanhead_gc_add(cur, "redis connection gone");', 1]
['rd.status = status;', 1]
['DATA_READING_ERROR,', 1]
['bool cmp_object_as_str(cmp_object_t *obj, uint32_t *size);', 1]
['nchan_loc_conf_t   *lcf = (nchan_loc_conf_t *)conf;', 1]
['out << l', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not add write event to redis");', 1]
['if(tags1[0] != tags2[0]){', 1]
['*  HASH_DELETE(hh,users,users);', 1]
['int16_t  *msgidtags = msgid->tagcount <= NCHAN_FIXED_MULTITAG_MAX ? msgid->tag.fixed : msgid->tag.allocd;', 1]
['*next = NULL;', 1]
['ngx_int_t nchan_output_filter(ngx_http_request_t *r, ngx_chain_t *in) {', 1]
['static ngx_str_t      DEFAULT_CHANNEL_EVENT_STRING = ngx_string("$nchan_channel_event $nchan_channel_id");', 1]
['ngx_rbtree_node_t  **p;', 1]
['ngx_int_t              (*enqueue)(struct subscriber_s *);', 1]
['nchan_reaper_stop(&mpt->chanhead_reaper);', 1]
['if (events & UV_READABLE) {', 1]
['static redisReplyObjectFunctions defaultFunctions = {', 1]
['cur[0] = NCHAN_MULTI_SEP_CHR;', 1]
['end:', 1]
['$(DYLIBNAME): $(OBJ)', 1]
['static char *nchan_pubsub_directive(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['nchan_msg_id_t   *id2 = (nchan_msg_id_t *)v2;', 1]
['head->redis_subscriber_privdata = NULL;', 1]
['"if msg_id==nil then\\n"', 1]
['static void receive_subscriber_keepalive_reply(ngx_int_t sender, sub_keepalive_data_t *d) {', 1]
['ngx_int_t memstore_ipc_send_publish_status(ngx_int_t dst, ngx_str_t *chid, ngx_int_t status_code, const ngx_str_t *status_line, callback_pt callback, void *privdata);', 1]
['static void dictReleaseIterator(dictIterator *iter);', 1]
['"--output: current_fake_subscribers\\n"', 1]
['chanhead_messages_delete(ch);', 1]
['//ugh, this is so redundant. TODO: clean this shit up', 1]
['case WEBSOCKET_READ_GET_REAL_SIZE_STEP:', 1]
['return msg', 1]
['len = redisFormatCommand(&cmd, "SET foo bar");', 1]
['"    dbg(\\"channel current_message present\\")\\n"', 1]
['bool cmp_read_str_size(cmp_ctx_t *ctx, uint32_t *size);', 1]
['else { //not a string', 1]
['} getmessage_data_t;', 1]
['cf.use_redis = head->use_redis;', 1]
['ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno, ngx_nonblocking_n " failed on pipe socket %i while initializing nchan", j);', 1]
['if (done != NULL) *done = (sdslen(c->obuf) == 0);', 1]
['if(f != NULL) {', 1]
['chains[1].next = &chains[2];', 1]
['assert(urnode->smallmsg.len == msglen);', 1]
['assert(ch->msg_last == NULL);', 1]
['ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT', 1]
['static unsigned int dictGenHashFunction(const unsigned char *buf, int len) {', 1]
["case '\\n':", 1]
['const  ngx_str_t NCHAN_ALLOW_GET_POST_PUT_DELETE_OPTIONS= ngx_string("GET, POST, PUT, DELETE, OPTIONS");', 1]
['ngx_http_subrequest(sub->request, &auth_request_url, NULL, &sr, psr, 0);', 1]
['return ngx_crc32_short(((ngx_str_t *)str)->data, ((ngx_str_t *)str)->len);', 1]
['static int redisSetReuseAddr(redisContext *c) {', 1]
['if(ngx_time() - head->last_subscribed_local > MEMSTORE_IPC_SUBSCRIBER_TIMEOUT) {', 1]
['if(status == NGX_HTTP_INTERNAL_SERVER_ERROR || (status == NCHAN_MESSAGE_RECEIVED && pd->rc != NGX_HTTP_INTERNAL_SERVER_ERROR)) {', 1]
['#define DEBUG_MEMZERO(var) /*nothing*/', 1]
['multi bulk nesting level is higher than this, the parser returns an error.', 1]
['if ((rc = ws_recv(c, rev, &buf, 8)) != NGX_OK) {', 1]
['/* Flag that is set when the async context has one or more subscriptions. */', 1]
['rc=NGX_ERROR;', 1]
['ngx_memcpy(msg->lbl.data, m->lbl.data, msg->lbl.len);', 1]
['accumulate data from the server.', 1]
['n = ipc_read_socket(c->fd, &alert, ev->log);', 1]
['ctx->error = ERROR_NONE;', 1]
['//reading frame header', 1]
['#define HASH_SRT(hh,head,cmpfcn)                                                 \\', 1]
['p = ngx_snprintf(p, NGX_POOL_ENTRY_SIZE, NGX_POOL_ENTRY_FORMAT,', 1]
['#include <stdarg.h> /* for va_list */', 1]
['ipc_set_handler(ipc, memstore_ipc_alert_handler);', 1]
['//find empty existing slot', 1]
['while(redisGetReply(context,&reply) == REDIS_OK) {', 1]
['if(conf->channel_event_string == NULL) { //still null? use the default string', 1]
['if(fsub->data.holding == 0) {', 1]
['def test_simple', 1]
['//debugstuff that prevents this function from getting inlined', 1]
['"return {ttl, time, tag, prev_time or 0, prev_tag or 0, data or \\"\\", content_type or \\"\\", es_event or \\"\\"}\\n",', 1]
['* Writes a string to the backend.  This avoids using the STR8 marker, which', 1]
["/* Append the specified null termianted C string to the sds string 's'.", 1]
['# redis-server configuration used for testing', 1]
['f->dequeue_handler_data = privdata;', 1]
['sub = head->multi[i].sub;', 1]
['char buf[128] = { 0 };', 1]
['d->msg_id = sub->last_msgid;', 1]
['if(tc->thing_head == NULL) {', 1]
['} rbtree_seed_t;', 1]
['if(fakeprocess_top != NULL) {', 1]
['r->str = buf;', 1]
['(head)->hh.tbl->tail = &((add)->hh);                                         \\', 1]
['void sdstoupper(sds s);', 1]
['//DBG("%i alerts to write, with %i in overflow", proc->wbuf.n, proc->wbuf.overflow_n);', 1]
['if(cf.use_redis) {', 1]
['} redisLibevEvents;', 1]
['switch(newspool->msg_status) {', 1]
['if(!fsub->awaiting_destruction) {', 1]
['int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn) {', 1]
['HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt);    \\', 1]
['info: "If `If-Modified-Since` and `If-None-Match` headers are absent, set the message id to the first non-empty of these values. Used primarily as a workaround for the inability to set the first `Last-Message-Id` of a web browser\'s EventSource object. "', 1]
['str.len=strlen(body);', 1]
['shm_free(shm, shdata);', 1]
['DBG("exit master from pid %i", ngx_pid);', 1]
['&longpoll_respond_message,', 1]
['subscriber_t *prev, *next;', 1]
['self->bulk_post_subscribe_handler = handler;', 1]
['--input:  keys: [message_key], values: []', 1]
['DBG("redis command %s took %i msec", name, dt);', 1]
['static redisReply *createReplyObject(int type) {', 1]
['typedef enum {RESCAN, ROTATE, KEEP_PLACE} nchan_reaper_strategy_t;', 1]
['fetchmsg_data_t        *data;', 1]
['fsub->data.timeout_handler_data = NULL;', 1]
['assert(shdata->procslot[offset] == NCHAN_INVALID_SLOT);', 1]
['@echo "Please specify LIBUV_DIR (e.g. ../libuv/)"', 1]
['nchan_store_channel_head_t   *target_chanhead;', 1]
['if(slot == memstore_slot()) {', 1]
['if (!cmp_read_ext16_marker(ctx, type, size))', 1]
['//do it.', 1]
['unsigned _ho_i;                                                                \\', 1]
['@@files=   {}', 1]
['if (ngx_del_event(connection->write, NGX_WRITE_EVENT, 0) == NGX_ERROR) {', 1]
['int                        next_ptr_offset;', 1]
['if(msg->msg->id.time == 0) {', 1]
['/* -------------------------- private prototypes ---------------------------- */', 1]
['if (rc == NGX_AGAIN) {', 1]
['nchan_msg_t   msg;', 1]
['ch->channel.messages++;', 1]
['ngx_connection_t  *c;', 1]
['* application uses a different boolean type.', 1]
['return write_fixed_value(ctx, FIXMAP_MARKER | size);', 1]
['STLIBSUFFIX=a', 1]
['case CHAN_DELETE:', 1]
['#define NGX_MAX_INT_T_VALUE  2147483647', 1]
['chains[0].next = &chains[1];', 1]
['c->flags |= REDIS_MONITORING;', 1]
['if (buf == NULL) {', 1]
['value: [ :on, :off ],', 1]
['size += ngx_buf_size(chains[3].buf);', 1]
['//     redisSetDisconnectCallback(c,__test_callback,(void*)1);', 1]
['_he_new_buckets = (UT_hash_bucket*)uthash_malloc(                            \\', 1]
['ngx_event_t            gc_timer;', 1]
['sds sdsMakeRoomFor(sds s, size_t addlen) {', 1]
['//nchan_decode_msg_id_multi_tag(tag, n, decoded_tags);', 1]
['nchan_websocket_ping_interval [:srv, :loc, :if],', 1]
['dict *callbacks;', 1]
['u_char              *p, *unit;', 1]
['DBG("%p (%V) respond msg %p", self, f->sub.name, msg);', 1]
['r->rstack[0].type = -1;', 1]
['unsigned                already_responded:1;', 1]
['if (msg == NULL) {', 1]
['//super-heavy debugging setup', 1]
['if(head->status != INACTIVE) {', 1]
['A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT', 1]
['assert(array_sz == 9);', 1]
['p->events |= UV_READABLE;', 1]
['in higher level language bindings for efficient reply parsing.', 1]
['ngx_int_t nchan_respond_msg(ngx_http_request_t *r, nchan_msg_t *msg, nchan_msg_id_t *msgid, ngx_int_t finalize, char **err);', 1]
['ipc_alert(nchan_memstore_get_ipc(), sender, IPC_GET_MESSAGE_REPLY, d, sizeof(*d));', 1]
['bc[1].buf.pos = headerbuf;', 1]
['nchan_store_redis.exit_worker(cycle);', 1]
['if(msg_id->time == 0) {', 1]
['return cmp_write_str8_marker(ctx, obj->as.str_size);', 1]
['* s = sdsempty("Sum is: ");', 1]
['size_t free = sdsavail(s);', 1]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(TCP_NODELAY)");', 1]
['if (ngx_strncmp((*hashes)[i], hash, REDIS_LUA_HASH_LENGTH)==0) {', 1]
["if redis.call('EXISTS', key.channel) ~= 0 then", 1]
['boundary[i].start = &char_boundary[2];', 1]
['ngx_str_t              *msgid_str = msgid_to_str(&msg->id);', 1]
['if (dec >= 0 && dec < 10) {', 1]
['if (!write_type_marker(ctx, FIXEXT8_MARKER))', 1]
['spl->bulk_post_subscribe_handler(spl, newspool->non_internal_sub_count, spl->bulk_post_subscribe_privdata);', 1]
['else if(CHECK_REPLY_STR(el)) {', 1]
['void redisAppendCommand(redisContext *c, const char *format, ...);', 1]
['obj->as.u32 = be32(obj->as.u32);', 1]
["case 'r': c = '\\r'; break;", 1]
['key.message', 1]
['"local time=tonumber(ARGV[2])\\n"', 1]
['ngx_int_t         offset = offsetof(rbtree_seed_t, sentinel);', 1]
['else if(ngx_strmatch(&msg_type, "msgkey")) {', 1]
['stat->func);', 1]
["local ttl = redis.call('TTL', msg_id)", 1]
['ngx_buf_t               databuf;', 1]
['"  <subscribers>%ui</subscribers>" CRLF', 1]
['if ((frame->opcode != WEBSOCKET_OPCODE_TEXT) && (frame->opcode != WEBSOCKET_OPCODE_CLOSE) && (frame->opcode != WEBSOCKET_OPCODE_PING) && (frame->opcode != WEBSOCKET_OPCODE_PONG)) {', 1]
['#define NCHAN_DEFAULT_BUFFER_TIMEOUT 3600', 1]
['int port = (argc > 2) ? atoi(argv[2]) : 6379;', 1]
['* s = sdstrim(s,"A. :");', 1]
['DBG("found spool node %p with msgid %V", node, msgid_to_str(id));', 1]
['HASH_BLOOM_MAKE((head)->hh.tbl);                                               \\', 1]
['v /= 10;', 1]
['"      found_msg_id=channel.current_message\\n"', 1]
['hdr_buf->last_buf=1;', 1]
['//create a temporary pool to allocate temporary elements', 1]
['if (!dst) {                                                          \\', 1]
['_mur_k1 = MUR_GETBLOCK(_mur_blocks,_mur_i);                        \\', 1]
['__redisPushCallback(&ac->sub.invalid,&cb);', 1]
['return (char*)sh->buf;', 1]
["if((cur + 1 <= last) && cur[0]==' ') {", 1]
['cur = ngx_http_time(cur, msg->id.time);', 1]
['if(nchan_store_memory.init_postconfig(cf)!=NGX_OK) {', 1]
['#include <sys/time.h>', 1]
['"setkeyttl(active_ttl)\\n"', 1]
['//now how about the mesage tag?', 1]
['ngx_pool_cleanup_t             *cln = NULL;', 1]
['ngx_str_t                  evstr;', 1]
['lcf->storage_engine=NULL;', 1]
['code_net=htons(code);', 1]
['#define redisReplyReaderCreate redisReaderCreate', 1]
['DBG("IPC received delete request for channel %V privdata %p", d->shm_chid, d->privdata);', 1]
['if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {', 1]
['&& CHECK_REPLY_INT_OR_STR(els[offset+2])   //id - tag', 1]
['ERR("      received FLOOD TEST from %i seq %l", sender, d->n);', 1]
['bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size) {', 1]
['else if (type_marker == BIN32_MARKER) {', 1]
['#define HIREDIS_MAJOR 0', 1]
['ngx_int_t nchan_free_msg_id(nchan_msg_id_t *id) {', 1]
['if (strchr(intfmts,*_p) != NULL) {', 1]
['static ngx_int_t nchan_init_module(ngx_cycle_t *cycle) {', 1]
['__redisReaderSetErrorProtocolByte(r,*p);', 1]
['ngx_int_t memstore_ready_chanhead_unless_stub(nchan_store_channel_head_t *head);', 1]
['#if !defined(_BSD_SOURCE)', 1]
['redisAeEvents *e;', 1]
['pd->rc = status;', 1]
['//static void spool_bubbleup_bulk_dequeue_handler(subscriber_pool_t *spool, subscriber_type_t type, ngx_int_t count, channel_spooler_t *spl);', 1]
['"if redis.call(\'EXISTS\', key.message) ~= 0 then\\n"', 1]
['if(sub_create) {', 1]
['being created by the default reply object functions.', 1]
['sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {', 1]
['/* No need to check cmd since it is the last statement that can fail,', 1]
['static ngx_int_t nchan_memstore_chanhead_ready_to_reap(nchan_store_channel_head_t *ch, uint8_t force) {', 1]
['uint32_t        subscribers;', 1]
['nchan_msg_id_t      wanted_msgid;', 1]
['for(i=0; i < workers; i++) {', 1]
['uint16_t dst_n = dst->tagcount, src_n = src->tagcount;', 1]
['#define MUR_ROTL32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))', 1]
['legacy: "push_max_channel_subscribers",', 1]
['ngx_memset(spool, 0x42, sizeof(*spool)); //debug', 1]
['file = buf_copy->file;', 1]
['* The output will be "2", but if we comment out the call to sdsupdatelen()', 1]
['ngx_int_t update_subscriber_last_msg_id(subscriber_t *sub, nchan_msg_t *msg) {', 1]
['* Writes the binary data marker to the backend.  This is useful if you are', 1]
['#if (defined(__BIG_ENDIAN__) || defined(SPARC) || defined(__ppc__) || defined(__ppc64__))', 1]
['u_char  header[8];', 1]
['ngx_memzero(&ccv, sizeof(ccv));', 1]
['bool cmp_read_bool(cmp_ctx_t *ctx, bool *b);', 1]
['obj->as.ext.size = ext_size;', 1]
['ac = realloc(c,sizeof(redisAsyncContext));', 1]
['cur->type = REDIS_REPLY_STATUS;', 1]
['if(content_length == 0) {', 1]
['//no empty buffers please', 1]
["case '4': return 4;", 1]
['///no buffer', 1]
['free(cb);', 1]
['ac->ev.addRead = redisAeAddRead;', 1]
['subscribe_data_free(data);', 1]
['ERR("got IPC alert delayed by %i sec", ngx_time() - alert.time_sent);', 1]
['u_char         *fname, *last;', 1]
['d->multi = &chanhead->multi[n];', 1]
["--  pubsub=       'channel:subscribers:'..id, --set", 1]
['nchan_memstore_publish_generic(d->multi_chanhead, &remsg, 0, NULL);', 1]
['rbtree_walk(&spl->spoolseed, (rbtree_walk_callback_pt )spooler_spool_dequeue_all, (void *)spl);', 1]
['static ngx_int_t nchan_message_alert_type_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['if ((ctx)->ev.addRead) (ctx)->ev.addRead((ctx)->ev.data); \\', 1]
['return websocket_frame_header_chain(fsub, WEBSOCKET_TEXT_LAST_FRAME_BYTE, ngx_buf_size(msg_buf));', 1]
['subt->eventsource=0;', 1]
['nchan_variable_t              *var;', 1]
['ngx_buf_t *nchan_channel_info_buf(ngx_str_t *accept_header, ngx_uint_t messages, ngx_uint_t subscribers, time_t last_seen, nchan_msg_id_t *last_msgid, ngx_str_t **generated_content_type) {', 1]
['ngx_int_t nchan_detect_multipart_subscriber_request(ngx_http_request_t *r) {', 1]
['fsub->sub.last_msgid = msg->id;', 1]
['chmsg->msg  = msg;', 1]
['for(cur = spool->first; cur != NULL; cur = spool->first) {', 1]
['assert(max == oldid->tagcount);', 1]
['} nchan_request_ctx_t;', 1]
['sh->free -= incr;', 1]
['if (list->head == NULL)', 1]
['* if the table is "full" dobule its size. */', 1]
['//nice and simple', 1]
['#define DICT_HT_INITIAL_SIZE     4', 1]
['* write event fires. When connecting was not succesful, the connect callback', 1]
['chanhead = nchan_memstore_get_chanhead(d->channel_id, d->sub->cf);', 1]
['hiredis.o: hiredis.c fmacros.h hiredis.h net.h sds.h', 1]
['/* Only use timeout when not NULL. */', 1]
['nchan_memstore_publish_generic(ch, NULL, NGX_HTTP_GONE, &NCHAN_HTTP_STATUS_410);', 1]
['"--output: message_tag, channel_hash {ttl, time_last_seen, subscribers, messages}\\n"', 1]
['static const ngx_str_t   content_type = ngx_string("text/event-stream; charset=utf-8");', 1]
['return spl;', 1]
['nchan_msg_id_t    *msgid = NULL;', 1]
['ssub->next = self->first;', 1]
['struct recycloc_page_t  *prev;', 1]
['if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {', 1]
['test("Format command by passing argc/argv without lengths: ");', 1]
['static ngx_int_t abort_response(subscriber_t *sub, char *errmsg) {', 1]
['test("Is able to deliver commands: ");', 1]
['if (obj.type != CMP_TYPE_SINT16) {', 1]
['"  <messages>%ui</messages>" CRLF', 1]
['hh_del->hh_prev->hh_next = hh_del->hh_next;                              \\', 1]
['if(spool->msg_status == MSG_CHANNEL_NOTREADY) {', 1]
['strcmp(c->errstr,"Server closed the connection") == 0);', 1]
['es_event_len = els[offset+7]->len;', 1]
['int nchan_timeval_subtract(struct timeval *result, struct timeval *x, struct timeval *y);', 1]
['if(newspool->sub_count > 0) {', 1]
['init_spool(spl, &spl->current_msg_spool, &latest_msg_id);', 1]
['cfg.type = CONN_FD;', 1]
['if (ngx_process != NGX_PROCESS_WORKER && ngx_process != NGX_PROCESS_SINGLE) {', 1]
['ngx_socket_t             fd = c->fd;', 1]
['*size = obj->as.bin_size;', 1]
['ipc_alert_t             *alerts = proc->wbuf.alerts;', 1]
['msg->msg->prev_id.tag.fixed[0] = 0;', 1]
['//set up read connection', 1]
["/* Make sure added region doesn't contain garbage */", 1]
['//#define NCHAN_SUBSCRIBER_LEAK_DEBUG 1', 1]
['} nchan_pub_subrequest_data_t;', 1]
['nchan_msg_id_t               req_msgid[NCHAN_MULTITAG_MAX];', 1]
['reply = redisCommand(c,"QUIT");', 1]
['pos = buf->start;', 1]
['struct UT_hash_handle *hh_next;   /* next hh in bucket order        */', 1]
['sds sdsRemoveFreeSpace(sds s) {', 1]
['DBG("IPC: send publish message to %i ch %V", dst, chid);', 1]
['"--clear short-term subscriber list\\n"', 1]
['if (prevde)', 1]
['static ngx_int_t websocket_publish(full_subscriber_t *fsub, ngx_buf_t *buf);', 1]
['| |1|2|3|       |K|             |                               |', 1]
['The same set of functions are used internally by hiredis when creating a', 1]
['* callbacks for all remaining replies. When this function is called from a', 1]
['uint32_t    array_sz;', 1]
['static ngx_int_t websocket_release(subscriber_t *self, uint8_t nodestroy) {', 1]
['//DEBUG CHECK -- REMOVE BEFORE RELEASE', 1]
['else if(msg) {', 1]
['ngx_int_t shm_destroy(shmem_t *shm) {', 1]
['static void redisLibevAddRead(void *privdata) {', 1]
['rp->tick_usec = tick_sec * 1000;', 1]
['0, //reservations', 1]
['nchan_pub_subrequest_stuff_t   *psr_stuff;', 1]
['time_t             now = ngx_time();', 1]
['ngx_http_cleanup_t      *cln;', 1]
['size_t             sz = ngx_strlen(lbl);', 1]
['nchan_store_publish_generic(&chid, NULL, NGX_HTTP_CONFLICT, &NCHAN_HTTP_STATUS_409);', 1]
['else if(rdt.chanhead_cleanup_head==NULL) {', 1]
['cl->next->prev=cl->prev;', 1]
['static ngx_int_t nchan_store_subscribe_continued(redis_subscribe_data_t *d);', 1]
['int _mur_i;                                                          \\', 1]
['ngx_int_t nchan_maybe_send_channel_event_message(ngx_http_request_t *r, channel_event_type_t event_type) {', 1]
['started_count = ch->channel.messages;', 1]
['redisContext *c = redisConnectBindNonBlock(ip,port,source_addr);', 1]
['struct timeval                  start_tv;', 1]
['ngx_chain_t             hdr_chain;', 1]
['if((stuff = shm_alloc(shm, total_sz, "message")) == NULL) {', 1]
['#define THING_HASH_DEL(tc, thing)      HASH_DEL(tc->things, thing)', 1]
["local msg=tohash(redis.call('HGETALL', msg_id))", 1]
['--input:  keys: [], values: [channel_id, number]', 1]
['msg.expires = 0;', 1]
['d->msg_id = msg_id;', 1]
['/* Disconnection is caused by an error, make sure that pending', 1]
['rds_ctx();', 1]
['v = ngx_http_add_variable(cf, &var->name, NGX_HTTP_VAR_CHANGEABLE);', 1]
['check the `err` field to see if establishing the connection was successful:', 1]
['ngx_str_t                      auth_request_url;', 1]
['retmsg.id.tag.allocd = multi_largetag;', 1]
['switch(chanhead->status) {', 1]
['case 200: //ok', 1]
['fwd_buf_to_str(&mpbuf, sz, &msg_type);', 1]
['DBG("chan index %i last id %V", i, msgid_to_str(lastid));', 1]
['#define IPC_DOES_CHANNEL_EXIST_REPLY 16', 1]
['NULL,                          /* init thread */', 1]
['NULL,                          /* init main configuration */', 1]
['cur->obj = obj;', 1]
['if((id_out = ngx_palloc(r->pool, sizeof(*id_out) + sz)) == NULL) {', 1]
['u_char                 char_boundary[50];', 1]
['if((channel_id = nchan_get_channel_id(r, SUB, 1)) == NULL) {', 1]
['"dbg(\\"id= \\", tostring(sub_id), \\"count= \\", tostring(sub_count))\\n"', 1]
['obj = r->fn->createString(cur,s+2,len);', 1]
['obj->as.u8 = 0;', 1]
['.host = "127.0.0.1",', 1]
['const  ngx_str_t NCHAN_HEADER_ETAG = ngx_string("Etag");', 1]
['ctx_type = "[Command]";', 1]
['chaninfo_copy.subscribers = ch->shared->sub_count;', 1]
['bool cmp_read_ext_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size);', 1]
['if((str = shm_alloc(shm, sz, "string")) == NULL) {', 1]
["* and 'initlen'.", 1]
['void redisFree(redisContext *c) {', 1]
['if(ch[4]) then', 1]
['int redisSetTimeout(redisContext *c, const struct timeval tv) {', 1]
['return chmsg;', 1]
['void ngx_rwlock_reserve_read(ngx_rwlock_t *lock)', 1]
['redisAsyncContext *ac = redisAsyncInitialize(c);', 1]
['for(cur = ch->msg_last; cur != NULL; cur=cur->prev){', 1]
['if (events & UV_WRITABLE) {', 1]
['nchan_postconfig,              /* postconfiguration */', 1]
["--  'active_ttl' is channel ttl with non-zero subscribers. -1 to persist, >0 ttl in sec", 1]
['/* SAX/FNV/OAT/JEN hash functions are macro variants of those listed at', 1]
['return sh->buf;', 1]
['# Copyright (C) 2010-2011 Salvatore Sanfilippo <antirez at gmail dot com>', 1]
['//set time and tag', 1]
['subscribe_data_t            *d = subscribe_data_alloc(sub->cf->use_redis ? -1 : owner);', 1]
['nchan_store_redis_fakesub_add(&ch->id, n);', 1]
['DBG("send unsubscribed to %i %V", dst, chid);', 1]
['ngx_buf_t                      *buf_copy;', 1]
['* Writes an object to the backend. This avoids using the STR8 marker, which', 1]
['if(enqueue) {', 1]
['bool cmp_read_decimal(cmp_ctx_t *ctx, double *d) {', 1]
['ngx_str_t *msgtag_to_str(nchan_msg_id_t *id) {', 1]
['for(i=0; i < ch->multi_count; i++) {', 1]
['nchan_memstore_force_delete_channel(d->shm_chid, (callback_pt )delete_callback_handler, d);', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "rwlock %p read lock wait", lock);', 1]
['d->cb_privdata = privdata;', 1]
['r->element = calloc(elements,sizeof(redisReply*));', 1]
['msgbuf.last = msgbuf.end;', 1]
['static ngx_int_t its_time_for_a_spooling(rbtree_seed_t *seed, subscriber_pool_t *spool, void *data) {', 1]
['ERR("unable to allocate memory for temporary pool");', 1]
['delete_multi_data_t   *d = ngx_calloc(sizeof(*d), ngx_cycle->log);', 1]
['//ngx_add_event(ipc->c[slot]->write, NGX_WRITE_EVENT, NGX_CLEAR_EVENT);', 1]
['test_cond("sdsMakeRoomFor()", sh->len == 1 && sh->free > 0);', 1]
['bool cmp_object_as_double(cmp_object_t *obj, double *d) {', 1]
['"dbg(\' #######  FIND_CHANNEL ######## \')\\n"', 1]
['"  dbg(\\"channel.mas_stored_messages == \\" , channel.max_stored_messages)\\n"', 1]
['char                *p = conf;', 1]
['if (!(c->flags & REDIS_SUBSCRIBED)) return REDIS_ERR;', 1]
['case 410: //gone', 1]
['#define test_cond(_c) if(_c) printf("\\033[0;32mPASSED\\033[0;0m\\n"); else {printf("\\033[0;31mFAILED\\033[0;0m\\n"); fails++;}', 1]
['DBG("first response: %V (n:%i) %p", d->msg ? msgid_to_str(&d->msg->id) : &empty_id_str, d->n, d->msg);', 1]
['uint32_t _mur_c2 = 0x1b873593;                                       \\', 1]
['if(*priority>start) {', 1]
['/* Reply callback prototype and container */', 1]
['test: hiredis-test', 1]
['spooler_add_subscriber,', 1]
['r->type = type;', 1]
['last_link = &bc->chain;', 1]
['memstore_ipc_send_does_channel_exist(owner, channel_id, (callback_pt )nchan_store_subscribe_sub_reserved_check, d);', 1]
['for(cur = *s1; cur < last; cur++) {', 1]
['[:loc_conf, :subscriber_timeout],', 1]
['(head)->hh.tbl->buckets = (UT_hash_bucket*)uthash_malloc(                      \\', 1]
['static subscribe_data_t *subscribe_data_alloc(ngx_int_t owner) {', 1]
['nchan_pub_subrequest_data_t   *psrd = &psr_stuff->psr_data;', 1]
["/* here's the deal: we have no control over fork()ing, nginx's internal", 1]
['dictFreeEntryVal(ht, he);', 1]
['#ifndef UTHASH_H', 1]
['fsub->data.multimsg_last->next = mmsg;', 1]
['HASH_REPLACE(hh,head,intfield,sizeof(int),add,replaced)', 1]
['#define HASH_INITIAL_NUM_BUCKETS_LOG2 5  /* lg2 of initial number of buckets */', 1]
['if((spooler = ngx_alloc(sizeof(*spooler), ngx_cycle->log))==NULL) {', 1]
['nchan_channel_t                *channel;', 1]
['#define __REDIS_NGINX_ADAPTER_H', 1]
['HASH_REPLACE(hh,head,strfield[0],strlen(add->strfield),add,replaced)', 1]
['obj->type = CMP_TYPE_NIL;', 1]
['return &spl->current_msg_spool;', 1]
['static ngx_str_t evt_sub_dequeue = ngx_string("subscriber_dequeue");', 1]
['*   cc -## a.c (where a.c is a simple test file)   (Sun Studio)', 1]
['msg_id, msg_time, msg_tag = msg.id, msg.time, msg.tag', 1]
['static void set_buf_to_str(ngx_buf_t *buf, const ngx_str_t *str);', 1]
['static ngx_int_t spooler_channel_status_changed(channel_spooler_t *self) {', 1]
['"local msgpacked\\n"', 1]
['int16_t         fixed[NCHAN_FIXED_MULTITAG_MAX];', 1]
['assert(head->sub_count >= 0);', 1]
['#define NCHAN_INVALID_SLOT           -1', 1]
["local pubsub=     'channel:pubsub:'..id", 1]
['bool cmp_object_as_sinteger(cmp_object_t *obj, int64_t *d) {', 1]
['local no_msgid_order=ARGV[4]', 1]
['struct dict *channels;', 1]
['ngx_encode_base64(&ws_accept_key, &sha1_str);', 1]
['* Neither the name of Redis nor the names of its contributors may be used', 1]
['static ngx_int_t websocket_respond_status(subscriber_t *self, ngx_int_t status_code, const ngx_str_t *status_line) {', 1]
['if(multipart_fn == NULL) {', 1]
['//publisher types', 1]
['bool cmp_write_ext32(cmp_ctx_t *ctx, int8_t tp, uint32_t sz, const void *data) {', 1]
['reply = redisCommand(context, "SET foo %s", value);', 1]
['default: "$nchan_channel_event $nchan_channel_id",', 1]
['if (iter->entry == NULL) {', 1]
['In every case, the `errstr` field in the context will be set to hold a string representation', 1]
['assert(msg != NULL);', 1]
['unsigned             generation;', 1]
['def test_walk_buffer', 1]
['if(conf->authorize_request_url == NULL) {', 1]
['ngx_int_t ipc_alert(ipc_t *ipc, ngx_int_t slot, ngx_uint_t code,  void *data, size_t data_size);', 1]
['static char *nchan_setup_handler(ngx_conf_t *cf, void * conf, ngx_int_t (*handler)(ngx_http_request_t *)) {', 1]
['c->flags &= ~REDIS_SUBSCRIBED;', 1]
['#include "memstore_multi.h"', 1]
['_prev = NULL;                                                        \\', 1]
['else if(nchan_strmatch(val, DISABLED_STRINGS_N, DISABLED_STRINGS)) {', 1]
['HASH_BLOOM_ADD((head)->hh.tbl,(add)->hh.hashv);                                 \\', 1]
['v->data = var->data;', 1]
['void *obj; /* holds user-generated value for a read task */', 1]
['bool cmp_write_str_v4(cmp_ctx_t *ctx, const char *data, uint32_t size);', 1]
['chid_conf = &cf->pubsub_chid;', 1]
['void (*addWrite)(void *privdata);', 1]
['//ERR("Comparing msgids: id1: %V --", msgid_to_str(id1));', 1]
['nchan_reaper_add(&mpt->msg_reaper, msg);', 1]
['ERR("can\'t alloc enough (%i) memory for recycloc", sizeof(recycloc_t) + page_size);', 1]
['legacy: "push_max_reserved_memory",', 1]
['r->headers_out.content_type.len = content_type->len;', 1]
['u_char                 *cur=headerbuf;', 1]
['void __redisSetError(redisContext *c, int type, const char *str) {', 1]
['//DBG("%s channel id NULL", what == PUB ? "pub" : "sub");', 1]
['Replies should be freed using the `freeReplyObject()` function.', 1]
['remsg.id.tagcount = mcount;', 1]
['DBG("create shm_str %p (data@ %p) %V", out, out->data, out);', 1]
['-- result_code can be: 200 - ok, 404 - not found, 410 - gone, 418 - not yet available', 1]
['frame->step = WEBSOCKET_READ_GET_PAYLOAD_STEP;', 1]
['nchan_buf_and_chain_t   bc[3];', 1]
['@@redis=nil', 1]
['srdata.n = 0;', 1]
['$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. -I$(LIBUV_DIR)/include $< $(LIBUV_DIR)/.libs/libuv.a -lpthread $(STLIBNAME)', 1]
['static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,', 1]
['assert(spool->sub_count == 0);', 1]
['if(nchan_set_msgid_http_response_headers(r, msgid) != NGX_OK) {', 1]
['ngx_memcpy(d->channel_id->data, channel_id->data, channel_id->len);', 1]
['channel_copy->subscribers = sub_count;', 1]
['//getc that shit', 1]
['if (reply != NULL) *reply = aux;', 1]
['if (++(_he_newbkt->count) > tbl->ideal_chain_maxlen) {                \\', 1]
['/* could not consume 1 byte */', 1]
['content_type=ARGV[4],', 1]
['shmsg_memspace_t        *stuff;', 1]
["* further expansion, as it's not helping; this happens when the hash", 1]
['nchan_msg_id_t          *msgid = &sub->last_msgid;', 1]
['return cmp_write_bin16_marker(ctx, size);', 1]
['/* Compare two sds strings s1 and s2 with memcmp().', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:MEM-REDIS:" fmt, ##arg)', 1]
['createStringObject,', 1]
['sub_count = chead->shared->sub_count;', 1]
['node->key = seed->hash(id);', 1]
['if(rdt.subscriber_id[0] == 0) {', 1]
['DBG("update number of workers from %i to %i", shdata->max_workers, workers);', 1]
['struct timeval tv = { 0, 1000 };', 1]
['//assumes all SHORTLIVED subs are the same type. This is okay for now, but may lead to bugs.', 1]
['if(sub->cf->eventsource_event.len > 0) {', 1]
['void ngx_rwlock_release_read(ngx_rwlock_t *lock) {', 1]
['/* Write the output buffer to the socket.', 1]
['bool cmp_read_fixext16(cmp_ctx_t *ctx, int8_t *type, void *data) {', 1]
['* (The multiplier is simply expand_mult+1). The whole idea of this', 1]
['store_message_t             *smsg;', 1]
['local msg={', 1]
['bool cmp_object_is_bin(cmp_object_t *obj) {', 1]
['"while true do\\n"', 1]
['* as in: "foo"bar or "foo\'', 1]
['* allow to search a limited length and the buffer that is being searched', 1]
['rp->ready = ready;', 1]
['dbg("NEXT MESSAGE KEY PRESENT: " .. msg.next)', 1]
['subscriber_t *longpoll_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id) {', 1]
['long len;', 1]
["* safe string pointed by 't' of length 'len' bytes. */", 1]
['"if on then return function(...) \\n"', 1]
['bool cmp_read_fixext8(cmp_ctx_t *ctx, int8_t *type, void *data);', 1]
['tmpid.len = vv->len;', 1]
['#define MUR_GETBLOCK(p,i) p[i]', 1]
['if(rp->count == 0) {', 1]
['/* Split a line into arguments, where every argument can be in the', 1]
['static int redisSetBlocking(redisContext *c, int blocking) {', 1]
['"local msg_id\\n"', 1]
['nchan_output_filter(r, &bc.chain);', 1]
['.unix = {', 1]
['for (;;) {', 1]
['ngx_free(fakeprocess_top);', 1]
['ngx_memcpy(dst, src, sizeof(*src));', 1]
['head->slot = memstore_slot();', 1]
['len = msgtag_to_strptr(id, msgtag_str_buf);', 1]
['ngx_int_t longpoll_subscriber_destroy(subscriber_t *sub) {', 1]
['static ngx_str_t * nchan_store_etag_from_message(nchan_msg_t *, ngx_pool_t *);', 1]
['msg_release(d->msg, "get multi msg");', 1]
['cur = seed->actives[i];', 1]
['ngx_str_t    *shm_chid;', 1]
['* including:', 1]
['subscriber_t *sub;', 1]
['nchan_store_channel_head_t     *churn_prev;', 1]
['#define NCHAN_MAX_CHANNEL_ID_LENGTH 1024 //bytes', 1]
['if(ctx == NULL || ctx->subscriber_type == NULL) {', 1]
['if(ssub == NULL) {', 1]
['redis_nginx_ping_callback(redisAsyncContext *ac, void *rep, void *privdata)', 1]
['#define _XOPEN_SOURCE 600', 1]
['bool cmp_write_array32(cmp_ctx_t *ctx, uint32_t size);', 1]
['CMP_TYPE_EXT16,           /* 10 */', 1]
['* In fractions this is just n/b (n=number of items,b=new num buckets).', 1]
['ngx_int_t ipc_register_worker(ipc_t *ipc, ngx_cycle_t *cycle);', 1]
['for ( ;; ) {', 1]
['if ((p = readBytes(r,1)) != NULL) {', 1]
['bool cmp_write_str8(cmp_ctx_t *ctx, const char *data, uint8_t size) {', 1]
['down performances considerably, so it is possible to modify the max size of', 1]
['d->rc = rc;', 1]
['typedef struct recycloc_trash_s recycloc_trash_t;', 1]
['for (stat = ngx_pool_stats[i]; stat != NULL; stat = stat->next) {', 1]
['return websocket_send_close_frame(fsub, CLOSE_POLICY_VIOLATION, &nopublishing);', 1]
['if(timer == NULL) {', 1]
['### Hooking it up to event library *X*', 1]
['if(tc < 0) {', 1]
['newarg = sdscat(curarg,"%");', 1]
['////////// UNSUBSCRIBED ////////////////', 1]
['hashv     = (hashv << 16) ^ _sfh_tmp;                                        \\', 1]
['shdata->reloading += shdata->max_workers;', 1]
['ngx_conf_log_error(NGX_LOG_WARN, cf, 0, "invalid %V value: %V", &cmd->name, val);', 1]
['#define MUR_PLUS1_ALIGNED(p) (((unsigned long)p & 0x3) == 1)', 1]
['static u_char          *chunk_end=(u_char *)"\\r\\n";', 1]
['if(thing) assert(cur != thing);', 1]
['ngx_uint_t           i;', 1]
['ngx_int_t nchan_reaper_add(nchan_reaper_t *rp, void *thing);', 1]
['"    msg.prev_time or 0,\\n"', 1]
['test("Is a able to send commands verbatim: ");', 1]
['#binding.pry', 1]
['* Often you need to create a string from scratch with the printf-alike', 1]
["test_cond(c->err == REDIS_ERR_IO); /* Don't care about the message... */", 1]
['subscriber_t *longpoll_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id);', 1]
['if(subdebug_head == sub) {', 1]
['#ifndef NGX_HTTP_GONE', 1]
['ngx_int_t                rc;', 1]
['bool cmp_write_nil(cmp_ctx_t *ctx);', 1]
["if((ret = ngx_strlchr(cur, last, '@')) == NULL) {", 1]
['ngx_memzero(&dummy_config, sizeof(dummy_config));', 1]
['ERR("can\'t create output chain, file in buffer won\'t open");', 1]
['assert_equal "PONG", redis.ping', 1]
['cbuf->file->fd=buf->file->fd;', 1]
['nchan_msg_id_t    *lastid;', 1]
['dummy_config.max_messages = -1;', 1]
['//ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: connection to redis failed - %s", ac->errstr);', 1]
['if(d->sub->release(d->sub) == NGX_OK) {', 1]
['switch(*self->channel_status) {', 1]
['} redisAeEvents;', 1]
['close_code = CLOSE_NORMAL;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not add read event to redis");', 1]
['REDIS_PORT=8537', 1]
['chrtos(cbuf,sizeof(cbuf),byte);', 1]
['| Masking-key (continued)       |          Payload Data         |', 1]
['"  if create_channel_ttl==0 then\\n"', 1]
['#define CHANNEL_HASH_FIND(id_buf, p)    HASH_FIND( hh, rdt.subhash, (id_buf)->data, (id_buf)->len, p)', 1]
['int totlen = 0;', 1]
['ngx_conf_merge_value(conf->subscriber_start_at_oldest_message, prev->subscriber_start_at_oldest_message, 1);', 1]
['DBG("%s scan max notready %i", rp->name, max_notready);', 1]
['if ((nchan_add_response_header(r, &NCHAN_HEADER_ETAG, etag))==NULL) {', 1]
['[![Build Status](https://travis-ci.org/redis/hiredis.png)](https://travis-ci.org/redis/hiredis)', 1]
['is a stream parser designed for easy reusability, which can for instance be used', 1]
['*eventsource_fn = *sub->fn;', 1]
['DBG("ensure chanhead ready: chanhead %p, status %i, foreign_ipc_sub:%p", head, head->status, head->foreign_owner_ipc_sub);', 1]
['//cur = copy_preallocated_str_to_cur(&dst_str, &src_str, cur);', 1]
['int elements = 0, slots = 5, start = 0, j;', 1]
['last = filename->data + len;', 1]
['return nchan_memstore_handle_get_message_reply(chmsg == NULL ? NULL : chmsg->msg, findmsg_status, d);', 1]
['DBG("send subscribe to %i, %V", dst, chid);', 1]
['char * (*hashes)[]=(char* (*)[])&store_rds_lua_hashes;', 1]
['chanhead = NULL;', 1]
['redisReply *reply = (redisReply *)r;', 1]
['boundary[i].last_in_chain = 1;', 1]
['head->shared = d->shared_channel_data;', 1]
['* For the async API, we want to wait until the first write event is', 1]
['bool cmp_object_is_float(cmp_object_t *obj);', 1]
['bc[2].chain.next = &bc[3].chain;', 1]
['prevde = de;', 1]
['INSTALL?= cp -r', 1]
['uv_run(loop, UV_RUN_DEFAULT);', 1]
['"local sub_count\\n"', 1]
['it = dictGetIterator(ac->sub.patterns);', 1]
['unsigned                      use_redis:1;', 1]
['static ngx_int_t publish_message_generic_callback(ngx_int_t, void *, void *);', 1]
['INSTALL?= cp -a', 1]
['ret= ipc_alert(nchan_memstore_get_ipc(), dst, IPC_PUBLISH_MESSAGE, &data, sizeof(data));', 1]
['len = redisvFormatCommand(target,format,ap);', 1]
["sub_count=redis.call('hincrby', keys.channel, 'subscribers', 1)", 1]
['default: ["websocket", "eventsource", "longpoll", "chunked", "multipart-mixed"],', 1]
['CONN_UNIX,', 1]
['extern const ngx_str_t NCHAN_HEADER_SEC_WEBSOCKET_KEY;', 1]
['/* Reads an unsigned integer that fits inside an unsigned long */', 1]
['assert(seed->active_nodes == 0);', 1]
['unsigned               active:1;', 1]
['sent << publish(Msg.new(id, data: "fee", ttl: 30))', 1]
['if((sub = websocket_subscriber_create(r, NULL)) == NULL) {', 1]
['head->channel.last_published_msg_id.tag.fixed[0]=0;', 1]
['/* Precision */', 1]
['size_t sdsAllocSize(sds s) {', 1]
['DBG("spool for msgid %V not found. discarding getmsg callback response.", msgid_to_str(&data->msgid));', 1]
['ngx_event_t                      cleanup_timer;', 1]
['$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< -lev $(STLIBNAME)', 1]
['"dbg(\' ######## SUBSCRIBER UNREGISTER SCRIPT ####### \')\\n"', 1]
['fakebody_buf->start = ngx_palloc(r->pool, sz); //huuh?', 1]
["redis.call('EXPIRE', key.message, msg.ttl)", 1]
['long long t1, t2;', 1]
['bc[0].buf.last = bc[0].buf.end;', 1]
["case 'b':", 1]
['((UT_hash_handle*)((ptrdiff_t)_hd_hh_del->next +                     \\', 1]
['void             *shm_locked_alloc(shmem_t *shm, size_t size, const char *label);', 1]
['puts out', 1]
['nchan_create_main_conf,        /* create main configuration */', 1]
['} else if (*p == \'"\') {', 1]
['id[n_out].data = cur_first;', 1]
['"    dbg(\\"NEXT MESSAGE KEY PRESENT: \\" .. msg.next)\\n"', 1]
['&nchan_store_content_type_from_message,', 1]
['* redisAppendCommand, followed by redisGetReply. The function will return', 1]
['case \'\\n\': len = snprintf(buf,size,"\\"\\\\n\\""); break;', 1]
['websocket_publish_continue(fsub, &d->buf);', 1]
['ctx->multipart_boundary->data=(u_char *)&ctx->multipart_boundary[1];', 1]
['bool cmp_write_ufix(cmp_ctx_t *ctx, uint8_t c);', 1]
['//message was queued successfully, but there were no subscribers to receive it.', 1]
['c->flags |= REDIS_BLOCK | REDIS_CONNECTED;', 1]
['/* Try to read pending replies */', 1]
['return cmp_write_fixext16_marker(ctx, tp);', 1]
['uint32_t        sz;', 1]
['static nchan_msg_id_t        latest_msgid = NCHAN_NEWEST_MSGID;', 1]
['cfg.type = CONN_UNIX;', 1]
['HASH_FIND(hh,head,findint,sizeof(int),out)', 1]
['*d = obj.as.s16;', 1]
['ngx_memzero(&bc[3].buf, sizeof(ngx_buf_t));', 1]
['uint32_t size;', 1]
['rbtree_seed_t               spoolseed;', 1]
['nchan_msg_t       remsg;', 1]
['bool cmp_write_str32_marker(cmp_ctx_t *ctx, uint32_t size) {', 1]
['c->flags |= REDIS_SUBSCRIBED;', 1]
['if (frame->opcode == WEBSOCKET_OPCODE_TEXT) {', 1]
['//msg id', 1]
['static ngx_int_t spooler_set_add_handler(channel_spooler_t *self, void (*handler)(channel_spooler_t *, subscriber_t *, void *), void *privdata) {', 1]
['callback(data);', 1]
['s = s / 1024;', 1]
['fsub->timeout_handler(&fsub->sub, fsub->timeout_handler_data);', 1]
['local hmset = function (key, dict)', 1]
['static ngx_str_t msgtag_str;', 1]
['d->callback(MSG_NOTFOUND, NULL, d->privdata);', 1]
['INPUT_VALUE_TOO_LARGE_ERROR,', 1]
['subscriber_type_t          type;', 1]
['if (!cmp_write_fixext16_marker(ctx, type))', 1]
['assert(id != NULL);', 1]
['uint8_t                         multi_waiting;', 1]
['DBG("No subscribers, but there was one %i sec ago. don\'t unsubscribe.", ngx_time() - head->last_subscribed_local);', 1]
['size_t size;', 1]
['glob->ipc = (ipc_t *)c->data;', 1]
['if((head->shared = shm_alloc(shm, sizeof(*head->shared), "channel shared data")) == NULL) {', 1]
['if((chead = nchan_memstore_get_chanhead(&ids[i], cf)) == NULL) {', 1]
['//find_channel', 1]
['ngx_str_t                      *id = NULL;', 1]
['"  time_offset=  \'nchan:message_time_offset\',\\n"', 1]
['static ngx_int_t delete_callback_handler(ngx_int_t, nchan_channel_t *, delete_data_t *);', 1]
['ERR("verify_msg_id: multitag mismatch. missed message?");', 1]
['mid_time = msgid->time;', 1]
['//DBG("first message removed");', 1]
['#define __HIREDIS_LIBEV_H__', 1]
['unsigned         allocd:1;', 1]
['fakebody_buf->last = fakebody_buf->end;', 1]
['for(cur = tree->root; cur != NULL && cur != sentinel; cur = tree->root) {', 1]
['chmsg = chanhead_find_next_message(d->chanhead, &d->msg_id, &findmsg_status);', 1]
['//any expired messages?', 1]
['nchan_timeval_subtract(&diff, &tv, &msg->start_tv);', 1]
['cur->type = REDIS_REPLY_STRING;', 1]
['void *nchan_thingcache_init(char *name, void *(*create)(ngx_str_t *), ngx_int_t(*destroy)(ngx_str_t *, void *), ngx_uint_t ttl);', 1]
['redisAsyncCommand(rds_ctx(), &redisCheckErrorCallback, NULL, "EVALSHA %s 0 %b %i", store_rds_lua_hashes.add_fakesub, STR(channel_id), count);', 1]
['if(shdata->msgdebug_head == msg) {', 1]
['head->channel.last_published_msg_id.tagcount=1;', 1]
['typedef size_t (*cmp_writer)(struct cmp_ctx_s *ctx, const void *data,', 1]
['nwritten = write(c->fd,c->obuf,sdslen(c->obuf));', 1]
['return cmp_write_bin8(ctx, data, size);', 1]
['self->bulk_dequeue_handler_privdata = privdata;', 1]
['fsub->data.timeout_ev.handler = timeout_ev_handler;', 1]
['spool->sub_count = 0;', 1]
['static ngx_int_t websocket_reserve(subscriber_t *self);', 1]
['int s, rv;', 1]
['{ ngx_string("nchan_channel_event_string"),', 1]
['ERR("can\'t get chanhead for id %V", channel_id);', 1]
['int16_t      *muhtags;', 1]
['eventsource_event=ARGV[5],', 1]
['def test_connection', 1]
['msg_id, channel = publish chid: randid, data: "hello what is this", ttl: 10, content_type: "X-fruit/banana"', 1]
["if (*c == ' ') {", 1]
['ngx_buf_t *nchan_chain_to_single_buffer(ngx_pool_t *pool, ngx_chain_t *chain, size_t content_length);', 1]
['bool cmp_write_fixmap(cmp_ctx_t *ctx, uint8_t size);', 1]
['obj->type = CMP_TYPE_FIXEXT2;', 1]
['dbg("get most recent")', 1]
['*last_chain = &bc[1].chain;', 1]
['static int _dictKeyIndex(dict *ht, const void *key) {', 1]
['"4965038f835d8a7599134b9e02f50a9b269fdeea",', 1]
['#include <util/nchan_util.h>', 1]
['pd->ch.last_seen = ch->last_seen;', 1]
['sp = start = s;', 1]
['/* add an item to a bucket  */', 1]
['* For instance: sdsmapchars(mystring, "ho", "01", 2)', 1]
['if max_stored_msgs < 0 then --no limit', 1]
['/* Functions that proxy to hiredis */', 1]
['struct event rev, wev;', 1]
['switch(frame->payload_len) {', 1]
['DBG("close fd %u ", f->fd);', 1]
['"  table.insert(nearly_departed, num_messages)\\n"', 1]
['static ngx_int_t nchan_store_publish_generic(ngx_str_t *, nchan_msg_t *, ngx_int_t, const ngx_str_t *);', 1]
['struct timespec  tv;', 1]
['_last_elt_hh = _dst_hh;                                              \\', 1]
['msg->msg->id.time = ngx_time();', 1]
['FALSE_MARKER           = 0xC2,', 1]
['static void redisContextCloseFd(redisContext *c) {', 1]
['if(ch->msg_first == msg) {', 1]
['/* Writes a boolean value to the backend */', 1]
['static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {', 1]
['dict *ht;', 1]
['msg_debug_assert_isempty();', 1]
['#endif  /* NCHAN_TYPES_H */', 1]
['c = *cur;', 1]
["dbg(' ######## SUBSCRIBER REGISTER SCRIPT ####### ')", 1]
['#define HASH_JEN_MIX(a,b,c)                                                      \\', 1]
['"local ttl = redis.call(\'TTL\', key)\\n"', 1]
['#define REDIS_ERR_PROTOCOL 4 /* Protocol error */', 1]
["message=      'channel:msg:%s:%s', --hash", 1]
['memstore_procslot_offset = i + 1 - shdata->max_workers;', 1]
['#', 1]
['local channel', 1]
['cur = ngx_strlcasestrn(tmp->data, last, (u_char *)"chunked", 7 - 1);', 1]
['((internal_subscriber_t *)sub)->respond_message = handler;', 1]
['struct UT_hash_table *tbl;', 1]
['obj->type = CMP_TYPE_FIXARRAY;', 1]
['ngx_str_t *ngx_http_debug_pool_str(ngx_pool_t *pool);', 1]
['ws_accept_key.data = buf;', 1]
['bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size) {', 1]
['ctx->channel_id[0] = *id;', 1]
['unixsocket /tmp/hiredis-test-redis.sock', 1]
['shdata->procslot[i] = NCHAN_INVALID_SLOT;', 1]
['buf->last += n;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: Failed loading redis lua scripts %s :%s", (*names)[i], reply->str);', 1]
['if(conf->pub_chid.n == 0) {', 1]
['pr = r->parent;', 1]
['DECLTYPE_ASSIGN(dst,_elt);                                         \\', 1]
['lastid = &multi[i].sub->last_msgid;', 1]
['--input:  keys: [], values: [channel_id, msg_time, msg_tag, no_msgid_order, create_channel_ttl]', 1]
["case '\\r':", 1]
['int nread;', 1]
['va_arg(ap,long long);', 1]
['sdstrim(x,"xy");', 1]
['vv = ngx_http_get_variable(r, &channel_id_var_name, key);', 1]
['chanhead_pubsub_status_t     status;', 1]
['nchan_conf_subscriber_types_t   sub;', 1]
['unsigned hashv;                   /* result of hash-fcn(key)        */', 1]
['ngx_http_cleanup_t          *original_cleanup;', 1]
['//#define PUB_FAKE_WORKER 0', 1]
["dbg(' ####### FAKESUBS ####### ')", 1]
['static ngx_str_t group =           ngx_string("meta");', 1]
['//message was queued successfully, and it was already sent to at least one subscriber', 1]
['first_chain = &chains[0];', 1]
['fsub->timeout_ev.handler = timeout_ev_handler;', 1]
['bool cmp_write_u8_as_bool(cmp_ctx_t *ctx, uint8_t b) {', 1]
['fakebody_chain = ngx_palloc(r->pool, sizeof(*fakebody_chain));', 1]
['static nchan_loc_conf_t            evcf_data;', 1]
['fsub->data.dequeue_handler_data = privdata;', 1]
['MUR_FMIX(_mur_h1);                                                   \\', 1]
['if(id1->time != id2->time) {', 1]
['ngx_str_t    id;', 1]
['"  redis.call(\'HSET\', key.channel, \'ttl\', channel.ttl)\\n"', 1]
['for(i = 0; i < NGX_MAX_PROCESSES; i++) {', 1]
['rdt.cleanup_timer.handler=&nchan_store_chanhead_cleanup_timer_handler;', 1]
['ret= NCHAN_MESSAGE_QUEUED;', 1]
['static ngx_str_t   pub_name = ngx_string("websocket");', 1]
['/* obtain a count of items in the hash */', 1]
['ws_frame_t                 *frame = &fsub->frame;', 1]
['struct=[]', 1]
['} while (!wdone);', 1]
["//don't deallocate shm_msg", 1]
['memset((head)->hh.tbl->buckets, 0,                                             \\', 1]
['fsub->timeout_handler = sub_empty_callback;', 1]
['databuf.start = cur;', 1]
['redisReadTask *cur, *prv;', 1]
['ipc->handler(alert.src_slot, alert.code, alert.data);', 1]
['//nchan_msg_id_t   *last_msgid;', 1]
['//too small', 1]
['static dictIterator *dictGetIterator(dict *ht) {', 1]
['ngx_memcpy(rsv->lbl, lbl, ngx_strlen(lbl));', 1]
['store_channel_head_shm_t     *old_shared;', 1]
['va_copy(cpy,ap);', 1]
['"--input:  keys: [message_key], values: []\\n"', 1]
['n.table = calloc(realsize,sizeof(dictEntry*));', 1]
["* If NULL is used for 'init' the string is initialized with zero bytes.", 1]
['_hs_tail->next = ((_hs_e) ?                                \\', 1]
['if (strcasecmp(stype+pvariant,"unsubscribe") == 0) {', 1]
['dbg("NEXT MESSAGE KEY NOT PRESENT. ERROR, ERROR!")', 1]
['buf->start = buf->last;', 1]
["if(!(cf->allow_origin.len == 1 && cf->allow_origin.data[0] == '*')) {", 1]
['#define NGX_POOL_PID_SIZE       (NGX_TIME_T_LEN + sizeof("pid:\\n") - 1)     /* sizeof pid_t equals time_t */', 1]
['[:loc_conf, :msg_in_etag_only],', 1]
['hdr_chain->next = &fsub->msg_chain;', 1]
["else if (c >= '0' && c <= '9') {", 1]
['ngx_int_t              i, max, slot;', 1]
['ngx_str_t               event_line = ngx_string("event: %V\\n");', 1]
['/* When the connection is not being disconnected, simply stop', 1]
['#define REDIS_READER_MAX_BUF (1024*16)  /* Default max unused reader buffer. */', 1]
['static void receive_get_message_reply(ngx_int_t sender, getmessage_data_t *d) {', 1]
['head->status = INACTIVE;', 1]
['} tcp;', 1]
['nchan_respond_status(r, NGX_HTTP_INTERNAL_SERVER_ERROR, NULL, 0);', 1]
['used. Together with a pointer to the string, it requires a `size_t` length argument', 1]
['//ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "redis_subscriber_callback,  privdata=%p", privdata);', 1]
['if(msg->next != NULL) {', 1]
['d->getting--;', 1]
['rem=len - ((size_t)(cur-accept)+sizeof("application/")-1);', 1]
['[IPC_UNSUBSCRIBED] =                (ipc_handler_pt )receive_unsubscribed,', 1]
['case 2:  _hj_i += ( (unsigned)_hj_key[1] << 8 );                            \\', 1]
['u_char                  headerbuf[58 + 10*NCHAN_FIXED_MULTITAG_MAX];', 1]
['#if nginx_version < 1003013', 1]
['* The command replied with an integer. The integer value can be accessed using the', 1]
['static dictEntry *dictNext(dictIterator *iter);', 1]
['fsub->dequeue_handler_data = privdata;', 1]
['ngx_shmtx_lock(&SHPOOL(shm)->mutex);', 1]
['bool cmp_write_str_marker(cmp_ctx_t *ctx, uint32_t size);', 1]
['pd->rc = NCHAN_MESSAGE_QUEUED;', 1]
['//redisAsyncCommand(rds_ctx(), &redis_getmessage_callback, (void *)d, "EVALSHA %s 0 %b %i %i %s %i", store_rds_lua_hashes.get_message, STR(d->channel_id), d->msg_id->time, d->msg_id->tag[0], "FILO", create_channel_ttl);', 1]
['static ngx_int_t internal_respond_status(subscriber_t *self, ngx_int_t status_code, const ngx_str_t *status_line) {', 1]
['cl->prev = cl->next = NULL;', 1]
['assert(spl == newspool->spooler);', 1]
['if (sr->variables == NULL) {', 1]
['#define REDIS_REPLY_NIL 4', 1]
['ctx_type = "[Pubsub]";', 1]
['if(memstore_channel_owner(d->shm_chid) != memstore_slot()) {', 1]
['"-- but then error messages become less useful, complicating debugging. If you \\n"', 1]
['ngx_int_t                      use_redis = d->sub->cf->use_redis;', 1]
['else if(nchan_strmatch(val, HTTP_MULTIPART_STRINGS_N, HTTP_MULTIPART_STRINGS)) {', 1]
['if (r->element == NULL) {', 1]
['if (!ctx->read(ctx, &obj->as.s16, sizeof(int16_t))) {', 1]
['#define HASH_JEN(key,keylen,num_bkts,hashv,bkt)                                  \\', 1]
["} else if (*p == '\\'') {", 1]
['sub->fn->notify(sub, NCHAN_SUB_MULTI_NOTIFY_ADDSUB, (void *)-count);', 1]
['buf->file=NULL;', 1]
['rm -rf $(DYLIBNAME) $(STLIBNAME) $(TESTS) examples/hiredis-example* *.o *.gcda *.gcno *.gcov', 1]
['test_cond(redisGetReply(c,&_reply) == REDIS_ERR &&', 1]
['cbuf->file->log=ngx_cycle->log;', 1]
['int fd = disconnect(dummy_ctx, 1);', 1]
['unsigned                        shared:1; //for debugging', 1]
['size_t             len;', 1]
['memstore_ipc_send_subscribe(owner, &head->id, head, &cf);', 1]
['/* This will likely result in an error reply, but it needs to be', 1]
['concurrency = "FIFO";', 1]
['_he_newbkt->hh_head = _he_thh;                                        \\', 1]
['* %s represents a C null terminated string you want to interpolate', 1]
['bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size);', 1]
['* elements already inside the hashtable */', 1]
['DBG("thing %p found in %s %p", thing->data, tc->name, tc);', 1]
['key.message=key.message:format(msg.id)', 1]
['case WEBSOCKET_OPCODE_CLOSE:', 1]
['static void ws_publisher_dequeue_callback(subscriber_t *sub, void *privdata) {', 1]
['#define HASH_FCN HASH_FUNCTION', 1]
['nchan_publisher_body_handler_continued(r->parent, d->ch_id, cf);', 1]
['//ERR("reap msg %p", msg);', 1]
['spool_remove_subscriber(spool, cur);', 1]
['switch((keylen) & 3) {                                               \\', 1]
['#define MAX_FAKE_WORKERS 5', 1]
['void (*valDestructor)(void *privdata, void *obj);', 1]
['ngx_free(pd);', 1]
['* reverse. */', 1]
['id[n_out].len = cur_last - cur_first;', 1]
['return mult*v;', 1]
['nchan_auth_subrequest_data_t   psr_data;', 1]
['prior written permission.', 1]
['fsub->sub.dequeue_after_response = 0;', 1]
['__redisSetError(c,type,buf);', 1]
['//still in HTTP land', 1]
['TESTS=hiredis-test', 1]
['int16_t           val = 0;', 1]
['_mur_h1 = _mur_h1*5+0xe6546b64;                                    \\', 1]
['struct redisAsyncContext; /* need forward declaration of redisAsyncContext */', 1]
['static void receive_get_channel_info_reply(ngx_int_t sender, channel_info_data_t *d) {', 1]
['timer->handler = subscriber_authorize_timer_callback_handler;', 1]
['REAL_LDFLAGS=$(LDFLAGS) $(ARCH)', 1]
['* a quoted string in the same format sdssplitargs() is able to parse.', 1]
['s++; //NEXT!!', 1]
['void                       (*reap)(void *); //reap it', 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_PUBLISH_STATUS, &data, sizeof(data));', 1]
['else if (type_marker == S32_MARKER) {', 1]
['"if msg.time then\\n"', 1]
['//     test("Calls command callback when command is issued: ");', 1]
['bool cmp_read_fixext16(cmp_ctx_t *ctx, int8_t *type, void *data);', 1]
['/* Setup callback */', 1]
['bool cmp_write_s8(cmp_ctx_t *ctx, int8_t c) {', 1]
['dbg("New message id: last_time ", lasttime, " last_tag ", lasttag, " msg_time ", msg.time)', 1]
['* The function returns the allocated tokens on success, even when the', 1]
['//channel actions', 1]
['* Redistributions in binary form must reproduce the above copyright notice,', 1]
['redis_nginx_cleanup(void *privdata)', 1]
['if((tc = ngx_alloc(sizeof(*tc), ngx_cycle->log)) == NULL) {', 1]
['shdata->max_workers = MAX_FAKE_WORKERS;', 1]
['bool cmp_write_map(cmp_ctx_t *ctx, uint32_t size) {', 1]
['ngx_int_t nchan_store_publish_message_generic(ngx_str_t *channel_id, nchan_msg_t *msg, ngx_int_t msg_in_shm, nchan_loc_conf_t *cf, callback_pt callback, void *privdata);', 1]
['ERR("unhandled code %i, %v", status_code, (status_line ? status_line : &empty));', 1]
["--  'subscriber_id' can be '-' for new id, or an existing id", 1]
['#define IPC_UNSUBSCRIBED            4', 1]
['publish randid, data: "this message has an invalid content-type", content_type: "foo:bar", ttl: 10', 1]
['//assert(d->hcln != 0);', 1]
['redisReply **replies;', 1]
['return cmp_read_ulong(ctx, d);', 1]
['typedef bool   (*cmp_reader)(struct cmp_ctx_s *ctx, void *data, size_t limit);', 1]
['test("Works with NULL functions for reply: ");', 1]
['static       subscriber_fn_t  chunked_fn_data;', 1]
['recycloc_llist_s *prealloc_end;', 1]
['nchan_access_control_allow_origin [:main, :srv, :loc],', 1]
['static ngx_int_t nchan_message_id_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) {', 1]
['&longpoll_set_dequeue_callback,', 1]
['ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "unable to create websocket subscriber");', 1]
['unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize;               \\', 1]
['alert->code = code;', 1]
['ngx_atomic_fetch_add(&msg->refcount, -1);', 1]
['struct nchan_msg_s             *dbg_next;', 1]
['hashv += (hashv << 3);                                                         \\', 1]
['static bool read_type_marker(cmp_ctx_t *ctx, uint8_t *marker) {', 1]
['if (hash > node->key) {', 1]
['entry = malloc(sizeof(*entry));', 1]
['* buffer and read all subsequent replies before disconnecting.', 1]
['head->channel.subscribers = head->sub_count - head->internal_sub_count;', 1]
['l.sub! "\\n", "\\\\n"', 1]
['tc->thing_head = NULL;', 1]
['//string will be freed on publish response', 1]
['nchan_msg_status_t          msg_status;', 1]
['typedef enum {', 1]
['sub->fn = multipart_fn;', 1]
['nchan_llist_timed_t *link = ngx_calloc(sizeof(*fakeprocess_top), ngx_cycle->log);', 1]
['bkt = ((hashv) & ((num_bkts) - 1));                                            \\', 1]
['tc->gc_timer.cancelable = 1;', 1]
['// consume message', 1]
['_hs_nmerges++;                                                     \\', 1]
['bool cmp_write_fixext1(cmp_ctx_t *ctx, int8_t type, const void *data);', 1]
['sr->request_body = body;', 1]
['&nchan_store_etag_from_message,', 1]
['if(max->time >= cur->time) {', 1]
['ngx_sha1_final(buf_sha1, &sha1);', 1]
['int redisEnableKeepAlive(redisContext *c) {', 1]
['cf = ngx_http_get_module_loc_conf(r, nchan_module);', 1]
['for( _bkt_i = 0; _bkt_i < (head)->hh.tbl->num_buckets; _bkt_i++) {       \\', 1]
['sub->fn = eventsource_fn;', 1]
['return cmp_write_fixext8_marker(ctx, tp);', 1]
['nchan_store_redis.exit_master(cycle);', 1]
['* See commit log.', 1]
['"\\"last_message_id\\": \\"%V\\" }"', 1]
['if(*last_chain) {', 1]
['nchan_copy_new_msg_id(&spool->id, id);', 1]
['if(!head->latest_msgid.tag.allocd  || !head->oldest_msgid.tag.allocd) {', 1]
['bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size);', 1]
['* The calculation of tbl->ideal_chain_maxlen below deserves some', 1]
['r->rstack[r->ridx].privdata = r->privdata;', 1]
['struct msg_rsv_dbg_s {', 1]
['nchan_message_timeout [:main, :srv, :loc],', 1]
['nchan_request_ctx_t        *ctx;', 1]
['unsigned                        poll:1; //bleugh', 1]
['* element with such key and dictReplace() just performed a value update', 1]
['x = sdscat(x,"bar");', 1]
['current = sdscatlen(current,&c,1);', 1]
['gettimeofday(&tv,NULL);', 1]
['sname = sdsnewlen(astr,alen);', 1]
['lock->mutex=1;', 1]
['bool cmp_object_as_array(cmp_object_t *obj, uint32_t *size) {', 1]
['"    elseif ttl < 0 then\\n"', 1]
['p = ngx_sprintf(p, NGX_POOL_PID_FORMAT, ngx_pid);', 1]
['nchan_channel_event_string [:srv, :loc, :if],', 1]
['((head)->hh.tbl->num_buckets * sizeof(UT_hash_bucket))   +            \\', 1]
['full_subscriber_t          *fsub = (full_subscriber_t *)ctx->sub;', 1]
['* Increase the maximum multi-bulk reply depth to 7.', 1]
['remsg.shared = 0;', 1]
['|     Extended payload length continued, if payload len == 127  |', 1]
['if(r->headers_out.status == NGX_HTTP_OK) {', 1]
['ch.last_published_msg_id.tag.fixed[0] = d->msg_tag;', 1]
['extern const ngx_str_t NCHAN_ALLOW_GET_POST_PUT_DELETE_OPTIONS;', 1]
['nchan_set_msgid_http_response_headers(r, &self->last_msgid);', 1]
['char     *cur;', 1]
['bc[1].chain.next = NULL;', 1]
['len == 4+4+(3+2)+4+(7+2)+4+(3+2));', 1]
['iter->nextEntry = iter->entry->next;', 1]
['/* from push stream module, written by', 1]
['info: "Whether or not message queuing is enabled. \\"Off\\" is equivalent to the setting nchan_channel_buffer_length 0"', 1]
['nchan_channel_id_split_delimiter [:srv, :loc, :if],', 1]
['int type;', 1]
['of the error.', 1]
['frame->payload_len = ntohs(len);', 1]
['#if (NGX_HTTP_V2)', 1]
['ngx_atomic_int_t                refcount;', 1]
['if(chanhead_push_message(chead, shmsg_link) != NGX_OK) {', 1]
['if (__redisShiftCallback(&ac->replies,&cb) != REDIS_OK) {', 1]
['ngx_http_complex_value_t       *authorize_request_url;', 1]
['//nchan_msg_status_t           findmsg_status;', 1]
['ac->onConnect = NULL;', 1]
['char *subscriber_register;', 1]
['strcmp(c->errstr,"Can\'t resolve: idontexist.local") == 0 ||', 1]
['unsigned _ha_bkt;                                                               \\', 1]
['hashv = hashv ^ _hf_key[_fn_i];                                            \\', 1]
['/* Format a command according to the Redis protocol. This function takes the', 1]
['ngx_str_t     msg_type;', 1]
['} get_multi_message_data_t;', 1]
['sh->free = totlen-len;', 1]
['DBG("No subscribers lately. Time... to die.");', 1]
['if(nchan_content_length_hash == 0) {', 1]
['*first_chain = &bc[0].chain;', 1]
['} nchan_worker_msg_sentinel_t;', 1]
['HASH_DELETE(hh,head,replaced);                                              \\', 1]
['static void redisLibuvPoll(uv_poll_t* handle, int status, int events) {', 1]
["case '$':", 1]
['ERR("Unexpected spool == nuspool during spool fetch_msg_callback. This is weird, please report this to the developers. findmsg_status: %i", findmsg_status);', 1]
['head->msg_first = NULL;', 1]
['if(rdt.chanhead_cleanup_tail != NULL) {', 1]
['full_subscriber_t           *fsub;', 1]
['mbuf = m->buf;', 1]
['static void *createIntegerObject(const redisReadTask *task, long long value);', 1]
['return content_type;', 1]
['unsigned                   enqueued:1;', 1]
["* ceil(n/b). We don't depend on floating point arithmetic in this", 1]
['//quit', 1]
['nchan_store_channel_head_t   *chanhead;', 1]
['bc[1].chain.buf=&bc[1].buf;', 1]
['/* Flag that is set when monitor mode is active */', 1]
['valid = 0;', 1]
['static ngx_int_t sub_respond_message(ngx_int_t status, nchan_msg_t *msg, sub_data_t* d) {', 1]
['} else if (config.type == CONN_FD) {', 1]
['* Reads a floating point value (either single or double-precision) from the', 1]
['init_mpt(mpt);', 1]
['if(head->slot == owner) {', 1]
['} else if (c->err) {', 1]
['static void *createArrayObject(const redisReadTask *task, int elements) {', 1]
['assert(ch->msg_first == NULL);', 1]
['/* Public API for the protocol parser. */', 1]
['nchan_max_channel_id_length [:main, :srv, :loc],', 1]
['out=[]', 1]
['errno = err;', 1]
['/* Try with IPv6 if no IPv4 address was found. We do it in this order since', 1]
['nchan_loc_conf_t              cf;', 1]
['if(ch->msg_last == msg) {', 1]
['/* Set the sds string length to the length as obtained with strlen(), so', 1]
['static dict *dictCreate(dictType *type, void *privDataPtr) {', 1]
['#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,out)                       \\', 1]
['return cmp_write_ext32(ctx, tp, sz, data);', 1]
['{ ngx_string("push_subscriber_concurrency"),', 1]
['//what do we need to fetch?', 1]
['if ((str_size + 1) > buf_size) {', 1]
['args: 0..2,', 1]
['len = redisFormatCommand(&cmd,"key:%08.3f str:%s", value, "hello");                   \\', 1]
['chan.id.data = d->shm_chid->data;', 1]
['sent << publish(Msg.new(id, data: "fie", ttl: 3))', 1]
['test("Set error on nested multi bulks with depth > 7: ");', 1]
['fsub->ping_ev.data = fsub;', 1]
['size_t    delim_sz = sub->len;', 1]
['assert(rp->count == 0 && rp->last == NULL);', 1]
['const char       *name;', 1]
['Note that this function will take care of freeing sub-replies objects', 1]
['ERR("invalid msg time from redis");', 1]
["cur[0]='m';", 1]
['redisContext *redisConnectUnixNonBlock(const char *path) {', 1]
['nchan_memstore_handle_get_message_reply(d->d.resp.shm_msg, d->d.resp.getmsg_code, d->privdata);', 1]
['bool cmp_object_is_short(cmp_object_t *obj);', 1]
['obj->as.str_size = be32(obj->as.u32);', 1]
["redis.call('HSET', key.channel, 'prev_message', msg.prev)", 1]
['frame->rsv2 = (frame->header[0] >> 5) & 1;', 1]
['* When no set of reply functions is given, the default set will be used. */', 1]
['d->msg_status = MSG_PENDING;', 1]
['sts = "WAITING";', 1]
['if( i != -1) {', 1]
['scripts={}', 1]
['data.shm_msg = shm_msg;', 1]
['"  redis.call(\'setex\', \\"channel:deleted:\\"..id, 5, 1)\\n"', 1]
['if (!write_type_marker(ctx, STR16_MARKER))', 1]
['//ngx_log_error(NGX_LOG_ERR, log, 0, "opening invalid file at %s", file->name.data);', 1]
['nchan_store_messages [:main, :srv, :loc, :if],', 1]
['void sdstolower(sds s) {', 1]
['msg->content_type = *content_type;', 1]
['return cmp_write_fixext2_marker(ctx, tp);', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS_REPLY_NIL: nil");', 1]
['spl->want_to_stop = 1;', 1]
['ngx_log_error(NGX_LOG_ERR, log, err, "nchan IPC: read() failed");', 1]
['spooler_respond_generic_data_t  *d = data;', 1]
['#define HASH_REPLACE_INT(head,intfield,add,replaced)                             \\', 1]
['/* Find out which command will be appended. */', 1]
['* Write a formatted command to the output buffer. When this family', 1]
["local msg=tohash(redis.call('HGETALL', key.message))", 1]
['struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */', 1]
['if (connection == NULL) {', 1]
['* sdssplit("foo_-_bar","_-_"); will return two', 1]
['File.write path, out', 1]
['publish_callback_data         cd_data;', 1]
['next = fakeprocess_top->next;', 1]
["//no qvalue. assume non-zero, meaning it's legit", 1]
['static char *nchan_set_complex_value_array(ngx_conf_t *cf, ngx_command_t *cmd, void *conf, nchan_complex_value_arr_t *chid) {', 1]
['struct event_base *base = event_base_new();', 1]
["/* Append to the sds string 's' a string obtained using printf-alike format", 1]
['char * (*names)[]=(char* (*)[])&store_rds_lua_script_names;', 1]
['if(proc->active) {', 1]
['cur += 8;', 1]
['ngx_int_t                   i, n = idcf->n, n_out = 0;', 1]
['obj->type = CMP_TYPE_SINT8;', 1]
['/* Set a key using binary safe API */', 1]
['cur += grouplen;', 1]
['c->read->handler = NULL;', 1]
['#define REDIS_LUA_HASH_LENGTH %i', 1]
['///port:host', 1]
['//     test_cond(__test_callback_flags == 0x010203);', 1]
['test("Can parse integer replies: ");', 1]
['if((node = rbtree_find_node(seed, id)) == NULL) {', 1]
['nchan_copy_msg_id(&retmsg.prev_id, &d->wanted_msgid, multi_prevlargetag);', 1]
['its_reaping_time_keep_place(rp, 0);', 1]
['/* Return ASAP when an error occurred. */', 1]
['"chanhead",', 1]
['Redis version >= 1.2.0.', 1]
['unsigned _bkt_i;                                                             \\', 1]
['&websocket_reserve,', 1]
['if(conf->publisher_upstream_request_url == NULL) {', 1]
['ngx_uint_t step;', 1]
['#define rbtree_node_from_data(data) (ngx_rbtree_node_t *)((u_char *)data - sizeof(ngx_rbtree_node_t))', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: unable to allocate memory for Etag header");', 1]
['bool cmp_write_bin32_marker(cmp_ctx_t *ctx, uint32_t size);', 1]
['static int intlen(int i) {', 1]
['// Thanks, agenzh!', 1]
['if((smsg = create_shared_message(cur, 1)) == NULL) {', 1]
['return cmp_write_map16(ctx, size);', 1]
['ac->err = c->err;', 1]
['ngx_str_t *nchan_get_header_value(ngx_http_request_t * r, ngx_str_t header_name);', 1]
['### Sending commands and their callbacks', 1]
['static ngx_int_t longpoll_respond_message(subscriber_t *self, nchan_msg_t *msg) {', 1]
['/*.o', 1]
['else if(msg->eventsource_event.len > 0) {', 1]
['/*.a', 1]
['if (c != NULL && c->err) {', 1]
['if scripts.count > 0', 1]
['char* (*hashes)[]=(char* (*)[])&store_rds_lua_hashes;', 1]
['ctx->request_origin_header = *origin_header;', 1]
['if(sub->type != INTERNAL && publish_events) {', 1]
['ngx_destroy_pool(pool);', 1]
['chan_info->subscribers = chan->subscribers;', 1]
["cur[-1]='\\0';", 1]
['ERR("REDIS: PUB/SUB really unexpected chanhead status %i", chanhead->status);', 1]
['assert(fsub->sub.enqueued == 0);', 1]
['ngx_log_error(NGX_LOG_ERR, log, 0, "nchan: can\'t create output chain, can\'t allocate buffer copy in pool");', 1]
['n = read(s, alert, sizeof(ipc_alert_t));', 1]
['fsub->data.dequeue_handler = cb;', 1]
['static nchan_store_channel_head_t * nchan_store_get_chanhead(ngx_str_t *channel_id);', 1]
['nchan_reaper_start(&m->nobuffer_msg_reaper,', 1]
['full_subscriber_t         *fsub = (full_subscriber_t *)self;', 1]
['if(status_code == NGX_HTTP_GONE) {', 1]
['msgtag_str.len = l1 + l2;', 1]
['return {404, "", "", "", "", subs_count}', 1]
['//port', 1]
['fsub->sub.request->read_event_handler = ngx_http_test_reading;', 1]
['[:loc_conf, :publisher_upstream_request_url],', 1]
['if(!ctx->multipart_boundary) {', 1]
['bc[0].buf.pos = headerbuf;', 1]
['static ngx_int_t spooler_prepare_to_stop(channel_spooler_t *spl) {', 1]
['//delete a multichannel', 1]
['p = strstr(reply->str,field);', 1]
['"[#{@chid}]#{id}<#{@content_type}> #{@data}"', 1]
['unsigned _sx_i;                                                                \\', 1]
['"--input:  keys: [], values: [channel_id, status_code]\\n"', 1]
['if (c) {', 1]
['bool cmp_object_is_str(cmp_object_t *obj);', 1]
['hashv    += hashv >> 11;                                                     \\', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "REDIS_REPLY_ARRAY: %i", reply->elements);', 1]
['out.join "\\n"', 1]
['redisReply         **els = r->element;', 1]
['static void spooler_dequeue_handler(channel_spooler_t *spl, subscriber_t *sub, void *privdata) {', 1]
['//copypasta from os/unix/ngx_process.c (ngx_spawn_process)', 1]
['sdslen(y) == 2 && memcmp(y,"ao\\0",3) == 0)', 1]
['DBG("chanhead gc queue looks empty, stop gc_queue handler");', 1]
['assert(head->foreign_owner_ipc_sub == d->ipc_sub);', 1]
['ngx_memzero(blob, sizeof(*blob));', 1]
['#define DBG(...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, __VA_ARGS__)', 1]
['sh->len += incr;', 1]
['normal Redis context, the redisReader structure uses a buffer in order to', 1]
['ngx_int_t                       internal_sub_count;', 1]
['"if no_msgid_order ~= \'FIFO\' then\\n"', 1]
['nchan_longpoll_multimsg_t *multimsg_first;', 1]
['r->headers_out.content_length_n = body->len;', 1]
['anymsg.tag.fixed[0] = 0;', 1]
['//DBG("looked everywhere, not found");', 1]
['void subscriber_debug_remove(subscriber_t *);', 1]
['if (!ctx->read(ctx, &obj->as.flt, sizeof(float))) {', 1]
['ngx_http_request_t *r = fsub->sub.request;', 1]
['prevde = NULL;', 1]
['double_newline_buf.last = double_newline_buf.end;', 1]
['unsigned                        meta:1;', 1]
['offsetof(nchan_main_conf_t, redis_url),', 1]
['d->owner = memstore_slot();', 1]
['* Usage example:', 1]
['fsub->holding = 1;', 1]
['nchan_msg_id_t        id = {0,0};', 1]
['#define EVENTSOURCE_STRINGS "eventsource", "event-source", "es", "sse"', 1]
['static char *nextArgument(char *start, char **str, size_t *len) {', 1]
['prev = sub->dbg_prev;', 1]
['if(memstore_multi_subscriber_create(head, i) == NULL) { //stores and enqueues automatically', 1]
['l1 = sprintf(msgtag_str_buf, "%li:", id->time);', 1]
['static void nchan_flush_pending_output(ngx_http_request_t *r) {', 1]
['* This function is used in order to fix the string length after the', 1]
['nchan_store_t                  *storage_engine;', 1]
['ERR("unable to allocate chan_info");', 1]
['nchan_msg_buf_open_fd_if_needed(msg_buf, &fsub->msg_file, NULL);', 1]
['"Specified string data length is too long (> 0xFFFFFFFF)",', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:MEM-REDIS:" fmt, ##arg)', 1]
['have been written to the socket, their respective replies have been read and their respective', 1]
['nchan_store_channel_head_t  *target_ch;', 1]
['return cmp_write_s32(ctx, (int32_t) d);', 1]
['* (the extent to which this is true is a measure of the quality of', 1]
['int redisGetReplyFromReader(redisContext *c, void **reply);', 1]
['nchan_request_ctx_t *ctx = ngx_http_get_module_ctx(r, nchan_module);', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "nchan_shpool start %p size %i", shpool->start, (u_char *)shpool->end - (u_char *)shpool->start);', 1]
['valid for the duration of the callback.', 1]
['if(unprevid.tag[i] == -1) msg->prev_id.tag[i] = self->id.tag[i];', 1]
['conf->channel_events_channel_id = prev->channel_events_channel_id;', 1]
['ngx_int_t     n = d->n;', 1]
['nchan_msg_t       *msg;', 1]
['d->originator = originator_slot;', 1]
['channel_spooler_t   *spooler;', 1]
['def test_delete', 1]
['ngx_int_t            rbtree_walk(rbtree_seed_t *seed, rbtree_walk_callback_pt, void *data);', 1]
['#define IPC_DELETE                  11', 1]
['first = fsub->data.multimsg_first;', 1]
['connection->read->log = connection->log;', 1]
['if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {', 1]
['After trying to connect to Redis using `redisConnect` you should', 1]
['glob->timer.data = glob;', 1]
['#define REDIS_LUA_HASH_LENGTH 40', 1]
["local channel_pubsub = 'channel:pubsub:'..id", 1]
['* this context, the status will always be REDIS_OK. */', 1]
['ngx_chain_t           *chains, *first_chain = NULL, *last_chain = NULL;', 1]
['/* check if we need to read type */', 1]
['bool cmp_object_as_float(cmp_object_t *obj, float *f) {', 1]
['{ ngx_string("nchan_store_messages"),', 1]
['if (hh_del->hh_next) {                                                       \\', 1]
['//message queue', 1]
['if (len < 0) {', 1]
['u_char                           subscriber_id[255];', 1]
['if(msg && msg->prev_id.time > 0 && msg->id.tagcount > 1) {', 1]
['ngx_int_t chanhead_gc_withdraw(nchan_store_channel_head_t *chanhead, const char *);', 1]
['static void init_msg_buf(ngx_buf_t *buf) {', 1]
['ipc = &ipc_data;', 1]
['static const subscriber_fn_t websocket_fn = {', 1]
['if(i==last) { //sent all outstanding alerts', 1]
['if(id->len > (unsigned )cf->max_channel_id_length) {', 1]
['DBG("received SUBSCRIBER KEEPALIVE from %i for channel %V", sender, d->shm_chid);', 1]
['--write message', 1]
['char                      *concurrency = NULL;', 1]
['ngx_int_t qval_fp;', 1]
['wb->overflow_last = overflow;', 1]
['INTEGER_WIDTH_TEST("d", int);', 1]
['//uint8_t publish_events = self->spooler->publish_events;', 1]
['struct redisReadTask *parent; /* parent task */', 1]
['ngx_http_request_t              *pr;', 1]
['"redis.call(\'echo\', table.concat(arg))\\n"', 1]
['close_msg = &custom_close_msg;', 1]
['fsub->data.cln->data = fsub;', 1]
["cur = redis.call('HINCRBY', chan_key, 'fake_subscribers', num)", 1]
['struct channel_spooler_s   *spooler;', 1]
['require "pry"', 1]
['tokens[elements] = sdsnewlen(s+start,len-start);', 1]
['/* expand_mult is normally set to 0. In this situation, the max chain length', 1]
['legacy: "push_channel_group",', 1]
['case KEEP_PLACE:', 1]
['test_cond("Strings concatenation",', 1]
['connection->write->handler = redis_nginx_write_event;', 1]
['if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)', 1]
['if(!last_msgid) {', 1]
['if (obj.type != CMP_TYPE_FIXEXT1) {', 1]
['__redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));', 1]
['redis_nginx_select_callback(redisAsyncContext *ac, void *rep, void *privdata)', 1]
['nchan_store_channel_head_t     *head;', 1]
['nchan_pub_subrequest_data_t   psr_data;', 1]
['obj = r->fn->createArray(cur,elements);', 1]
['redis.call(\'setex\', "channel:deleted:"..id, 5, 1)', 1]
['cb = ngx_palloc(r->pool, sizeof(*cb));', 1]
['}; //ipc_writebuf_t', 1]
['} else if (config.type == CONN_UNIX) {', 1]
['time_t               last_seen = 0;', 1]
['//subscriber_register', 1]
['ngx_str_t               *shm_chid;', 1]
['void memstore_fakeprocess_pop(void);', 1]
['if channel~=nil then', 1]
['&websocket_respond_message,', 1]
['case \'\\a\': s = sdscatlen(s,"\\\\a",2); break;', 1]
['va_arg(ap,double);', 1]
['msg->temp_allocd = 0;', 1]
['ngx_uint_t                    id; //could be useful later', 1]
['size_t   sz = src->len;', 1]
['ngx_int_t (*find_channel)(ngx_str_t *, callback_pt, void*);', 1]
['msg->lbl = r->uri;', 1]
['rv = REDIS_ERR;', 1]
['2 * tbl->num_buckets * sizeof(struct UT_hash_bucket));               \\', 1]
['printf("PING: %s\\n", reply->str);', 1]
['_EL_CLEANUP(ac);', 1]
['ngx_int_t               count = 0;', 1]
['cbuf->file->name.data=(u_char *) (cbuf->file+1);', 1]
['*u = obj->as.u8;', 1]
['/* Always re-schedule reads */', 1]
['void           *pd;', 1]
['if(id->tagcount > NCHAN_FIXED_MULTITAG_MAX) {', 1]
['rc = nchan_store_redis.publish(&chead->id, publish_msg, cf, callback, privdata);', 1]
['if (redisCheckSocketError(c) == REDIS_ERR) {', 1]
['--replace subscribers count with fake_subscribers', 1]
['ngx_int_t                    owner;', 1]
['while (_hs_p) {                                                        \\', 1]
['hashv ^= hashv << 16;                                                \\', 1]
['#include <subscribers/memstore_multi.h>', 1]
['// cur += es_event_len;', 1]
['if((mmsg = ngx_palloc(fsub->sub.request->pool, sizeof(*mmsg))) == NULL) {', 1]
['NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3|NGX_CONF_TAKE4|NGX_CONF_TAKE5|NGX_CONF_TAKE6,', 1]
['ac->onDisconnect = NULL;', 1]
['d->privdata=privdata;', 1]
['content_type = NULL;', 1]
['ngx_int_t                   rc;', 1]
['local num_messages = 0', 1]
['tags2 = id2->tag.fixed;', 1]
['* MessagePack libraries.  No encoding is assumed in this case, not that it', 1]
['* string, -2 the penultimate character, and so forth.', 1]
['ngx_int_t nchan_memstore_publish_generic(nchan_store_channel_head_t *head, nchan_msg_t *msg, ngx_int_t status_code, const ngx_str_t *status_line);', 1]
['if(CHECK_REPLY_ARRAY_MIN_SIZE(reply, 3)', 1]
['//message actions and properties', 1]
['buf = ngx_create_temp_buf(pool, content_length + 1);', 1]
['if (r->buf == NULL) {', 1]
['static ngx_str_t         nopublishing = ngx_string("Publishing not allowed.");', 1]
['if (cur==NULL) { //we went all the way to the end', 1]
["redis.call('PUBLISH', channel_pubsub, pubmsg)", 1]
['*generated_content_type = &channel_info_content_type;', 1]
['dbg("channel.mas_stored_messages == " , channel.max_stored_messages)', 1]
['ngx_conf_merge_value(conf->max_messages, prev->max_messages, NCHAN_DEFAULT_MAX_MESSAGES);', 1]
['spl->store = store;', 1]
['ngx_int_t nchan_copy_msg_id(nchan_msg_id_t *dst, nchan_msg_id_t *src, int16_t *largetags);', 1]
['value = &((ngx_str_t *) cf->args->elts)[i];', 1]
['val = 3;', 1]
['return cmp_write_ext8(ctx, tp, sz, data);', 1]
['ERR("Error regarding an aspect of life or maybe freshly fallen cookie crumbles");', 1]
['test("Error handling in reply parser: ");', 1]
['extern const ngx_str_t NCHAN_ACCESS_CONTROL_ALLOWED_SUBSCRIBER_HEADERS;', 1]
['static void websocket_reading(ngx_http_request_t *r) {', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "No memory for sdata. Part IV, subparagraph 12 of the Cryptic Error Series.");', 1]
['else if (type_marker == FIXEXT4_MARKER) {', 1]
['(add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);         \\', 1]
['old_largetags = oldid->tag.allocd;', 1]
['#include <netdb.h>', 1]
['ngx_memcpy(&alert->data, data, data_size);', 1]
['ngx_int_t nchan_store_chanhead_publish_message_generic(nchan_store_channel_head_t *chead, nchan_msg_t *msg, ngx_int_t msg_in_shm, nchan_loc_conf_t *cf, callback_pt callback, void *privdata);', 1]
['/* Clear input buffer on errors. */', 1]
['if(dequeue_subscribers) {', 1]
['glob->timer.handler = fake_ipc_alert_delay_handler;', 1]
['elsif Msg === msg', 1]
['r->cleanup = d->original_cleanup;', 1]
['n=sent.shift', 1]
['(head)->hh.tbl->num_items--;                                             \\', 1]
['bool cmp_object_as_sinteger(cmp_object_t *obj, int64_t *d);', 1]
['uint32_t  u32;', 1]
['ngx_buf_t               msg_buf; //assumes single-buffer messages', 1]
['else if (type_marker == ARRAY32_MARKER) {', 1]
['sdata->chanhead = chanhead;', 1]
['static void redis_subscriber_register_callback(redisAsyncContext *c, void *vr, void *privdata);', 1]
['* specifier.', 1]
['if msg then', 1]
['if(id->time == -1) {', 1]
['static int processItem(redisReader *r) {', 1]
['"      --we await a message\\n"', 1]
['ngx_http_post_subrequest_t     psr;', 1]
['chanhead_churner_withdraw(ch);', 1]
['data.max_msgs = cf->max_messages;', 1]
['/* Helper functions to push/shift callbacks */', 1]
['spool_fetch_msg(spool);', 1]
['"--write message\\n"', 1]
['return version;', 1]
['return last_char;', 1]
['psr_stuff->psr_data.tmp_pool = NULL;', 1]
['static int8_t compare_msgid_time(nchan_msg_id_t *min, nchan_msg_id_t *max, nchan_msg_id_t *cur) {', 1]
['cb.fn = fn;', 1]
["} else if (*p == '\\\\' && *(p+1)) {", 1]
['multipart_fn = &multipart_fn_data;', 1]
['out = shm_copy_immutable_string(nchan_memstore_get_shm(), str);', 1]
['UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL;                         \\', 1]
['redis_get_message_data_t  *d= (redis_get_message_data_t *)privdata;', 1]
['static subscriber_pool_t *find_spool(channel_spooler_t *spl, nchan_msg_id_t *id) {', 1]
['//         redisBufferWrite(c,&wdone);', 1]
['sub = nsub->sub;', 1]
['if (redisReaderGetReply(c->reader,reply) == REDIS_ERR) {', 1]
['if (c->flags & REDIS_DISCONNECTING && sdslen(c->obuf) == 0) {', 1]
['test_cond(reply->type == REDIS_REPLY_NIL)', 1]
['typedef struct UT_hash_handle {', 1]
['ret = memstore_ipc_send_unsubscribed(d->originator, d->chid, NULL);', 1]
['redis_nginx_event_attach(redisAsyncContext *ac)', 1]
['"  local stored_messages = tonumber(redis.call(\'LLEN\', key.messages))\\n"', 1]
['////////// GET MESSAGE ////////////////', 1]
['} ipc_alert_t;', 1]
['test("Don\'t reset state after protocol error: ");', 1]
['wfd[0].events = POLLOUT;', 1]
['redis_get_message_from_key_data_t *d = (redis_get_message_from_key_data_t *)privdata;', 1]
['fsub->data.timeout_ev.log = ngx_cycle->log;', 1]
['test("Can parse nil replies: ");', 1]
['DBG("shm: %p, shdata: %p", shm, shdata);', 1]
["case 'f': case 'F': return 15;", 1]
['ngx_conf_merge_bitmask_value(conf->pub.http, prev->pub.http, 0);', 1]
['{ ngx_string("nchan_max_reserved_memory"),', 1]
['static const subscriber_fn_t internal_sub_fn = {', 1]
['fsub->msg_chain.next = NULL;', 1]
['DBG("received subscribe reply for channel %V", d->shm_chid);', 1]
['bool cmp_read_fixext2(cmp_ctx_t *ctx, int8_t *type, void *data);', 1]
['n.sizemask = realsize-1;', 1]
['if (!write_type_marker(ctx, S64_MARKER))', 1]
['The reply parsing API consists of the following functions:', 1]
['return write_fixed_value(ctx, FIXSTR_MARKER | size);', 1]
['e.pos = value->data;', 1]
['//find channel', 1]
['if(fsub->holding == 0) {', 1]
['uint32_t bloom_sig; /* used only to test bloom exists in external analysis */', 1]
['static void receive_publish_message_reply(ngx_int_t sender, publish_response_data *d) {', 1]
['return key;', 1]
['"publish",', 1]
['assert(!ch->in_gc_queue);', 1]
['static ngx_int_t chanhead_delete_message(nchan_store_channel_head_t *ch, store_message_t *msg);', 1]
['static void get_msg_from_msgkey_callback(redisAsyncContext *c, void *r, void *privdata) {', 1]
['tags_oldest = head->oldest_msgid.tag.fixed;', 1]
['* as this would add latency to every connect. Otherwise a more sensible', 1]
['DECLTYPE_ASSIGN(head,ELMT_FROM_HH((head)->hh.tbl, _hs_list));      \\', 1]
['unsigned                        in_churn_queue:1;', 1]
['static ngx_int_t chanhead_messages_gc_custom(nchan_store_channel_head_t *ch, ngx_int_t max_messages) {', 1]
['sent.each do |m|', 1]
['int               ttl = msg->expires - msg->id.time;', 1]
['if((rc = nchan_respond_msg(r, msg, &self->last_msgid, 0, &err)) != NGX_OK) {', 1]
['return ch', 1]
['static int processLineItem(redisReader *r) {', 1]
['bool cmp_object_is_uchar(cmp_object_t *obj);', 1]
['ngx_str_t        *content_type = NULL;', 1]
['if(msgid == NULL || (msgid->time < first->msg->id.time || (msgid->time == first->msg->id.time && msgid->tag.fixed[0] < first->msg->id.tag.fixed[0])) ) {', 1]
['lcf->channel_timeout=NGX_CONF_UNSET;', 1]
['creating the context.', 1]
['r = createReplyObject(task->type);', 1]
['ngx_init_set_membuf(&bc->buf, terminal_newlines.data, terminal_newlines.data + terminal_newlines.len);', 1]
['exit 1 unless system "luac -p #{f}"', 1]
['callback_pt             enqueue;', 1]
['HASH_FIND(hh,head,findstr,strlen(findstr),out)', 1]
['//delete', 1]
['head->generation = 0;', 1]
['strcmp(reply->str,"hello world") == 0);', 1]
['{ ngx_string("nchan_eventsource_event"),', 1]
['ngx_chain_t                    *out;', 1]
['init_msg_buf(fakebody_buf);', 1]
['d->sub->dequeue(d->sub);', 1]
['buf.pos = evstr.data;', 1]
['ngx_str_t            *val = &((ngx_str_t *) cf->args->elts)[1];', 1]
['* width is correctly determined using the format and subsequent varargs', 1]
['v->not_found = 0;', 1]
['websocket_send_close_frame(fsub, close_code, close_msg);', 1]
['* matters.', 1]
['//nchan_request_ctx_t      *ctx = ngx_http_get_module_ctx(fsub->sub.request, nchan_module);', 1]
['/* the size is invalid if it is smaller than the number of', 1]
['"  tag= 0\\n"', 1]
['bool cmp_write_double(cmp_ctx_t *ctx, double d) {', 1]
['sleep 2', 1]
['slot = i;', 1]
['{ ngx_string("push_channel_timeout"), //legacy for nchan_channel_timeout', 1]
['tmp_etag = msgtag_to_str(msgid);', 1]
['uv_close((uv_handle_t*)&p->handle, on_close);', 1]
['for((el)=(head), (*(char**)(&(tmp)))=(char*)((head)?(head)->hh.next:NULL);       \\', 1]
['bool cmp_write_ext8(cmp_ctx_t *ctx, int8_t type, uint8_t size,', 1]
['"  msg = redis.call(\'LPOP\', messages)\\n"', 1]
['ngx_free(sd);', 1]
['@@hashes[name]=h', 1]
['ngx_int_t    i, max, inserted = 0;', 1]
['static ngx_int_t websocket_publish_callback(ngx_int_t status, nchan_channel_t *ch, full_subscriber_t *fsub) {', 1]
['str.len = ngx_buf_size(body);', 1]
['newbuf = sdscatlen(c->obuf,cmd,len);', 1]
['nchan_copy_msg_id(&chead->latest_msgid, &publish_msg->id, NULL);', 1]
["dec = c - '0';", 1]
['/* "Reads" (more like "skips") a NULL value from the backend */', 1]
['void cmp_init(cmp_ctx_t *ctx, void *buf, cmp_reader read, cmp_writer write);', 1]
['test("Format command by passing argc/argv with lengths: ");', 1]
['{ "yaml"  , 4, &NCHAN_CHANNEL_INFO_YAML },', 1]
['* connectivity. */', 1]
['delayed_alert_glob_t *glob = (delayed_alert_glob_t *)ev->data;', 1]
['va_arg(ap,int); /* char gets promoted to int */', 1]
['new_channel=false', 1]
['hashv ^= hashv << 25;                                                        \\', 1]
["found_msg_id=oldestmsg(key.messages, ('channel:msg:%s:'..id))", 1]
["r->headers_out.status_line = everything_ok; //but in reality, we're returning a 200 OK", 1]
['int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;', 1]
['"    \\n"', 1]
['DATA_WRITING_ERROR,', 1]
['assert(i == rp->count);', 1]
['//     while(__test_callback_flags == 0) {', 1]
['ngx_http_subrequest(r, &publisher_upstream_request_url, NULL, &sr, psr, NGX_HTTP_SUBREQUEST_IN_MEMORY);', 1]
['time_t            t1 = id1->time;', 1]
['if((sub_link = nchan_ws_llist_enqueue(sub)) == NULL) {', 1]
['nchan_add_response_header(r, &transfer_encoding_header, &transfer_encoding);', 1]
['createArrayObject,', 1]
['INSTALL_INCLUDE_PATH= $(PREFIX)/include/hiredis', 1]
['fsub->sub.enqueued = 1;', 1]
['DBG("Nobody wants this message we\'ll need to grab with an HMGET");', 1]
['nchan_complex_value_arr_t       sub_chid;', 1]
['rp->timer.log = ngx_cycle->log;', 1]
['if (start < 0) start = 0;', 1]
['ngx_memcpy(&databuf, msg_buf, sizeof(*msg_buf));', 1]
['ARRAY16_MARKER         = 0xDC,', 1]
['if(callback) {', 1]
['head->spooler.fn->set_bulk_post_subscribe_handler(&head->spooler, spooler_bulk_post_subscribe_handler, head);', 1]
['*max=0;', 1]
['"Error writing type marker",', 1]
['if(last_link) {', 1]
['redisCheckErrorCallback(c, r, privdata);', 1]
['if(mcf == NULL) {', 1]
['ngx_msec_t                   t;', 1]
['static void receive_subscribe(ngx_int_t sender, subscribe_data_t *d) {', 1]
['if (obj.type != CMP_TYPE_FIXEXT16) {', 1]
['default: "memory",', 1]
['n = parse_multi_id(chid, ids);', 1]
['for(i=0; i<(sizeof(subtypes)/sizeof(nchan_content_subtype_t)); i++) {', 1]
['* 4) The implicit null term.', 1]
['bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj);', 1]
['if(ipc_write_alert_fd(fd, &alerts[i % IPC_WRITEBUF_SIZE]) != NGX_OK) {', 1]
['stop_spooler(&ch->spooler, 0);', 1]
['#include <fcntl.h>', 1]
['lcf->storage_engine = &nchan_store_redis;', 1]
['if (errno == EINPROGRESS) {', 1]
['while sent.length>0', 1]
['"  local lasttime, lasttag = tonumber(lastmsg[1]), tonumber(lastmsg[2])\\n"', 1]
['if msg.time then', 1]
['//DBG("create %V %V", msgid_to_str(&msg->msg->id), chanhead_msg_to_str(msg));', 1]
['} getmessage_blob_t;', 1]
['static void _dictReset(dict *ht) {', 1]
['offsetof(nchan_loc_conf_t, use_redis),', 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_GET_CHANNEL_INFO, &data, sizeof(data));', 1]
['msg.prev_tag = lasttag', 1]
['ipc_write_handler(proc->c->write);', 1]
['if((largetags = ngx_alloc(sizeof(*largetags) * src_n, ngx_cycle->log)) == NULL) {', 1]
['*prev = rp->last;', 1]
['bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj) {', 1]
['ngx_http_complex_value_t       *publisher_upstream_request_url_ccv;', 1]
['memcmp(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\0",33) == 0)', 1]
['DBG("inserted node %p", node);', 1]
['static ngx_int_t nchan_store_subscribe_sub_reserved_check(ngx_int_t channel_status, void* _, subscribe_data_t *d) {', 1]
['((UT_hash_handle*)((ptrdiff_t)((delptr)->hh.prev) +                  \\', 1]
['timer->data = data;', 1]
['unsigned                     allocd:1;', 1]
['else if(ngx_strmatch(&msg_type, "alert") && array_sz > 1) {', 1]
['if (newlen != 0) {', 1]
['(tbl)->bloom_bv = (uint8_t*)uthash_malloc(HASH_BLOOM_BYTELEN);                 \\', 1]
['assert(spool->spooler->running);', 1]
['alert.src_slot = memstore_slot();', 1]
['//main config', 1]
['static ngx_int_t chanhead_gc_withdraw(nchan_store_channel_head_t *chanhead) {', 1]
['/* Writes false to the backend */', 1]
['d->callback(NGX_ERROR, NULL, d->privdata);', 1]
['if (strchr("eEfFgGaA",*_p) != NULL) {', 1]
['head->internal_sub_count--;', 1]
['bool cmp_object_as_bin(cmp_object_t *obj, uint32_t *size);', 1]
['(void (*)(void *)) memstore_reap_churned_chanhead,', 1]
['default: return 0;', 1]
['/* Set monitor flag and push callback */', 1]
['for(cur = rp->first; cur != NULL; cur = thing_next(rp, cur)) {', 1]
['(head)->hh.tbl->buckets[_bkt_i].count, _bkt_count);              \\', 1]
['str.data = buf->start;', 1]
['hashv += hashv >> 11;                                                \\', 1]
['if (u <= 0xFF)', 1]
['ctx->channel_event_name = &evt_chan_delete;', 1]
['hiredis-example-libuv:', 1]
['psrd->cln->handler = (ngx_http_cleanup_pt )sudden_upstream_request_abort_handler;', 1]
['ngx_free(sub->lbl);', 1]
['u_char opcode:4;', 1]
['ngx_memcpy(&r->headers_out.status_line, &ACCEPTED_LINE, sizeof(ngx_str_t));', 1]
['#define IPC_GET_MESSAGE             9', 1]
['if (c <= 0x7F)', 1]
['nchan_llist_timed_t             *chanhead_cleanup_tail;', 1]
['bool cmp_write_sfix(cmp_ctx_t *ctx, int8_t c) {', 1]
['ngx_int_t nchan_detect_eventsource_request(ngx_http_request_t *r);', 1]
['*thing_prev_ptr(rp, thing) = NULL;', 1]
['all: $(DYLIBNAME)', 1]
['redisLibuvEvents* p = (redisLibuvEvents*)malloc(sizeof(*p));', 1]
['int redisBufferRead(redisContext *c);', 1]
['DBG("%p respond req %p msg %p", self, r, msg);', 1]
['size_t curlen = sdslen(s);', 1]
['current = sdscatlen(current,(char*)&byte,1);', 1]
['typedef struct redisReply {', 1]
['//#define SUB_FAKE_WORKER 1', 1]
['r->err = 0;', 1]
['"--  pubsub=       \'channel:subscribers:\'..id, --set\\n"', 1]
['DBG("publish unbuffer msg %V expire %i ", msgid_to_str(&publish_msg->id), cf->buffer_timeout);', 1]
['full_subscriber_t          *fsub = d->fsub;', 1]
['spooled_subscriber_cleanup_t  dequeue_callback_data;', 1]
['max = MAX_FAKE_WORKERS;', 1]
['{ ngx_string("nchan_message_buffer_length"),', 1]
['(add)->hh.hashv, _ha_bkt);                                              \\', 1]
['ERR("couldn\'t get chanhead while receiving subscribe ipc msg");', 1]
['#define CHANNEL_HASH_ADD(chanhead)      HASH_ADD_KEYPTR( hh, mpt->hash, (chanhead->id).data, (chanhead->id).len, chanhead)', 1]
['if(n_out > 1) {', 1]
['while(sp <= end && strchr(cset, *sp)) sp++;', 1]
['return cmp_write_s8(ctx, d);', 1]
['#ifndef CMP_H__', 1]
['ngx_destroy_pool(nchan_pool); // just for this worker', 1]
['}                                                                           \\', 1]
['unsigned                        http_multipart:1;', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "redis_nginx_adapter: could not select redis database");', 1]
['/* Create a dummy connection just to get an fd to inherit */', 1]
['you use this API. The reply is cleaned up by hiredis _after_ the callback', 1]
['void *nchan_thingcache_get(void *tcv, ngx_str_t *id) {', 1]
['static ngx_int_t websocket_send_frame(full_subscriber_t *fsub, const u_char opcode, off_t len);', 1]
['CMP_TYPE_FIXEXT8,         /* 25 */', 1]
['chanhead_cleanlink = &head->cleanlink;', 1]
['b -= c; b -= a; b ^= ( a << 16 );                                              \\', 1]
['if ( CHECK_REPLY_ARRAY_MIN_SIZE(r, 4)', 1]
['@id=msgid', 1]
['if(chan->last_published_msg_id.tagcount > NCHAN_FIXED_MULTITAG_MAX) {', 1]
['int test_inherit_fd = 1;', 1]
['sh->free = totlen-sh->len;', 1]
['bool cmp_write_ufix(cmp_ctx_t *ctx, uint8_t c) {', 1]
['void    **prev = thing_prev_ptr(rp, thing);', 1]
['if (!write_type_marker(ctx, BIN16_MARKER))', 1]
['obj->as.str_size = type_marker & FIXSTR_SIZE;', 1]
['if (init) {', 1]
['### Cleaning up', 1]
['if(*spool->spooler->channel_status != READY) {', 1]
['static void reaper_timer_handler(ngx_event_t *ev) {', 1]
['result->tv_sec = x->tv_sec - y->tv_sec;', 1]
['ngx_memcpy(content_type->data, msg->content_type.data, content_type->len);', 1]
['static char* inactive="%i,";', 1]
['/* FNV-1a variation */', 1]
['table.insert(bulk, k)', 1]
['time_t t = ngx_time();', 1]
['nchan_store_channel_head_t     *gc_next;', 1]
['`reply->integer` field of type `long long`.', 1]
['* formatted command to the output buffer and registers the provided callback', 1]
['return &((subscriber_pool_t *)data)->id;', 1]
['ngx_int_t ipc_open(ipc_t *ipc, ngx_cycle_t *cycle, ngx_int_t workers, void (*slot_callback)(int slot, int worker));', 1]
['/* Make sure the DB is emtpy */', 1]
['} unix;', 1]
['if(sub->last_msgid.time + ttl <= time) {', 1]
['printf("\\nTesting against Unix socket connection (%s):\\n", cfg.unix.path);', 1]
['assert(type == REDIS_ERR_IO);', 1]
['else if(filename->len < 512) {', 1]
['ngx_int_t memstore_ipc_send_does_channel_exist(ngx_int_t dst, ngx_str_t *chid, callback_pt callback, void* privdata) {', 1]
['determine the length of the string:', 1]
['//     redisSetCommandCallback(c,__test_callback,(void*)1);', 1]
['struct ngx_rbtree_debug_node_s {', 1]
['assert(msg_id->tagcount == 1);', 1]
['void memstore_ipc_alert_handler(ngx_int_t sender, ngx_uint_t code, void *data) {', 1]
['NULL,                          /* init master */', 1]
['redisGetReply(context,&reply); // reply for GET', 1]
['ngx_int_t (*publish)     (ngx_str_t *, nchan_msg_t *, struct nchan_loc_conf_s *, callback_pt, void *);', 1]
['for(i=0; i < sz; i++) {', 1]
['unsigned                        tagcount:16;', 1]
['The asynchronous context can hold a disconnect callback function that is called when the', 1]
['return ngx_strncmp(str->data, match, str->len) == 0;', 1]
['u_char                        *cur;', 1]
['bool cmp_write_float(cmp_ctx_t *ctx, float f);', 1]
['ngx_buf_t *buf = NULL;', 1]
['ipc_alert_t   alert;', 1]
['ngx_int_t nchan_reaper_start(nchan_reaper_t *rp, char *name, int prev, int next, ngx_int_t (*ready)(void *, uint8_t), void (*reap)(void *), int tick_sec) {', 1]
['DYLIB_MINOR_NAME=$(LIBNAME).$(HIREDIS_MAJOR).$(HIREDIS_MINOR).$(DYLIBSUFFIX)', 1]
['prevtags[0]=msg->prev_id.tag.fixed[0];', 1]
['#define REDIS_ERR_OTHER 2 /* Everything else... */', 1]
['/* Reads a map from the backend */', 1]
['unsigned int (*hashFunction)(const void *key);', 1]
['#define NCHAN_DEFAULT_SUBSCRIBER_TIMEOUT 0  //default: never timeout', 1]
['DBG("IPC: received publish status for channel %V status %i %s", d->shm_chid, d->status_code, d->status_line == NULL ? &nullstring : d->status_line);', 1]
['void              shmtx_lock(shmem_t *shm);', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SUB:MEM-MULTI:" fmt, ##arg)', 1]
['id.time=ngx_http_parse_time(r->headers_in.if_modified_since->value.data, r->headers_in.if_modified_since->value.len);', 1]
["p = strchr(p,'$');", 1]
['void *cur;', 1]
['full_subscriber_t  *fsub;', 1]
['void shmtx_unlock(shmem_t *shm) {', 1]
['bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size) {', 1]
['int         n;', 1]
['* 2) The string.', 1]
['ngx_int_t nchan_add_variables(ngx_conf_t *cf) {', 1]
['last = ngx_copy(last, &len_net, 2);', 1]
['custom_close_msg.data=msgbuf;', 1]
['ngx_int_t                  status_code;', 1]
['//static char        *cur;', 1]
['sr->headers_in.headers.last = &sr->headers_in.headers.part;', 1]
["-- no_msgid_order: 'FILO' for oldest message, 'FIFO' for most recent", 1]
['sub_create = http_chunked_subscriber_create;', 1]
['nanosleep(&tv, NULL);', 1]
['callbackKeyDestructor,', 1]
['static char *nchan_ignore_subscriber_concurrency(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['store_channel_head_shm_t  *channel_info;', 1]
['return cbuf;', 1]
['--kick out old subscribers', 1]
['The following examples shows a simple pipeline (resulting in only a single call to `write(2)` and', 1]
['ngx_buf_t      *mpbuf =(ngx_buf_t *)cmp->buf;', 1]
['while (__redisShiftCallback(&ac->sub.invalid,&cb) == REDIS_OK)', 1]
['if (!ctx->read(ctx, &obj->as.s32, sizeof(int32_t))) {', 1]
['change_sub_count(target_ch, multi_subs);', 1]
['static ngx_int_t longpoll_reserve(subscriber_t *self) {', 1]
['while(!done) {', 1]
['//  d->chanhead = local_chanhead;', 1]
['bool cmp_write_ext(cmp_ctx_t *ctx, int8_t tp, uint32_t sz, const void *data) {', 1]
['list->head = cb->next;', 1]
['ngx_int_t            rbtree_remove_node(rbtree_seed_t *, ngx_rbtree_node_t *);', 1]
['n += stat->num;', 1]
['redisContext *redisConnectNonBlock(const char *ip, int port);', 1]
['id.tag.fixed[0] = 0;', 1]
["//remove from cleanup list if we're there", 1]
['full_subscriber_t        *fsub = (full_subscriber_t *)self;', 1]
['#include <store/memory/shmem.h>', 1]
['static void rwl_lock_mutex(ngx_rwlock_t *lock) {', 1]
['//TODO: optimize this alloc away', 1]
['//TODO: change status to NOTREADY and whatnot', 1]
['#ifndef __HIREDIS_LIBUV_H__', 1]
['subscriber_t *intervalpoll_subscriber_create(ngx_http_request_t *r, nchan_msg_id_t *msg_id) {', 1]
['/* random signature used only to find hash tables in external analysis */', 1]
['switch (frame->step) {', 1]
['buf = ngx_pcalloc(r->pool, sizeof(*buf) + content_type->len + 25);', 1]
['/* Only REDIS_ERR_IO may lack a description! */', 1]
['"msg",', 1]
['static ngx_int_t chanhead_messages_gc(nchan_store_channel_head_t *ch) {', 1]
['@ttl=_empty_is_nil arg[:ttl]', 1]
['return sub->cf->storage_engine->subscribe(ch_id, sub);', 1]
['case 3: _mur_k1 ^= _mur_tail[2] << 16;                             \\', 1]
['len=els[offset+5]->len;', 1]
['assert(memstore_channel_owner(channel_id) == memstore_slot());', 1]
['} flood_data_t;', 1]
['if (target != NULL)', 1]
['static uint16_t be16(uint16_t x) {', 1]
['if (ctx->write(ctx, data, 8))', 1]
['fsub->msg_buf.last_buf=1;', 1]
['char                         *ctx_type = "Some";', 1]
['and can be accessed via `reply->element[..index..]`.', 1]
['if (r->len == 0)', 1]
['nchan_expand_msg_id_multi_tag(&remsg.id, 0, d->n, -1);', 1]
['static ngx_int_t ngx_strmatch(ngx_str_t *str, char *match) {', 1]
['* \\0 characters in the middle, as the length is stored in the sds header. */', 1]
['want[i] = 1;', 1]
['info: "Maximum concurrent subscribers."', 1]
['#define UTHASH_VERSION 1.9.9', 1]
['/* Found. */', 1]
['return nchan_store_subscribe_continued(channel_status, _, d);', 1]
['extern nchan_store_t  nchan_store_memory;', 1]
['int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...) {', 1]
['iter->ht = ht;', 1]
['internal_subscriber_t  *fsub = (internal_subscriber_t  *)sub;', 1]
['pd->ch.messages = ch->messages;', 1]
['size_t maxbuf; /* Max length of unused buffer */', 1]
['d->n = sd->n;', 1]
['void memstore_ipc_alert_handler(ngx_int_t sender, ngx_uint_t code, void *data);', 1]
['HASH_OOPS("invalid hh_prev %p, actual %p\\n",                  \\', 1]
['char *buf; /* Read buffer */', 1]
['ngx_flag_t       global_redis_enabled = 0;', 1]
['ngx_str_t * (*message_etag)(nchan_msg_t *msg, ngx_pool_t *pool);', 1]
['hash = ((hash << 5) + hash) + (*buf++); /* hash * 33 + c */', 1]
['* the element already exists. */', 1]
['sent << publish(Msg.new(id, data: "fee", ttl: 3))', 1]
['if (chanhead == NULL) {', 1]
['ngx_int_t nchan_store_redis_fakesub_add(ngx_str_t *channel_id, ngx_int_t count);', 1]
['ngx_str_t            id;', 1]
['if(sub->type != INTERNAL && spool->spooler->publish_events) {', 1]
['nchan_msg_id_t   *id1 = (nchan_msg_id_t *)v1;', 1]
['if(global_redis_enabled && nchan_store_redis.init_postconfig(cf)!=NGX_OK) {', 1]
['if(ch->multi[i].sub) {', 1]
['else if(tag1 < tag2) {', 1]
['const ngx_str_t NCHAN_HEADER_UPGRADE = ngx_string("Upgrade");', 1]
['* so now we can write this with a bit shift and logical AND:', 1]
['if(params->db == NGX_ERROR) {', 1]
['nchan_complex_value_arr_t       pub_chid;', 1]
['"  if channel.current_message ~= nil then\\n"', 1]
[':nchan_ignore_obsolete_setting,', 1]
['Copyright (c) 2003-2014, Troy D. Hanson     http://troydhanson.github.com/uthash/', 1]
['its_reaping_time(rp, 1);', 1]
['shm_free(shm, (void *)str);', 1]
['if (r->element != NULL) {', 1]
['if (obj.type != CMP_TYPE_FIXEXT2) {', 1]
['if(tmp->len != NCHAN_WEBSOCKET.len || ngx_strncasecmp(tmp->data, NCHAN_WEBSOCKET.data, NCHAN_WEBSOCKET.len) != 0) return 0;', 1]
['unsigned _src_bkt, _dst_bkt;                                                   \\', 1]
['"  if on then return function(...) \\n"', 1]
['CMP_TYPE_UINT32,          /* 16 */', 1]
['lcf->publisher_upstream_request_url = NULL;', 1]
["* contiguous characters found in 'cset', that is a null terminted C string.", 1]
['/* XXX maybe we should set those built-in header slot in', 1]
['ctx->channel_event_name = &evt_sub_dequeue;', 1]
['redis_subscriber_register(head, sub);', 1]
['p += 3;', 1]
['cfg.type = CONN_TCP;', 1]
['int32_t   s32;', 1]
['void                       *bulk_dequeue_handler_privdata;', 1]
['last = ngx_copy(last, &len, 1);', 1]
['static ngx_int_t spool_fetch_msg_callback(nchan_msg_status_t findmsg_status, nchan_msg_t *msg, fetchmsg_data_t *data) {', 1]
['"local code=tonumber(ARGV[2])\\n"', 1]
['&nchan_module_ctx,             /* module context */', 1]
['#define dictSlots(ht) ((ht)->size)', 1]
['ngx_memzero(&fsub->timeout_ev, sizeof(fsub->timeout_ev));', 1]
['if (!(head)) {                                                                  \\', 1]
['ngx_str_t                       *connect_url;', 1]
['for(cur = spool->first; cur != NULL; cur = cur->next) {', 1]
['while(cur != NULL && max_messages >= 0 && ch->channel.messages > max_messages) {', 1]
['case NCHAN_SUBSCRIBER_CONCURRENCY_FIRSTIN:', 1]
['ngx_int_t nchan_detect_websocket_request(ngx_http_request_t *r);', 1]
['"  channel = {time=time}\\n"', 1]
["redis.call('PUBLISH', channel_key, del_msgpack)", 1]
["if(cur[0]==';' && cur[1]=='q' && cur[2]=='=') {", 1]
['&& ngx_strncasecmp(header[i].key.data, (u_char *) "Content-Length", sizeof("Content-Length") - 1) == 0) {', 1]
['noopt:', 1]
['r = createReplyObject(REDIS_REPLY_INTEGER);', 1]
['char *_hb_key=(char*)(key);                                                    \\', 1]
['r->write_event_handler = ngx_http_request_empty_handler;', 1]
['if (obj.type != CMP_TYPE_UINT64) {', 1]
['i *= 2;', 1]
['static ngx_int_t nchan_http_publisher_handler(ngx_http_request_t * r) {', 1]
['link->time = ngx_time();', 1]
['int redisContextConnectTcp(redisContext *c, const char *addr, int port,', 1]
['assert(max < 255);', 1]
['assert(head == d->originator);', 1]
['ipc_alert(nchan_memstore_get_ipc(), sender, IPC_DOES_CHANNEL_EXIST_REPLY, d, sizeof(*d));', 1]
['d->callback(d->status, &ch, d->callback_privdata);', 1]
['bool cmp_write_fixmap(cmp_ctx_t *ctx, uint8_t size) {', 1]
['cf.buffer_timeout = d->msg_timeout;', 1]
["unsigned keylen;                  /* enclosing struct's key len     */", 1]
['s = sdscatprintf(s,"\\\\x%02x",(unsigned char)*p);', 1]
['extern ngx_module_t nchan_module;', 1]
['ERR("unable to allocate memory for payload");', 1]
['-- finds and return the info hash of a channel, or nil of channel not found', 1]
['fwd_buf_to_str(mpb, sz, &msg->content_type);', 1]
['ch->status = INACTIVE;', 1]
['ngx_int_t     port;', 1]
['#include <stdint.h>', 1]
['m->nobuffer_msg_reaper.max_notready_ratio = 0.10;', 1]
['glob->ipc->handler(glob->alert.src_slot, glob->alert.code, glob->alert.data);', 1]
["local numsub = redis.call('PUBSUB','NUMSUB', channel_pubsub)[2]", 1]
['if(owner == memstore_slot()) {', 1]
['CMP_TYPE_SINT64,          /* 21 */', 1]
['nchan_conf_publisher_types_t    pub;', 1]
['int _sfh_rem = _sfh_len & 3;                                                   \\', 1]
['"    redis.call(\'DEL\', \'channel:msg:\'..id..\':\'..oldmsgid)\\n"', 1]
['#define MUR_ONE_THREE(p) ((((*WP(p))&0xff000000) >>24) | (((*(WP(p)+1))&0x00ffffff) <<  8))', 1]
['"local id, time, tag, subscribe_if_current = ARGV[1], tonumber(ARGV[2]), tonumber(ARGV[3])\\n"', 1]
['* These used to be expressed using (delptr) but that led to a bug', 1]
['const  ngx_str_t NCHAN_ACCESS_CONTROL_ALLOWED_PUBLISHER_HEADERS = ngx_string("Content-Type, Origin");', 1]
['if (frame->payload_len > 0) {', 1]
['//headers', 1]
['ngx_int_t nchan_reaper_withdraw(nchan_reaper_t *rp, void *thing) {', 1]
['spool_transfer_subscribers(spool, nuspool, 1);', 1]
['DBG("%p (%V) free", self, fsub->sub.name);', 1]
['assert(head->foreign_owner_ipc_sub == d->d.subscriber);', 1]
['set_buf(&mpbuf, (u_char *)el->str, el->len);', 1]
['[IPC_DOES_CHANNEL_EXIST_REPLY]=     (ipc_handler_pt )receive_does_channel_exist_reply,', 1]
['ngx_add_timer(&f->timeout_ev, f->sub.cf->subscriber_timeout * 1000);', 1]
['(void (*)(void *)) memstore_reap_chanhead,', 1]
['//the event message', 1]
['cur += msgtag_to_strptr(&msg->id, (char *)cur);', 1]
['//     if (reply) freeReplyObject(reply);', 1]
['FILE       *stream;', 1]
['} nchan_reaper_t;', 1]
['#endif /*NCHAN_MODULE_H*/', 1]
['#define cmp_write_uint     cmp_write_uinteger', 1]
['#include <store/rbtree_util.h>', 1]
['ngx_int_t nchan_create_websocket_publisher(ngx_http_request_t  *r) {', 1]
['unsigned nonideal_items;', 1]
['ngx_int_t               rc = NGX_DONE;', 1]
['} redis_subscribe_data_t;', 1]
['if(content_type_len > 0) {', 1]
['mult = -1;', 1]
['msg = m;', 1]
['(key1) == (key2))', 1]
['int free;', 1]
['head->in_churn_queue = 0;', 1]
['"dbg(\\"channel \\", id, \\" ttl: \\",channel.ttl, \\", subscribers: \\", channel.subscribers, \\"(fake: \\", channel.fake_subscribers or \\"nil\\", \\"), messages: \\", num_messages)\\n"', 1]
['else if(ngx_strmatch(&alerttype, "unsub all except")) {', 1]
['cur->sub->dequeue_after_response = 1;', 1]
['ngx_str_t          id;', 1]
['static inline size_t sdslen(const sds s) {', 1]
['last++;', 1]
['//is this right?', 1]
["redis.call('PUBLISH', channel_key, pubmsg)", 1]
['static size_t bulklen(size_t len) {', 1]
['@content_type=_empty_is_nil arg[:content_type]', 1]
['//#include <store/memory/store-private.h> //for debugging', 1]
['rescue Redis::CommandError => e', 1]
['if(spl->bulk_dequeue_handler) {', 1]
['/* Reset socket to be blocking after connect(2). */', 1]
['return REDIS_ERR_OOM;', 1]
['int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap) {', 1]
['nchan_create_loc_conf,         /* create location configuration */', 1]
["// no_msgid_order: 'FILO' for oldest message, 'FIFO' for most recent", 1]
['when compiling c++ source) this code uses whatever method is needed', 1]
['int throughput = 1;', 1]
['*str = p+2;', 1]
['assert(!f->already_dequeued);', 1]
['if(fsub->sub.cf->longpoll_multimsg) {', 1]
['event_base_set(base,&e->rev);', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "RBTREE:" fmt, ##arg)', 1]
['ngx_chain_t *chain = REQUEST_PALLOC(r, chain);', 1]
['if(n <= NCHAN_FIXED_MULTITAG_MAX) {', 1]
['ERR("failed to transfer spool subscribers");', 1]
['byte = (hex_digit_to_int(*(p+2))*16)+', 1]
['return mcf;', 1]
['struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail;            \\', 1]
['#    - last: only the most recent subscriber request is kept, all others get a 409 Conflict response.', 1]
['d->sub->fn->respond_status(d->sub, NGX_HTTP_INTERNAL_SERVER_ERROR, NULL); //auto-closes subscriber', 1]
['ngx_int_t longpoll_subscriber_destroy(subscriber_t *sub);', 1]
['//r->headers_out.content_type.data = content_type.data;', 1]
['#define HASH_SORT(head,cmpfcn) HASH_SRT(hh,head,cmpfcn)', 1]
['bool cmp_write_false(cmp_ctx_t *ctx) {', 1]
['//int8_t                     i, max;', 1]
['#define DBG(fmt, args...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "IPC-HANDLERS(%i):" fmt, memstore_slot(), ##args)', 1]
['init_msg_buf(&msgbuf);', 1]
['#define dictSize(ht) ((ht)->used)', 1]
['store_message_t      *cur, *first;', 1]
['return ipc_alert(nchan_memstore_get_ipc(), dst, IPC_GET_MESSAGE, &data, sizeof(data));', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: thought there\'d be a channel id around for msg");', 1]
['rbtree_walk_real(seed, right, sentinel, callback, data);', 1]
['bc.buf.start = end_boundary;', 1]
['*d = obj.as.u8;', 1]
['chain->next=NULL;', 1]
['ngx_pool_t   *tmp_pool = NULL;', 1]
['root = (r->ridx == 0);', 1]
['nchan_output_filter(fsub->sub.request, chain);', 1]
['DBG("chanhead %p (%V) is empty and expired. DELETE.", ch, &ch->id);', 1]
['/* Add an element to the target hash table */', 1]
['ngx_int_t    i, max, removed = 0;', 1]
['obj->type = CMP_TYPE_UINT32;', 1]
['nchan_msg_id_t               last_msgid;', 1]
['* foo bar "newline are supported\\n" and "\\xff\\x00otherstuff"', 1]
['ngx_int_t nchan_request_set_content_type_multipart_boundary_header(ngx_http_request_t *r, nchan_request_ctx_t *ctx);', 1]
['void sdstoupper(sds s) {', 1]
['static int redisContextWaitReady(redisContext *c, const struct timeval *timeout) {', 1]
['if((tmp_pool = ngx_create_pool(NCHAN_WS_UPSTREAM_TMP_POOL_SIZE, ngx_cycle->log))==NULL) {', 1]
['this list of conditions and the following disclaimer in the documentation', 1]
['//not yet implemented', 1]
['if(ch->channel.messages == 0) {', 1]
['dst->len = sz;', 1]
['// static redisContext *__connect_nonblock() {', 1]
['DBG("IPC: send get message from %i ch %V", dst, chid);', 1]
['nchan_longpoll_multimsg_t *multimsg_last;', 1]
['if (bin_size > buf_size) {', 1]
['ngx_str_t           *accept_header = NULL;', 1]
['sub_create = longpoll_subscriber_create;', 1]
['//reload_msgs();', 1]
['last = cur + id[n_out].len;', 1]
['if create_channel_ttl==0 then', 1]
['int redisFormatCommand(char **target, const char *format, ...);', 1]
['if (ac->err == 0) {', 1]
['ngx_memzero(&fsub->sub.last_msgid, sizeof(fsub->sub.last_msgid));', 1]
['boundary[i].last = boundary[i].end;', 1]
['*fd=NGX_INVALID_FILE;', 1]
['S32_MARKER             = 0xD2,', 1]
['ngx_int_t                       messages;', 1]
["* Reads a string from the backend; according to the spec, the string's data", 1]
['"local num=tonumber(ARGV[2])\\n"', 1]
['else if (type_marker == FIXEXT8_MARKER) {', 1]
['if(status_line!=NULL) {', 1]
['redisAeAttach(loop, c);', 1]
['mid->tagactive = i;', 1]
['//nchan_walk_rbtree(nchan_movezig_channel_locked, nchan_shm_zone);', 1]
['if((chead = nchan_memstore_find_chanhead(d->shm_chid)) == NULL) {', 1]
['"61308a3e69a2857570da0cbc8cf28afe6d33c4fd",', 1]
['//print information about a channel', 1]
['"  dbg(\\"New message id: last_time \\", lasttime, \\" last_tag \\", lasttag, \\" msg_time \\", msg.time)\\n"', 1]
['//copypasta because these should only be used for debugging', 1]
['for(i=0; i< head->multi_count; i++) {', 1]
['proc->wbuf.overflow_n--;', 1]
['"  channel.ttl=msg.ttl\\n"', 1]
['//TODO: maybe message-expired notification', 1]
['#define SHPOOL(shmem) ((ngx_slab_pool_t *)(shmem)->zone->shm.addr)', 1]
['args: 0..6,', 1]
["case '%':", 1]
['if (rc == 0) {', 1]
['for(i=0; i < n && n_out < NCHAN_MULTITAG_MAX; i++) {', 1]
['After the command is put in the output buffer, `redisGetReply` is called. This function has the', 1]
['const char *argv[3];', 1]
['void *(*createInteger)(const redisReadTask*, long long);', 1]
['//ERR("request %p orig pool %p", r, r->pool);', 1]
['/* If this was the last unsubscribe message, revert to', 1]
['rbtree_conditional_walk(&self->spoolseed, (rbtree_walk_conditional_callback_pt )collect_spool_range, &srdata);', 1]
['nchan_parse_msg_tag(if_none_match->data, if_none_match->data + if_none_match->len, &id);', 1]
['FLOAT_WIDTH_TEST(float);', 1]
['"if msg.prev then\\n"', 1]
['bool cmp_read_bin(cmp_ctx_t *ctx, void *data, uint32_t *size) {', 1]
['psr->data = &psr_stuff->psr_data;', 1]
['ngx_conf_merge_value(conf->subscribe_only_existing_channel, prev->subscribe_only_existing_channel, 0);', 1]
['#define WEBSOCKET_READ_START_STEP           0', 1]
["if (*p == '\\\\' && *(p+1) == 'x' &&", 1]
['} nchan_auth_subrequest_stuff_t;', 1]
['int8_t type;', 1]
['&internal_notify,', 1]
['*reply = NULL;', 1]
['if(spool == NULL) {', 1]
['script_table=[]', 1]
["redis.call('DEL', subs_key)", 1]
['ngx_memcpy(fsub->sub.lbl, r->uri.data, r->uri.len);', 1]
['bool cmp_read_ext8_marker(cmp_ctx_t *ctx, int8_t *type, uint8_t *size);', 1]
['rdt.ctx = NULL;', 1]
['contained in arrays and nested arrays, so there is no need for the user to', 1]
['if msg_id and channel.current_message == msg_id', 1]
['e = (redisLibeventEvents*)malloc(sizeof(*e));', 1]
['r->headers_in.content_length = h;', 1]
['ngx_module_t  nchan_module = {', 1]
['#define SLOW_REDIS_REPLY 100 //ms', 1]
['buf_copy->last_buf = 1;', 1]
['redisReply             *el = NULL;', 1]
['/* Add every channel/pattern to the list of subscription callbacks. */', 1]
['//not a worker, stop initializing stuff.', 1]
['#ifndef NCHAN_TYPES_H', 1]
['* NOTE: This function should only called by ht_destroy(). */', 1]
['msgid = msgid_to_str(&ctx->msg_id);', 1]
['ngx_int_t                  (*ready)(void *, uint8_t force); //ready to be reaped?', 1]
['int _len = len-1;', 1]
['spooler_set_add_handler,', 1]
['right = node->right;', 1]
['cur = (next == NULL ? rp->first : next);', 1]
['v *= 10;', 1]
['legacy: "push_store_messages",', 1]
['FIXEXT2_MARKER         = 0xD5,', 1]
['#define __HIREDIS_LIBEVENT_H__', 1]
['void *nchan_thingcache_get(void *tcv, ngx_str_t *id);', 1]
['ngx_http_finalize_request(fsub->sub.request, NGX_OK);', 1]
['### Reader max buffer', 1]
['if(shdata->procslot[i] == NCHAN_INVALID_SLOT) {', 1]
['#define DECLTYPE(x) (decltype(x))', 1]
['uint32_t        h;', 1]
['boundary[i].memory = 1;', 1]
['getmessage_data_t      data;', 1]
['* format. When this is the need, just use sdsempty() as the target string:', 1]
['ngx_destroy_pool(fsub->upstream_stuff->psr_data.tmp_pool);', 1]
['fsub->data.owner = memstore_slot();', 1]
['bool cmp_read_map(cmp_ctx_t *ctx, uint32_t *size) {', 1]
["if (*_p == '.') {", 1]
['subscriber_t    *sub;', 1]
['ngx_int_t nchan_store_publish_message_generic(ngx_str_t *channel_id, nchan_msg_t *msg, ngx_int_t msg_in_shm, nchan_loc_conf_t *cf, callback_pt callback, void *privdata) {', 1]
['$(CC) -MM *.c', 1]
['obj->type = CMP_TYPE_FIXEXT4;', 1]
['if (reply->element[2]->integer == 0)', 1]
['sh->buf[newlen] = 0;', 1]
['rbtree_walk(&self->spoolseed, (rbtree_walk_callback_pt )spooler_respond_rbtree_node_spool, &data);', 1]
['static ngx_str_t   TE_HEADER = ngx_string("TE");', 1]
['printf("GET foo: %s\\n", reply->str);', 1]
['rbtree_seed_t         *seed = &spool->spooler->spoolseed;', 1]
['ngx_memcpy(cur, group->data, group->len);', 1]
['msglen = msg->buf->end - msg->buf->start;', 1]
['void sdsfree(sds s);', 1]
['format = &NCHAN_CHANNEL_INFO_PLAIN;', 1]
['} shm_data_t;', 1]
['* context is non-blocking, the "reply" pointer will not be used and the', 1]
['callbacks = ac->sub.channels;', 1]
["if (value < 0) *p-- = '-';", 1]
['bool cmp_object_to_bin(cmp_ctx_t *ctx, cmp_object_t *obj, void *data, uint32_t buf_size) {', 1]
['`type` field in the `redisReply` should be used to test what kind of reply', 1]
['if(validate_id(r, &tmpid, cf) != NGX_OK) {', 1]
['* On >2.0, QUIT will return with OK and another read(2) needed to be', 1]
['ngx_http_subrequest(r, &auth_request_url, NULL, &sr, psr, 0);', 1]
['static ngx_inline void ngx_init_set_membuf(ngx_buf_t *buf, u_char *start, u_char *end) {', 1]
['rc = spool_fetch_msg(spool);', 1]
['ngx_close_connection(connection);', 1]
['shm = ngx_alloc(sizeof(*shm), ngx_cycle->log);', 1]
['sds sdsdup(const sds s);', 1]
['ngx_int_t       workers;', 1]
['/* Unused arguments generate annoying warnings... */', 1]
['bool cmp_object_is_uchar(cmp_object_t *obj) {', 1]
['/* Join an array of C strings using the specified separator (also a C string).', 1]
['{ ngx_string("nchan_channel_id3"),        nchan_channel_id_variable, 2},', 1]
['uint64_t              len_net;', 1]
['spool->msg = msg;', 1]
['/* Create a new hash table */', 1]
['for (j = 0; j < len; j++) s[j] = tolower(s[j]);', 1]
['[IPC_GET_CHANNEL_INFO] =            (ipc_handler_pt )receive_get_channel_info,', 1]
['c->write->log = cycle->log;', 1]
['#define REDIS_KEEPALIVE_INTERVAL 15 /* seconds */', 1]
['nchan_store_memory.exit_worker(cycle);', 1]
['#include <subscribers/http-chunked.h>', 1]
['bc[2].buf.memory = 1;', 1]
['There was an I/O error while creating the connection, trying to write', 1]
['typedef struct spool_collect_overflow_s spool_collect_overflow_t;', 1]
['y->tv_sec += nsec;', 1]
['lcf->buffer_timeout=NGX_CONF_UNSET;', 1]
['//d->sub->last_msg_id = msg->id;', 1]
['internal_subscriber_destroy(self);', 1]
['"  channel.max_stored_messages = store_at_most_n_messages\\n"', 1]
['memstore_ready_chanhead_unless_stub(d->multi_chanhead);', 1]
['nchan_merge_loc_conf,          /* merge location configuration */', 1]
['if(sub->type != INTERNAL && self->spooler->publish_events) {', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "NCHAN: Channel info string too long: max: 512, is: %i", len);', 1]
['bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size);', 1]
['//set preamble in the request ctx. it would be nicer to store in in the subscriber data,', 1]
['last_seen = ch->last_seen;', 1]
['size_t                  total_sz, buf_body_size = 0, content_type_size = 0, buf_filename_size = 0, eventsource_event_size = 0;', 1]
['if (c->flags & (REDIS_DISCONNECTING | REDIS_FREEING)) return REDIS_ERR;', 1]
['/* Grow the sds to have the specified length. Bytes that were not part of', 1]
['memcpy(buf,str,len);', 1]
['hints.ai_socktype = SOCK_STREAM;', 1]
['ngx_int_t                  n;', 1]
['bool cmp_write_fixext2(cmp_ctx_t *ctx, int8_t type, const void *data);', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: unable to allocate memory for Content Type header");', 1]
['if(!largetags) {', 1]
['nchan_store_channel_head_t * nchan_memstore_find_chanhead(ngx_str_t *channel_id) {', 1]
['uint32_t  bin_size;', 1]
['#define CLOSE_INVALID_PAYLOAD        1007', 1]
['"local new_channel = false\\n"', 1]
['return hash;', 1]
['const  ngx_str_t NCHAN_HEADER_PRAGMA = ngx_string("Pragma");', 1]
['Hiredis was written by Salvatore Sanfilippo (antirez at gmail) and', 1]
['#define HASH_ADD_INT(head,intfield,add)                                          \\', 1]
['"  return {err=\'Message content-type cannot contain \\":\\" character.\'}\\n"', 1]
['static ngx_int_t redis_array_to_channel(redisReply *r, nchan_channel_t *ch) {', 1]
['bool cmp_write_double(cmp_ctx_t *ctx, double d);', 1]
['#define NCHAN_DEFS_H', 1]
['strerror_r(errno,c->errstr,sizeof(c->errstr));', 1]
['%w( foobar1 whatthe-somethng-of isnot-even-meaning -has-you-evenr-as-sofar-as-to -even-move-zig).each do |w|', 1]
['//is the message queue too big?', 1]
['u_char rsv3:1;', 1]
['alert = &wb->alerts[(wb->first + wb->n++) % IPC_WRITEBUF_SIZE];', 1]
['if (c->flags & REDIS_BLOCK) {', 1]
['const ngx_str_t           *status_line;', 1]
['frame->rsv1 = (frame->header[0] >> 6) & 1;', 1]
['ERR("SPOOLER %p has no add_handler, couldn\'t add subscriber %p", self, sub);', 1]
['return {err=\'Message content-type cannot contain ":" character.\'}', 1]
['ctx->channel_id_count = n_out;', 1]
['void nchan_expand_msg_id_multi_tag(nchan_msg_id_t *id, uint8_t in_n, uint8_t out_n, int16_t fill) {', 1]
['delete id', 1]
['ngx_free(rdt.connect_params);', 1]
['uint8_t type;', 1]
['filling up the output buffer. For this cause, two commands can be used that are identical', 1]
['ngx_log_error(NGX_LOG_ERR, (r)->connection->log, 0, "nchan: unexpected publisher message request body buffer location. please report this to the nchan developers.");', 1]
['assert(ctx != NULL);', 1]
[':nchan_pubsub_directive,', 1]
["_format[_l] = '\\0';", 1]
['{ ngx_string("push_channel_group"), //legacy for nchan_channel_group', 1]
['if (ac->onDisconnect == NULL) {', 1]
['static void handle_chanhead_gc_queue(ngx_int_t force_delete) {', 1]
['static unsigned int callbackHash(const void *key) {', 1]
['ngx_http_complex_value_t          **cv;', 1]
['static redisReply *createReplyObject(int type);', 1]
['v += dec;', 1]
['if(cf) {', 1]
['sdslen(x) == 5 && memcmp(x,"fobar\\0",6) == 0);', 1]
['case NGX_DECLINED:', 1]
['DBG("received get_channel_info request for channel %V privdata %p", d->shm_chid, d->privdata);', 1]
['begin', 1]
['void                        *cb_privdata;', 1]
['#include "testhelp.h"', 1]
['ngx_int_t                    sub_count;', 1]
['#define NGX_HTTP_SWITCHING_PROTOCOLS       101', 1]
['memcpy(s+curlen, t, len);', 1]
['tags[i] = (i == out_n) ? v : fill;', 1]
['There was an error while parsing the protocol.', 1]
['void subscriber_debug_assert_isempty(void) {', 1]
['if(dst_n < src_n) {', 1]
['last = tmp->data + tmp->len;', 1]
['redisContext *redisConnectUnixNonBlock(const char *path);', 1]
["//previous upstream request's pool", 1]
['if(ch->msg_first == NULL) {', 1]
['ln += stat->lnum;', 1]
['"\\"subscribers\\": %ui, "', 1]
['Apart from supporting sending commands and receiving replies, it comes with', 1]
['nchan_store_multi_t            *multi;', 1]
['DBG("%p reserve for req %p. reservations: %i", self, fsub->sub.request, self->reserved);', 1]
['*c = obj->as.u8;', 1]
['ac->ev.delWrite = redis_nginx_del_write;', 1]
['key = 0;', 1]
['of the string:', 1]
['static void memstore_sub_debug_start() {', 1]
['fsub->data.dequeue_handler_data = NULL;', 1]
['r->headers_out.content_type = val;', 1]
['static ngx_str_t *nchan_subscriber_get_etag(ngx_http_request_t * r) {', 1]
['if (buf != NULL) {', 1]
['_src_hh;                                                               \\', 1]
['} nchan_store_t;', 1]
['const ngx_str_t                *format = &NCHAN_CHANNEL_INFO_PLAIN;', 1]
['mcount = d->multi_chanhead->multi_count;', 1]
['return cmp_object_is_ulong(obj);', 1]
['if(update_subscriber_last_msgid) {', 1]
['"Error writing fixed value",', 1]
['ERR("invalid websocket close status code %i", code);', 1]
['"  local lastmsg = redis.call(\'HMGET\', key.last_message, \'time\', \'tag\')\\n"', 1]
['ngx_str_t                       channel_info_content_type;', 1]
['ngx_str_t                      publisher_upstream_request_url;', 1]
['static ngx_str_t         transfer_encoding = ngx_string("chunked");', 1]
['return sdsnewlen(p,32-(p-buf));', 1]
['//nchan_loc_conf_t               *plcf = conf;', 1]
['fakebody_buf->pos = fakebody_buf->start;', 1]
['ngx_rbtree_node_t *found;', 1]
['static ngx_int_t longpoll_multimsg_respond(full_subscriber_t *fsub) {', 1]
['ngx_atomic_t                total_message_count;', 1]
['static ngx_int_t chanhead_push_message(nchan_store_channel_head_t *ch, store_message_t *msg);', 1]
['IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED', 1]
['int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn) {', 1]
["if(cur[0] == '/') {", 1]
['//switch back', 1]
['Version 0.9.0 is a major overhaul of hiredis in every aspect. However, upgrading existing', 1]
['ngx_str_t                   tmpid;', 1]
['cmp_ext_t ext;', 1]
['static void redisLibevReadEvent(EV_P_ ev_io *watcher, int revents) {', 1]
['reply = redisCommand(c,"FLUSHDB");', 1]
['{ ngx_string("nchan_channel_events_channel_id"),', 1]
["ngx_add_timer(timer, 0); //not sure if this needs to be done like this, but i'm just playing it safe here.", 1]
['ssub->dequeue_callback_data.ssub = ssub;', 1]
['"    key.message\\n"', 1]
['### 0.11.0', 1]
['name_table << "  \\"#{name}\\","', 1]
['if ((out)->hh.keylen == keylen_in) {                                           \\', 1]
['//open file fd if necessary', 1]
['//now the header', 1]
['static ngx_str_t        terminal_newlines=ngx_string("\\n\\n");', 1]
['HASH_ADD(hh,head,ptrfield,sizeof(void *),add)', 1]
['nchan_channel_group [:srv, :loc, :if],', 1]
['return cmp_object_is_long(obj);', 1]
['rp->last = cur;', 1]
['else if (type_marker == U64_MARKER) {', 1]
['"  return {err=(\\"Message for channel %s id %s already exists\\"):format(id, msg.id)}\\n"', 1]
['ngx_int_t nchan_response_channel_ptr_info(nchan_channel_t *channel, ngx_http_request_t *r, ngx_int_t status_code);', 1]
['//the churner is only allowed to churn self-owned channels', 1]
['"Error writing ext type",', 1]
['* len = redisFormatCommand(target, "GET %s", mykey);', 1]
['reply->element[1]->type == REDIS_REPLY_STATUS &&', 1]
['void                *firstmoved = NULL;', 1]
['multi = chead->multi;', 1]
['DBG("reap msg fd invalid");', 1]
['nchan_add_response_header(r, &NCHAN_HEADER_CONNECTION, &NCHAN_UPGRADE);', 1]
['sdslen((const sds)key));', 1]
['"  elseif sub_count < 0 then\\n"', 1]
['r->rstack[0].elements = -1;', 1]
['case MSG_PENDING:', 1]
['offsetof(nchan_store_channel_head_t, gc_prev),', 1]
['if(channel == NULL) {', 1]
['nchan_msg_t                 *publish_msg;', 1]
['channel = {time=time}', 1]
['ngx_del_timer(&tc->gc_timer);', 1]
['hdr_buf->last = ngx_copy(hdr_buf->last, &code_net, 2);', 1]
['*d = obj.as.s64;', 1]
['nchan_subscriber_directive_parse(cf, cmd, conf, 0);', 1]
['else if (type_marker == MAP32_MARKER) {', 1]
['have the following prototype:', 1]
['* The string is modified in-place.', 1]
['list->head = cb;', 1]
['spool->responded_count = 0;', 1]
['cur = (u_char *)&bc[1];', 1]
['reply->element[0]->type == REDIS_REPLY_ARRAY &&', 1]
['sa.sun_family = AF_LOCAL;', 1]
['(add)->hh.next = NULL;                                                          \\', 1]
['case 2: hashv += get16bits (_sfh_key);                                       \\', 1]
['ngx_int_t              (*notify)(struct subscriber_s *, ngx_int_t code, void *data);', 1]
['* The end result is that the selected items have dual presence', 1]
['cmp_read_str_size(&cmp ,&sz);', 1]
['int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {', 1]
['len += lcode(&e);', 1]
["* Note that 'sep' is able to split a string using", 1]
["/* Apply toupper() to every character of the sds string 's'. */", 1]
['ngx_str_t                  *id;', 1]
['/* Write a command to the output buffer. Use these functions in blocking mode', 1]
['_hs_p = _hs_q;                                                     \\', 1]
['fsub->ping_ev.handler = ping_ev_handler;', 1]
['shdata->max_workers = workers;', 1]
['ngx_free(id->tag.allocd);', 1]
['buf->pos=pos;', 1]
['//parse the freaking qvalue', 1]
['struct spooled_subscriber_s {', 1]
['int s;', 1]
['e.buf = *value;', 1]
['msg->prev->next = msg;', 1]
['for(i=0; i<3; i++) {', 1]
['ipc_writebuf_overflow_t  *next;', 1]
['sdslen(x) == 3 && memcmp(x,"foo\\0",4) == 0)', 1]
['buf->file->fd =NGX_INVALID_FILE;', 1]
['ac->onDisconnect(ac,(ac->err == 0) ? REDIS_OK : REDIS_ERR);', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:INTERVALPOLL:" fmt, ##arg)', 1]
['&internal_respond_message,', 1]
['* in the new end of the string.', 1]
['//time extended!', 1]
[':nchan_subscriber_first_message_directive,', 1]
['@time=Time.now.utc.to_i', 1]
['ngx_str_t            *channel_id;', 1]
['//garbage collecting goodness', 1]
['ngx_memset(node, 0x67, sizeof(*node));', 1]
['/* Search if this slot does not already contain the given key */', 1]
['## AUTHORS', 1]
['/* Set the socket nonblocking.', 1]
['//     test("Calls disconnect callback and free callback on redisFree: ");', 1]
['} else if (insq) {', 1]
['DBG("IPC send alert code %i to slot %i", code, slot);', 1]
['ngx_str_t              *publish_channel_id;', 1]
['} fetchmsg_data_t;', 1]
['static char *readBytes(redisReader *r, unsigned int bytes) {', 1]
['ngx_int_t nchan_memstore_handle_get_message_reply(nchan_msg_t *msg, nchan_msg_status_t findmsg_status, void *d);', 1]
['* see if there is a reply available. */', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "RBTREE:" fmt, ##arg)', 1]
['&& CHECK_REPLY_INT_OR_STR(els[offset+3])   //prev_id - time', 1]
['ERR("can\'t allocate memory for IPC write buffer overflow");', 1]
['while (r->ridx >= 0) {', 1]
['deleted_count = 0;', 1]
['if (!cmp_read_str_size(ctx, &str_size))', 1]
['assert(p != NULL);', 1]
['if (initlen && init)', 1]
['ac->ev.delRead = redisLibevDelRead;', 1]
['* context will be set to the return value of the error function.', 1]
["msg.id=('%i:%i'):format(msg.time, msg.tag)", 1]
['obj->type = CMP_TYPE_SINT32;', 1]
['if (sh == NULL) return NULL;', 1]
['bool cmp_write_ext8(cmp_ctx_t *ctx, int8_t tp, uint8_t sz, const void *data) {', 1]
['if (!cmp_read_fixext1_marker(ctx, type))', 1]
["local time, tag, prev_time, prev_tag, data, content_type, es_event = unpack(redis.call('HMGET', key, 'time', 'tag', 'prev_time', 'prev_tag', 'data', 'content_type', 'eventsource_event'))", 1]
['ch->msg_first = msg;', 1]
['assert(chead->msg_last == shmsg_link);', 1]
['c -= a; c -= b; c ^= ( b >> 5 );                                               \\', 1]
['chains[3].next = NULL;', 1]
['if (nread == -1) {', 1]
['#if _MSC_VER >= 1600 && defined(__cplusplus)  /* VS2010 or newer in C++ mode */', 1]
['msglen = 0;', 1]
['sdsrange(y,1,100);', 1]
['CMP_TYPE_STR16,           /* 28 */', 1]
['/* Type will be error or status. */', 1]
['DBG("%p reserve for req %p, reservations: %i", self, fsub->sub.request, self->reserved);', 1]
['static ngx_command_t  nchan_commands[] = {', 1]
["redis.call('EXPIRE', key.time_offset, channel.ttl)", 1]
['data.shm_chid= str_shm_copy(chid);', 1]
['c = _p-1;', 1]
['thing->id.data = (u_char *)(&whole[1]);', 1]
['ELMT_FROM_HH((head)->hh.tbl,_hs_e) : NULL);          \\', 1]
['n.table[h] = he;', 1]
['ngx_int_t stop_spooler(channel_spooler_t *spl, uint8_t dequeue_subscribers);', 1]
['va_arg(ap,int); /* short gets promoted to int */', 1]
['case SUB_CHANNEL_AUTHORIZED:', 1]
['int ridx; /* Index of current read task */', 1]
['ngx_uint_t                         max_messages;', 1]
['if (!cmp_write_str8_marker(ctx, size))', 1]
['ngx_int_t            time_int, ttl;', 1]
['out=NULL;                                                                      \\', 1]
['if (ctx->read(ctx, data, 1))', 1]
['"    msg.prev_tag or 0,\\n"', 1]
['(*argc)++;', 1]
['e.flushed = 1;', 1]
['uint16_t       code_net;', 1]
['ngx_free(node);', 1]
['EXAMPLES=hiredis-example hiredis-example-libevent hiredis-example-libev', 1]
['newlen *= 2;', 1]
['* end of the string. However the string is binary safe and can contain', 1]
['ngx_int_t internal_subscriber_set_dequeue_handler(subscriber_t *sub, callback_pt handler);', 1]
['ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "nchan: unable to allocate memory for Content Type header in pool");', 1]
['nchan_store_chanhead_publish_message_generic(d->chanhead, msg, 0, &cf, NULL, NULL);', 1]
['bool cmp_object_is_uint(cmp_object_t *obj) {', 1]
['int redisKeepAlive(redisContext *c, int interval);', 1]
['cd $(INSTALL_LIBRARY_PATH) && ln -sf $(DYLIB_MAJOR_NAME) $(DYLIBNAME)', 1]
["* in the 'to' array.", 1]
['if (head.hh_head) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,head.hh_head));          \\', 1]
['sz = group->len + 1 + tmpid.len;', 1]
['uint32_t cmp_mp_version(void) {', 1]
['sds sdscatprintf(sds s, const char *fmt, ...);', 1]
['(head)->hh.tbl->hho)) : NULL);                         \\', 1]
['STR_DATA_LENGTH_TOO_LONG_ERROR,', 1]
['d->channel_id=(ngx_str_t *)&d[1];', 1]
['#ifndef __DICT_H', 1]
['(head)->hh.tbl->hho))->next = (delptr)->hh.next;             \\', 1]
['if(create_complex_value_from_ngx_str(cf, &conf->last_message_id.cv[1], &second_choice_msgid) == NGX_CONF_ERROR) {', 1]
['#define dictSetHashKey(ht, entry, _key_) do { \\', 1]
['typedef struct dictEntry {', 1]
['obj->type = CMP_TYPE_EXT8;', 1]
['struct ev_loop *loop;', 1]
['bool cmp_read_u32(cmp_ctx_t *ctx, uint32_t *i);', 1]
['static ngx_chain_t *websocket_frame_header_chain(full_subscriber_t *fsub, const u_char opcode, off_t len) {', 1]
['void *internal_subscriber_get_privdata(subscriber_t *sub) {', 1]
['#endif /*NCHAN_REAPER_H*/', 1]
['nchan_set_msgid_http_response_headers(r, &fsub->data.multimsg_last->msg->id);', 1]
['REAL_LDFLAGS+= -ldl -lnsl -lsocket', 1]
['d->channel_info = head->shared;', 1]
['(head)->hh.tbl->signature = HASH_SIGNATURE;                                    \\', 1]
['DBG("found my procslot (ngx_process_slot %i, procslot %i)", ngx_process_slot, i);', 1]
['x = sdscpy(x,"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk");', 1]
['DBG("IPC: received get_message reply for channel %V msg %p privdata %p", d->shm_chid, d->d.resp.shm_msg, d->privdata);', 1]
['def initialize(channel_id, arg={})', 1]
['else if(cf->msg_in_etag_only && (if_none_match = nchan_subscriber_get_etag(r)) != NULL) {', 1]
['assert(msg_reserve(shm_msg, "publish_message") == NGX_OK);', 1]
['//publish', 1]
['chan_info->last_published_msg_id = chan->last_published_msg_id;', 1]
['nchan_store_channel_head_t     *churn_next;', 1]
['ERR("can\'t allocate shared memory for (new) chanhead");', 1]
['if(min->time < id->time || (min->time == id->time && min->tag.fixed[0] <= id->tag.fixed[0])) {', 1]
['p->handle.data = p;', 1]
['test("Format command with %%b string interpolation: ");', 1]
['static void callbackValDestructor(void *privdata, void *val) {', 1]
['//DBG("finished writing %i alerts.", proc->wbuf.n);', 1]
['"    dbg(\\"new channel\\")\\n"', 1]
['ngx_http_finalize_request(r, NGX_HTTP_FORBIDDEN);', 1]
['uint8_t         code;', 1]
['//unsubscribe now', 1]
['head->latest_msgid.tag.allocd = ngx_alloc(sizeof(*head->latest_msgid.tag.allocd) * n, ngx_cycle->log);', 1]
['CMP_TYPE_SINT32,          /* 20 */', 1]
['#define NGX_HTTP_GONE 410', 1]
['ngx_free(overflow);', 1]
['vector = realloc(vector,((*argc)+1)*sizeof(char*));', 1]
['if(force_delete || ngx_time() - cur->time > NCHAN_CHANHEAD_EXPIRE_SEC) {', 1]
['code((ngx_http_script_engine_t *) &e);', 1]
['ngx_int_t memstore_ipc_send_subscribe(ngx_int_t dst, ngx_str_t *chid, nchan_store_channel_head_t *origin_chanhead, nchan_loc_conf_t *cf) {', 1]
['bc->buf.flush = 1;', 1]
['ngx_memzero(&fsub->ping_ev, sizeof(fsub->ping_ev));', 1]
['redis_get_message_data_t           *d=NULL;', 1]
['if (NULL == glob) {', 1]
['//input:  keys: [message_key], values: []', 1]
["//EventStream really isn't designed for large chunks of data", 1]
['cf.max_messages = head->max_messages;', 1]
['do {                 \\', 1]
['} UT_hash_table;', 1]
['void(redisAsyncContext *c, void *reply, void *privdata);', 1]
['#ifdef _MSC_VER         /* MS compiler */', 1]
['*ht = n;', 1]
['int argc = 0;', 1]
['WEBSOCKET,', 1]
['fsub->sub.cf = &dummy_config;', 1]
['test_cond(strncmp(cmd,"*2\\r\\n$12\\r\\nkey:00000123\\r\\n$9\\r\\nstr:hello\\r\\n",len) == 0 && \\', 1]
['//     test_cond(__test_callback_flags == 0x0201);', 1]
["fn_buf[filename->len]='\\0';", 1]
['NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3|NGX_CONF_TAKE4|NGX_CONF_TAKE5,', 1]
['case RBTREE_WALK_LEFT_RIGHT:', 1]
['mpt->workers = workers;', 1]
['static ngx_int_t websocket_send_close_frame(full_subscriber_t *fsub, uint16_t code, ngx_str_t *err) {', 1]
['BIN16_MARKER           = 0xC5,', 1]
['msgid = &channel->last_published_msg_id;', 1]
['if(id == NULL && fail_hard) {', 1]
['"active subscribers: %ui" CRLF', 1]
['aeDeleteFileEvent(loop,e->fd,AE_WRITABLE);', 1]
['const  ngx_str_t NCHAN_ALLOW_GET_OPTIONS= ngx_string("GET, OPTIONS");', 1]
['content_type->len= off + 1 + subtypes[i].len;', 1]
['//set up write connection', 1]
['OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,', 1]
['bool cmp_write_array16(cmp_ctx_t *ctx, uint16_t size);', 1]
['return;                                         \\', 1]
['sts = "INACTIVE";', 1]
['shm_data_t         *d;', 1]
['redisAsyncHandleWrite(p->context);', 1]
["//shouldn't happen", 1]
['if (!write_type_marker(ctx, S8_MARKER))', 1]
['&longpoll_enqueue,', 1]
['h = ngx_crc32_short(id->data, id->len);', 1]
['unsigned                        http_chunked:1;', 1]
['//input:  keys: [], values: [channel_id, status_code]', 1]
['nchan_free_msg_id(&ch->oldest_msgid);', 1]
['//ttl', 1]
['size += ngx_buf_size(chains[1].buf);', 1]
['for((el)=(head),(tmp)=DECLTYPE(el)((head)?(head)->hh.next:NULL);                 \\', 1]
['d->sub->fn->respond_status(d->sub, NGX_HTTP_FORBIDDEN, NULL);', 1]
['d->cb(code, &d->chinfo, d->pd);', 1]
['rbtree_seed_t        *seed = &spl->spoolseed;', 1]
['[IPC_SUBSCRIBER_KEEPALIVE] =        (ipc_handler_pt )receive_subscriber_keepalive,', 1]
['obj->as.bin_size = be16(obj->as.u16);', 1]
["redis.call('HSET', key.channel, 'time', msg.time)", 1]
['{ ngx_string("push_subscriber"), //legacy for nchan_subscriber', 1]
['fsub->cln->data = fsub;', 1]
['shdata->procslot[offset] = slot;', 1]
['msg = &blob->msg;', 1]
['//serialize_chanhead_msgs_for_reload(cur);', 1]
['DBG("%p (%V) memstore-ipc subscriber created with privdata %p", d->sub, d->chid, d);', 1]
['if (wev->timedout) {', 1]
['r->keepalive=0; //apparently, websocket must not use keepalive.', 1]
['dictRelease(ac->sub.channels);', 1]
['const ngx_str_t  NCHAN_CONTENT_TYPE_TEXT_PLAIN = ngx_string("text/plain");', 1]
['"if channel~=nil then\\n"', 1]
['#include <adapters/libuv.h>', 1]
['ngx_memcpy(cur_out, cur, ret - cur);', 1]
['ngx_http_core_loc_conf_t       *clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);', 1]
['ngx_int_t internal_subscriber_destroy(subscriber_t *sub) {', 1]
['publish_msg->prev_id.time = 0;', 1]
['} /* extern "C" */', 1]
['ngx_str_t       *tmp;', 1]
['newsh->free = newlen - len;', 1]
['uv_poll_t          handle;', 1]
['msg.id.tagactive=0;', 1]
['redisLibevEvents *e;', 1]
['//#define ONE_FAKE_CHANNEL_OWNER 2', 1]
['redis_channel_callback_data_t *d=(redis_channel_callback_data_t *)privdata;', 1]
['return h % MAX_FAKE_WORKERS;', 1]
['d->channel_id->len = channel_id->len;', 1]
['nchan_store_memory.init_module(cycle);', 1]
['struct nchan_msg_s             *dbg_prev;', 1]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_GETFL)");', 1]
['} spooler_respond_data_t;', 1]
['buf->start = (u_char *)&buf[1];', 1]
['callback_pt     cb;', 1]
['msgstart = buf->pos;', 1]
['"No Error",', 1]
['ngx_str_t           id; //response id', 1]
['return fsub->notify(code, data, fsub->privdata);', 1]
['urnode->smallmsg.data = NULL;', 1]
['"return { msg.tag, {tonumber(channel.ttl or msg.ttl), tonumber(channel.time or msg.time), tonumber(channel.fake_subscribers or channel.subscribers or 0), tonumber(num_messages)}, new_channel}",', 1]
['bool cmp_write_fixstr_marker(cmp_ctx_t *ctx, uint8_t size) {', 1]
['msg->prev_id.time = time_int;', 1]
['msg = getmsg randid, "1200:0"', 1]
['ngx_memcpy(&conf->pub_chid, &prev->pub_chid, sizeof(prev->pub_chid));', 1]
['test("Format command with %%s string interpolation: ");', 1]
['#define NCHAN_DEFAULT_SHM_SIZE 33554432 //32 megs', 1]
['struct nchan_loc_conf_s { //nchan_loc_conf_t', 1]
['rd.last_seen = ch->last_seen;', 1]
['bool cmp_read_pfix(cmp_ctx_t *ctx, uint8_t *c) {', 1]
['c->read->log = cycle->log;', 1]
['if(ngx_strncmp(cur+sizeof("text/")-1, "plain", rem<5 ? rem : 5)==0) {', 1]
['//     return redisConnectNonBlock("127.0.0.1", port, NULL);', 1]
['static double bedouble(double x) {', 1]
["cur[0] = '/';", 1]
['nchan_OPTIONS_respond(r, &cf->allow_origin, &NCHAN_ACCESS_CONTROL_ALLOWED_SUBSCRIBER_HEADERS, &NCHAN_ALLOW_GET_OPTIONS);', 1]
['static void subscriber_authorize_timer_callback_handler(ngx_event_t *ev) {', 1]
['if(CHECK_REPLY_ARRAY_MIN_SIZE(reply, 2)) {', 1]
['va_start(ap, fmt);', 1]
['if (!cmp_write_str16_marker(ctx, size))', 1]
['return cmp_write_ext16_marker(ctx, tp, sz);', 1]
['long elements;', 1]
['uint32_t cmp_version(void) {', 1]
['if(ngx_strncmp(start, subtypes[i].subtype, rem<subtypes[i].len ? rem : subtypes[i].len)==0) {', 1]
['const char *field = "redis_version:";', 1]
['return `REDIS_ERR`. The function to set the disconnect callback has the following prototype:', 1]
['redisReaderFeed(reader,(char*)"*1\\r\\n",4);', 1]
['--[[', 1]
['HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ],  \\', 1]
[':nchan_set_sub_channel_id,', 1]
['"local create_channel_ttl=tonumber(ARGV[5]) or 0\\n"', 1]
['ngx_msec_t                    t;', 1]
['"    dbg(\\"no msg id given, ord=\\"..no_msgid_order)\\n"', 1]
['static long long readLongLong(char *s) {', 1]
['HASH_ADD(hh,head,intfield,sizeof(int),add)', 1]
['if(proc->c) {', 1]
['"-- finds and return the info hash of a channel, or nil of channel not found\\n"', 1]
['#define HASH_REPLACE_STR(head,strfield,add,replaced)                             \\', 1]
['fsub->notify = empty_callback;', 1]
['"-- redis doesn\'t do includes. It could be generated pre-insertion into redis, \\n"', 1]
['[:loc_conf, :authorize_request_url],', 1]
['remsg.temp_allocd = 0;', 1]
['if(shdata->procslot[i] == ngx_process_slot) {', 1]
['if((rc = ngx_http_send_header(r)) >= NGX_HTTP_SPECIAL_RESPONSE) {', 1]
["r->errstr[len] = '\\0';", 1]
['"    break\\n"', 1]
['static ngx_int_t redisReply_to_int(redisReply *el, ngx_int_t *integer) {', 1]
['set_buffer(&buf, frame->header, NULL, 8);', 1]
['websocket_send_frame(fsub, WEBSOCKET_PING_LAST_FRAME_BYTE, 0);', 1]
['head->last_msgid.time = msg->id.time;', 1]
['if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {', 1]
['{ ngx_string("nchan_channel_id1"),        nchan_channel_id_variable, 0},', 1]
['if (! (head)->hh.tbl->buckets) { uthash_fatal( "out of memory"); }             \\', 1]
['fsub->dequeue_handler = empty_handler;', 1]
['head->channel.last_published_msg_id.time=0;', 1]
['newarg = curarg;', 1]
['"Protocol error, got %s as reply type byte", cbuf);', 1]
['redisAsyncContext *c = rdt.ctx;', 1]
['nchan_authorize_request [:srv, :loc, :if],', 1]
['//what msgids do we want?', 1]
['ngx_memcpy(&d->msg_id, msg_id, sizeof(*msg_id));', 1]
['buf->last=last;', 1]
['ch->channel.subscribers += n;', 1]
['/* Connect to target given by config. */', 1]
['if (!write_type_marker(ctx, U16_MARKER))', 1]
['void rds_ctx_teardown(redisAsyncContext *ac) {', 1]
['static ngx_str_t               nullstring = ngx_null_string;', 1]
['#define NGX_RWLOCK_WRITE        -1', 1]
['//garbage collection for channel heads', 1]
['assert(id1->time == id2->time);', 1]
['assert(msg->buf == urnode->msg.buf);', 1]
['args: 1..5,', 1]
['DBG("%p (%V) dequeue sub", self, f->sub.name);', 1]
['snprintf(buf,64,"%d",j);', 1]
['publish_multi_data_t *pd;', 1]
['else if (type_marker == EXT16_MARKER) {', 1]
['while(ep > start && strchr(cset, *ep)) ep--;', 1]
['&websocket_fn,', 1]
['head->msg_last = NULL;', 1]
['#include <string.h>   /* memcmp,strlen */', 1]
['CMP_TYPE_ARRAY16,         /* 30 */', 1]
['#define HASH_CLEAR(hh,head)                                                      \\', 1]
['static char *nchan_subscriber_last_message_id(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {', 1]
['for (j = 0; j < l; j++) {', 1]
['uint16_t   i, max1 = id1->tagcount, max2 = id2->tagcount;', 1]
['str.data = (u_char *)body;', 1]
['legacy: "push_authorized_channels_only",', 1]
['static const u_char WEBSOCKET_PING_LAST_FRAME_BYTE  = WEBSOCKET_OPCODE_PING  | (WEBSOCKET_LAST_FRAME << 4);', 1]
['msg.prev_tag = 0', 1]
['if(page_size > ngx_pagesize) {', 1]
['ngx_int_t ipc_set_handler(ipc_t *ipc, void (*alert_handler)(ngx_int_t, ngx_uint_t , void *data));', 1]
['script: make && make check', 1]
['//set debug label', 1]
['rbtree_init(urs, "unique response verifier", urs_node_id, NULL, NULL);', 1]
['bool cmp_object_as_int(cmp_object_t *obj, int32_t *i) {', 1]
['ngx_del_timer(&rp->timer);', 1]
['if (val == 0) val = 1;', 1]
['@@hashes=  {}', 1]
['config.tcp.timeout.tv_usec = 0;', 1]
['time_t           mid_time; //optimization yeah', 1]
['* advance. Meaning the spawning logic must be copied to the T.', 1]
['//nchan_msg_id_t                 msg_id;', 1]
['if (redisCreateSocket(c,AF_LOCAL) < 0)', 1]
['oldid->tag.allocd[i] = (i < oldid->tagcount) ? oldtags[i] : -1;', 1]
['fsub->data.cln->data = self;', 1]
['ht->table[index] = entry;', 1]
['if (header[i].key.len == NCHAN_HEADER_IF_NONE_MATCH.len', 1]
['if(sz > 0) {', 1]
['chanhead_churner_add(head);', 1]
['if(spool->responded_shortlived_subs == 1) {', 1]
['static ngx_int_t websocket_frame_header(ngx_buf_t *buf, const u_char opcode, off_t len) {', 1]
['tokens[elements] = sdsnewlen(s+start,j-start);', 1]
['_hj_k -= 12;                                                                \\', 1]
['"Input value is too large",', 1]
["//eh, we didn't find a valid alt_msgid value from variables. use the defaults", 1]
['if ((s = socket(type, SOCK_STREAM, 0)) == -1) {', 1]
['head->spooler.fn->set_bulk_dequeue_handler(&head->spooler, spooler_bulk_dequeue_handler, head);', 1]
['ngx_log_error(NGX_LOG_WARN, ngx_cycle->log, 0, "rwlock %p write lock wait (reserved by %ui)", lock, lock->write_pid);', 1]
['if(owner != memstore_slot()) {', 1]
['static int __redisShiftCallback(redisCallbackList *list, redisCallback *target) {', 1]
['if(self->cf->subscriber_timeout > 0 && f->timeout_ev.timer_set) {', 1]
['nchan_channel_t       ch;', 1]
['return (ctx->write(ctx, &x, sizeof(uint8_t)) == (sizeof(uint8_t)));', 1]
['redisAsyncContext *redisAsyncConnect(const char *ip, int port) {', 1]
['ngx_memcpy(msg->content_type.data, els[offset+6]->str, content_type_len);', 1]
['__redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_SETFL)");', 1]
['static uint64_t ws_ntohll(uint64_t value) {', 1]
['static ngx_int_t es_enqueue(subscriber_t *sub) {', 1]
['//ngx_rbtree_node_t *actives[4096]; //super-heavy debugging', 1]
['if(lastid->time < msg->id.time ||', 1]
['* sds string without copying into an intermediate buffer:', 1]
['cur = rp->position == NULL ? rp->first : rp->position;', 1]
['sub_channel = (Hash === opt) ? (opt[:subscribe] || opt[:sub]) : nil', 1]
['return cmp_write_ext8_marker(ctx, tp, sz);', 1]
['static ipc_handler_pt ipc_alert_handler[] = {', 1]
['DBG("found message %V", msgid_to_str(&cur->next->msg->id));', 1]
['ngx_int_t memstore_ipc_send_get_message(ngx_int_t owner, ngx_str_t *shm_chid, nchan_msg_id_t *msgid, void * privdata);', 1]
['redisCallbackList replies;', 1]
['cf.max_messages = d->chanhead->max_messages;', 1]
['static void __redisAsyncDisconnect(redisAsyncContext *ac) {', 1]
['if(msgid->time == 0) {', 1]
["dbg(' ####### DELETE #######')", 1]
['nchan_output_shutdown();', 1]
['ERR("couldn\'t parse msgpacked message from redis");', 1]
['if (newsh == NULL) return NULL;', 1]
['//make both ends nonblocking', 1]
['sds sdsnew(const char *init) {', 1]
['*ret_id = id;', 1]
['dst->tagcount = src->tagcount;', 1]
['return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;', 1]
['bool cmp_read_str(cmp_ctx_t *ctx, char *data, uint32_t *size) {', 1]
['if(cur != NULL) {', 1]
['* hash distribution; reaching them in a chain traversal takes >ideal steps */', 1]
['def redis; @@redis; end', 1]
['ERR("Added message %p (%V) to %V", smsg, msgid_to_str(&smsg->msg->id), chid);', 1]
['ngx_str_t                      channel_id[NCHAN_MULTITAG_REQUEST_CTX_MAX];', 1]
['* http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx */', 1]
['/* Continue writing when not done, stop writing otherwise */', 1]
['ac->ev.delWrite = NULL;', 1]
['#define DBG(fmt, arg...) ngx_log_error(DEBUG_LEVEL, ngx_cycle->log, 0, "SUB:CHUNKED:" fmt, ##arg)', 1]
['hashv += (hashv << 10);                                                    \\', 1]
['a reply parser that is decoupled from the I/O layer. It', 1]
['ipc_writebuf_overflow_t  *overflow_first;', 1]
['assert(head->channel.subscribers >= 0);', 1]
['msg->dbg_next = shdata->msgdebug_head;', 1]
['static void its_reaping_time_keep_place(nchan_reaper_t *rp, uint8_t force) {', 1]
['if (prefix != NULL)', 1]
['c = ev->data;', 1]
['uniq_response_t    *urnode;', 1]
['ngx_conf_merge_bitmask_value(conf->pub.websocket, prev->pub.websocket, 0);', 1]
['ngx_init_set_membuf(data_prefix_buf, data_prefix.data, data_prefix.data + data_prefix.len);', 1]
['if(nchan_strmatch(val, LONGPOLL_STRINGS_N, LONGPOLL_STRINGS)) {', 1]
['else if (type_marker >= NEGATIVE_FIXNUM_MARKER) {', 1]
['#include <execinfo.h>', 1]
['static ngx_int_t memstore_reap_store_message( store_message_t *smsg );', 1]
['tc->gc_timer.data = tc;', 1]
['x = sdsnew("aar");', 1]
['`reply->elements`. Every element in the multi bulk reply is a `redisReply` object as well', 1]
['tv_usec is certainly positive. */', 1]
['/* Only continue when the buffer contains the entire bulk item. */', 1]
['obj->type = CMP_TYPE_BIN32;', 1]
['subscriber_type_t        subtype;', 1]
['void (*callback) (void *) = privdata;', 1]
['nchan_channel_t              *channel = (nchan_channel_t *)ch;', 1]
['} while(cur <= last);', 1]
['char                  *name;', 1]
['ngx_int_t msg_release(nchan_msg_t *msg, char *lbl) {', 1]
['//nchan_store_channel_head_t      unbuffered_dummy_chanhead;', 1]
['callbacks = ac->sub.patterns;', 1]
['"--input: keys: [], values: [channel_id, subscriber_id, empty_ttl]\\n"', 1]
['#ifndef uthash_expand_fyi', 1]
['(dst) = DECLTYPE(dst)(src);                                                    \\', 1]
['if store_at_most_n_messages == nil or store_at_most_n_messages == "" then', 1]
['free(vector);', 1]
['return redisFreeKeepFd(c);', 1]
['{ ngx_string("nchan_channel_id4"),        nchan_channel_id_variable, 3},', 1]
['CfCmd.new do', 1]
['msg = &stuff->msg;', 1]
['hdr_chain->next=NULL;', 1]
['const ngx_str_t NCHAN_HEADER_SEC_WEBSOCKET_KEY = ngx_string("Sec-WebSocket-Key");', 1]
['uint32_t    sz;', 1]
['ngx_del_timer(&fsub->ping_ev);', 1]
['match = rbtree_find_node(seed, seed->id(rbtree_data_from_node(cur)));', 1]
['if(ngx_buf_size(cur->msg->buf) > 0) {', 1]
['#define LONGPOLL_STRINGS "longpoll", "long-poll"', 1]
['error:', 1]
['const char* cmp_strerror(cmp_ctx_t *ctx);', 1]
['//switch(r->headers_out', 1]
['proc->wbuf.overflow_first = of->next;', 1]
['sts = "READY";', 1]
['if (start && newlen) memmove(sh->buf, sh->buf+start, newlen);', 1]
['if not msg.next then --this should have been taken care of by the channel.current_message check', 1]
['obj->type = CMP_TYPE_MAP16;', 1]
['uint32_t  str_size;', 1]
['redisReaderFeed(reader,(char*)"*2\\r\\n",4);', 1]
['memset(p, 0, sizeof(*p));', 1]
['ngx_int_t nchan_respond_membuf(ngx_http_request_t *r, ngx_int_t status_code, const ngx_str_t *content_type, ngx_buf_t *body, ngx_int_t finalize);', 1]
['proc->wbuf.n -= (i - first);', 1]
['uses customized reply object functions to create Ruby objects.', 1]
['} rdstore_data_t;', 1]
['#define NGX_POOL_SUMMARY_FORMAT "size:%10z%2s num:%12z cnum:%12z lnum:%12z [SUMMARY]\\n"', 1]
['if(ngx_strnstr(cur, "redis://", 8) != NULL) {', 1]
['head->spooler.fn->set_dequeue_handler(&head->spooler, spooler_dequeue_handler, head);', 1]
['"last message id: %V"', 1]
['static ngx_int_t rbtree_validate_node(rbtree_seed_t *seed, ngx_rbtree_node_t *node) {', 1]
['if (errno == EINPROGRESS)', 1]
['int tc = compare_msgid_time(&data->min, &data->max, &spool->id);', 1]
['ngx_buf_t                      *b;', 1]
['### Disconnecting', 1]
['if(conf->shm_size==NGX_CONF_UNSET_SIZE) {', 1]
['} ev;', 1]
['#define ERR(fmt, arg...) ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "SPOOL:" fmt, ##arg)', 1]
['r->request_body_file_log_level = 0;', 1]
['valid = 1;', 1]
['d->sub->fn->respond_status(d->sub, NGX_HTTP_FORBIDDEN, NULL); //auto-closes subscriber', 1]
['#include <netinet/tcp.h>', 1]
['bc[0].buf.start = chunk_start;', 1]
['nchan_store_channel_head_t    *chead;', 1]
['static nchan_llist_timed_t  ws_pub_head;', 1]
['if(ngx_strncmp(reply->str, script_error_start.data, script_error_start.len) == 0 && (unsigned ) reply->len > script_error_start.len + REDIS_LUA_HASH_LENGTH) {', 1]
['+-------------------------------+-------------------------------+', 1]
["case 'b': c = '\\b'; break;", 1]
['* up as soon as possible. */', 1]
['} nchan_channel_queue_t;', 1]
['connection is disconnected (either because of an error or per user request). This function should', 1]
['ngx_rbtree_t       tree;', 1]
['EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,', 1]
['bool cmp_object_as_uchar(cmp_object_t *obj, uint8_t *c);', 1]
['return dictGenHashFunction((const unsigned char *)key,', 1]
['"      end\\n"', 1]
['[:loc_conf, :channel_id_split_delimiter],', 1]
['ngx_int_t                       subscriber_start_at_oldest_message;', 1]
['bc[3].buf.memory = 1;', 1]
['"  --kick out old subscribers\\n"', 1]
['* s = sdsMakeRoomFor(s, BUFFER_SIZE);', 1]
['#define HASH_MAKE_TABLE(hh,head)                                                 \\', 1]
['if (chain->next != NULL) {', 1]
['ngx_memzero(&rp->timer, sizeof(rp->timer));', 1]
['#define NGX_RWLOCK_MUTEX_COND(lock, cond, stmt)   \\', 1]
['else if(cf->sub.poll) {', 1]
['ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "unable to create subscriber");', 1]
['"if not channel.ttl then\\n"', 1]
['memcpy(dstcb,dictGetEntryVal(de),sizeof(*dstcb));', 1]
['ngx_memzero(&tc->gc_timer, sizeof(tc->gc_timer));', 1]
['} cmp_ext_t;', 1]
['else if(request_body_chain!=NULL) {', 1]
['status_code = NGX_HTTP_NOT_MODIFIED;', 1]
['offsetof(nchan_loc_conf_t, websocket_ping_interval),', 1]
['redisLibevDelWrite(privdata);', 1]
['bool cmp_write_fixext4_marker(cmp_ctx_t *ctx, int8_t type);', 1]
['static ngx_inline void init_spool(channel_spooler_t *spl, subscriber_pool_t *spool, nchan_msg_id_t *id) {', 1]
['static bool cmp_to_str(cmp_ctx_t *cmp, ngx_str_t *str) {', 1]
['* will have the effect of turning the string "hello" into "0ell1".', 1]
['void sdsupdatelen(sds s) {', 1]
['subdebug_head->dbg_prev = sub;', 1]
['return vector;', 1]
['dictEntry *de, *prevde;', 1]
['#define CHECK_REPLY_STRNVAL(reply, v, n) ( CHECK_REPLY_STR(reply) && ngx_strncmp((reply)->str, v, n) == 0 )', 1]
['if(fsub->data.cln == NULL) {', 1]
['if(shdata->active_workers > 0) {', 1]
['if (newlen < SDS_MAX_PREALLOC)', 1]
[') <= 0) {                                           \\', 1]
['buf->last_buf= len == 0;', 1]
['//websocket headers', 1]
['return cmp_write_fixarray(ctx, size);', 1]
['chanhead_gc_add(head, "received UNSUBSCRIVED over ipc, sub_count == 0");', 1]
['"  eventsource_event=ARGV[5],\\n"', 1]
['ac->ev.delRead  = redisLibuvDelRead;', 1]
['/* Copy callback from stack to heap */', 1]
['#ifndef __sun', 1]
['bool cmp_write_str16(cmp_ctx_t *ctx, const char *data, uint16_t size) {', 1]
['ngx_msec_t   dt = ngx_current_msec - t;', 1]
['time_t          last_seen;', 1]
['static ngx_int_t spooler_respond_rbtree_node_spool(rbtree_seed_t *seed, subscriber_pool_t *spool, void *data) {', 1]
['return ctx->write(ctx, &c, sizeof(int8_t));', 1]
['if (cb != NULL) {', 1]
['channel.ttl=msg.ttl', 1]
['if (node->key != temp->key) {', 1]
['ngx_buf_t *buf = msg->buf;', 1]
['next = sub->dbg_next;', 1]
['bool cmp_object_is_str(cmp_object_t *obj) {', 1]
['test("Returns I/O error on socket timeout: ");', 1]
['ERR("nchan: invalid msgpack message from redis: %s", cmp_strerror(&cmp));', 1]
['if(ch->multi) {', 1]
['if (len <= curlen) return s;', 1]
['lcf->max_channel_subscribers=NGX_CONF_UNSET;', 1]
['if (pipe(socks) == -1) {', 1]
['local store_at_most_n_messages = ARGV[7]', 1]
['#include <store/memory/ipc.h>', 1]
['"Error reading packed data",', 1]
['nchan_free_msg_id(&msg->id);', 1]
['#define HASH_BLOOM_BITTEST(bv,idx) (bv[(idx)/8] & (1U << ((idx)%8)))', 1]
