['}', 77]
['{', 71]
['return -1;', 12]
['else', 7]
['free(mime);', 5]
['free(filename);', 5]
['return 1;', 5]
['free(path);', 5]
['exit(-1);', 5]
['free(extension);', 5]
['return 0;', 4]
['/**', 4]
['**/', 4]
['break;', 3]
['exit(EXIT_FAILURE);', 3]
['sendString("400 Bad Request\\n", connecting_socket);', 3]
['exit(1);', 3]
['return bytes_sent;', 2]
['parameterCount++;', 2]
['// Indicate that we want to jump over the next parameter', 2]
['count++;', 2]
['sendString("501 Not Implemented\\n", connecting_socket);', 2]
['//', 2]
['free(line);', 2]
['free(word_holder);', 2]
['free(current_word);', 2]
['for ( ; i < strlen(input); i ++ )', 2]
['type = 1;', 2]
['// RETURN -1', 2]
['fclose(fp);', 2]
['#include <sys/types.h>', 2]
['int count = 0;', 2]
['while ( 1 )', 2]
['else if ( strcmp("HTTP/1.0", output) == 0 )', 1]
['fp = fopen(path, "rb");', 1]
['if ( connecting_socket < 0 )', 1]
['memcpy(mime_type, current_word, strlen(current_word));', 1]
['exit(0);', 1]
['/* Create a new SID for the child process */', 1]
['if ( bind(current_socket, (struct sockaddr *)&address, sizeof(address)) < 0 )', 1]
['char* currentLine = malloc(100);', 1]
['int startline = 0;', 1]
['strlen(server_head) +', 1]
['if ((msgLen = recv(socket, buffer, BUFFER_SIZE, 0)) == -1)', 1]
['printf("Configuration file:\\t%s\\n", conf_file);', 1]
['void bindSocket()', 1]
['strcat(message, length_head);', 1]
['#include <stdlib.h>', 1]
['#define BUFFER_SIZE 512', 1]
['static void daemonize(void)', 1]
['socklen_t addr_size;', 1]
['directory from being locked; hence not being able to remove it. */', 1]
['fprintf(stderr, "Error in configuration file on line 1!\\n");', 1]
['// --- Workflow --- //', 1]
['char *line = malloc(200);', 1]
['output[appended_position] = input[i];', 1]
['// GoHttp is purely written for educational purposes', 1]
['// Setting default values', 1]
['int sendBinary(int *byte, int length)', 1]
['int current_char = 0;', 1]
['fprintf(stderr, "Error in configuration file on line 2!\\n");', 1]
['#include <sys/wait.h>', 1]
['char *log_file;', 1]
['sendBinary(&current_char, sizeof(char));', 1]
['exit(EXIT_SUCCESS);', 1]
['// IF NOT EXISTS', 1]
['// Calculate Content Length //', 1]
['int receive(int socket)', 1]
["if ( *(input + i ) != '\\t' && *(input + i) != ' ' && *(input + i) != '\\n' && *(input + i) != '\\r')", 1]
['sendString(message, socket);', 1]
['FILE *fp;', 1]
['char *current_word = malloc(600);', 1]
['else\t\t\t\t\t\t\t// GARBAGE', 1]
['start();', 1]
['strcat(message, (char*)ctime(&rawtime));', 1]
['current_socket = socket(AF_INET, SOCK_STREAM, 0);', 1]
['if ( getHttpVersion(input, httpVersion) != -1 )', 1]
['// 1. Receive ( recv() ) the GET / HEAD', 1]
['char *head = "\\r\\nHTTP/1.1 ";', 1]
['char *newline = "\\r\\n";', 1]
['#include <pthread.h>', 1]
['strcat(message, newline);', 1]
['rewind(fp);', 1]
['int appending_char_count = 0;', 1]
['perror("Accepting sockets");', 1]
['if ( current_socket == -1 )', 1]
['if ( mimeSupported != 1)', 1]
['char *mime = (char*)malloc(200 * sizeof(char));', 1]
['void initConfiguration()', 1]
['log_file = (char*)argv[parameterCount];', 1]
['#define EXIT_FAILURE 1', 1]
['connecting_socket = accept(current_socket, (struct sockaddr *)&connector, &addr_size);', 1]
['strlen(Content_Type) +', 1]
['// int child_process = fork();', 1]
['struct sockaddr_storage connector;', 1]
['strcat(message, content_head);', 1]
['printf("Setting port to %i\\n", atoi(argv[parameterCount]));', 1]
['sizeof(char)) * 2);', 1]
['if ( in_position == 1 )', 1]
['// freopen( "/dev/null", "r", stdin);', 1]
['#define EXIT_SUCCESS 0', 1]
['char *path = (char*)malloc(1000 * sizeof(char));', 1]
['// 2. Process the request and see if the file exists', 1]
['if (fscanf(filePointer, "%s %s", currentLine, wwwroot) != 2)', 1]
['if (strcmp(argv[parameterCount], "-p") == 0)', 1]
['char *requestType = malloc(5);', 1]
['// RETURN 1 IF GET', 1]
['int appended_position = 0;', 1]
['char *length_head = "\\r\\nContent-Length: ";', 1]
['filesize = ftell(fp);', 1]
['int length, bytes_sent;', 1]
['log_file = ".log";', 1]
['wwwroot = malloc(100);', 1]
['strlen(contentLength) +', 1]
['printf("\\t\\t-d\\t\\tEnables deamon mode.\\n");', 1]
['if (sid < 0) {', 1]
['if ( listen(current_socket, MAX_CONNECTIONS) < 0 )', 1]
['/*', 1]
['char *httpVersion = (char*)malloc(20 * sizeof(char));', 1]
['void sendHeader(char *Status_code, char *Content_Type, int TotalSize, int socket)', 1]
["memset (buffer,'\\0', BUFFER_SIZE);", 1]
['strlen(length_head) +', 1]
['int contentLength = 0;', 1]
['address.sin_port = htons(port);', 1]
['strcat(message, contentLength);', 1]
['sendString(char *message, int socket)', 1]
['if ( getppid() == 1 ) return;', 1]
['printf("Port:\\t\\t\\t%i\\n", port);', 1]
['int scan(char *input, char *output, int start, int max)', 1]
['#include <sys/socket.h>', 1]
['// IF NOT VALID REQUEST', 1]
['// Get server root directory from configuration file', 1]
['// DO NOT USE IN PRODUCTION!', 1]
['FILE *filePointer = NULL;', 1]
['strcat(path, filename);', 1]
['bytes_sent = send(connecting_socket, byte, length, 0);', 1]
['if ( type == 1 && strcmp("GET", requestType) == 0)', 1]
['Create a socket and assign current_socket to the descriptor', 1]
['if ( strcmp("HTTP/1.1" , output) == 0 )', 1]
['return filesize;', 1]
['if(count < max)', 1]
['printf("Mime not supported");', 1]
['for (parameterCount = 1; parameterCount < argc; parameterCount++)', 1]
["memset(filename, '\\0', 200);", 1]
['mime_file = malloc(600);', 1]
['/* Change the current working directory.  This prevents the current', 1]
['else if (strlen(input) > 4 && strcmp("POST", requestType) == 0 )', 1]
['#define MAX_FILE_SIZE 5*1024', 1]
['char *mime_file;', 1]
['printf("File extension not existing");', 1]
["memset(extension, '\\0', 10);", 1]
['strcat(message, date_head);', 1]
['if ( deamon == TRUE )', 1]
['pid = fork();', 1]
['free(mime_type);', 1]
['daemonize();', 1]
['startline = scan(line, current_word, 0, 600);', 1]
['conf_file = "httpd.conf";', 1]
['time_t rawtime;', 1]
['void sendFile(FILE *fp, int file_size)', 1]
['strcat(message, Status_code);', 1]
['// 3. Read the file content', 1]
['char *wwwroot;', 1]
['printf("Unable to open file");', 1]
['contentLength = Content_Lenght(fp);', 1]
['else if (strcmp(argv[parameterCount], "-d") == 0)', 1]
['acceptConnection();', 1]
['printf("Logfile:\\t\\t%s\\n", log_file);', 1]
['#include <stdio.h>', 1]
['strcpy(mime_file, "mime.types");', 1]
['if ( startline != -1 )', 1]
['if ( GetExtension(filename, extension, 10) == -1 )', 1]
['if ( strlen ( input ) > 0 )', 1]
['printf("Error handling incoming request");', 1]
['addr_size = sizeof(connector);', 1]
['if ( message != NULL )', 1]
['perror("Create socket");', 1]
['strcat(message, Content_Type);', 1]
['int GetExtension(char *input, char *output, int max)', 1]
['int start = scan(input, filename, 4, 100);', 1]
['fclose(filePointer);', 1]
['char *message = malloc((', 1]
['char *content_head = "\\r\\nContent-Type: ";', 1]
['// Open the requesting file as binary //', 1]
['startline = scan(line, word_holder, startline, 600);', 1]
['int parameterCount;', 1]
['log_file = malloc(100);', 1]
['else if ( request == 2 )\t\t// HEAD', 1]
['handle(connecting_socket);', 1]
['return i;', 1]
['int fileNameLenght = 0;', 1]
['int i = 0;', 1]
['close(connecting_socket);', 1]
['// Send File Content //', 1]
["*(output + appending_char_count) = '\\0';", 1]
['#define FALSE 0', 1]
["memset (mime_type,'\\0',200);", 1]
['int getRequestType(char *input)', 1]
['deamon = FALSE;', 1]
['printf("Server root:\\t\\t%s\\n", wwwroot);', 1]
['sendFile(fp, contentLength);', 1]
['printf("Setting logfile = %s\\n", argv[parameterCount]);', 1]
['free(message);', 1]
['if (receive((int)socket) < 0)', 1]
['do{', 1]
['createSocket();', 1]
['printf("Settings:\\n");', 1]
['if ( strlen(output) > 0 )', 1]
['strlen(Status_code) +', 1]
['perror("Receive");', 1]
['bytes_sent = send(socket, message, length, 0);', 1]
['address.sin_family = AF_INET;', 1]
['int connecting_socket;', 1]
['printf("\\t\\t-p port\\t\\tWhich port to listen to.\\n");', 1]
['strlen(newline) +', 1]
['if (filePointer == NULL)', 1]
['// freopen( "/dev/null", "w", stdout);', 1]
['// RETURN 0 IF NOT YET IMPLEMENTED', 1]
['strcpy(path, wwwroot);', 1]
['type = -1;', 1]
['while(fgets(line, 200, mimeFile) != NULL) {', 1]
['perror("Listen on port");', 1]
['if ( start >= strlen(input) )', 1]
['handleHttpGET(buffer);', 1]
['void startListener()', 1]
['fseek(fp, 0, SEEK_END);', 1]
['scan(input, requestType, 0, 5);', 1]
['appended_position +=1;', 1]
['// RETURN 2 IF HEAD', 1]
['if (pid > 0) {', 1]
['// If flag -p is used, set port', 1]
['int mimeSupported = 0;', 1]
['// IF VALID REQUEST', 1]
['// RETURN 1', 1]
['#include <string.h>', 1]
['strlen(date_head) +', 1]
['*(output + appending_char_count) = *(input + i ) ;', 1]
['mimeSupported =  checkMime(extension, mime);', 1]
['/* Change the file mode mask */', 1]
['void createSocket()', 1]
['sendString("404 Not Found\\n", connecting_socket);', 1]
['else if (strcmp(argv[parameterCount], "-l") == 0)', 1]
['char *extension = (char*)malloc(10 * sizeof(char));', 1]
['// SendHeader();', 1]
["if ( line[0] != '#' )", 1]
['appending_char_count += 1;', 1]
['// Set deamon to FALSE', 1]
['filePointer = fopen(conf_file, "r");', 1]
['else if (type == 1 && strcmp("HEAD", requestType) == 0)', 1]
['if ( child_process == 0 )', 1]
['if ( strcmp ( word_holder, extension ) == 0 )', 1]
['int bytes_sent;', 1]
['strlen(head) +', 1]
["if ( input[i] == '.' )", 1]
['FILE *mimeFile = fopen(mime_file, "r");', 1]
['sendHeader(statusCode, contentType, size, socket);', 1]
['if ( scan(input, output, start, 20) )', 1]
['int Content_Lenght(FILE *fp)', 1]
['for (; i < strlen(input); i ++ )', 1]
['void sendHTML(char *statusCode, char *contentType, char *content, int size, int socket)', 1]
['char *filename = malloc(100);', 1]
['// 4. Send out with correct mine and http 1.1', 1]
['printf("Usage: %s [-p port] [-d] [-l logfile]\\n", argv[0]);', 1]
['char *conf_file;', 1]
['#define TRUE 1', 1]
['sid = setsid();', 1]
['if ( start > 0 )', 1]
['if ( request == 1 )\t\t\t\t// GET', 1]
['time ( &rawtime );', 1]
['#include <netinet/in.h>', 1]
['char *word_holder = malloc(600);', 1]
['// int contentLength = strlen(HTML);', 1]
['Handles the current connector', 1]
['void handle(int socket)', 1]
['void start()', 1]
['in_position = 1;', 1]
['int msgLen = 0;', 1]
['type = 2;', 1]
['char* mime_type = malloc(800);', 1]
['int i = start;', 1]
['int checkMime(char *extension, char *mime_type)', 1]
['// freopen( "/dev/null", "w", stderr);', 1]
['#define MAX_CONNECTIONS 3', 1]
['if ((chdir("/")) < 0) {', 1]
['printf("Setting deamon = TRUE");', 1]
['int handleHttpGET(char *input)', 1]
['char *server_head = "\\r\\nServer: PT06";', 1]
['length = strlen(message);', 1]
['else if ( request == 0 )\t\t// POST', 1]
['// Get default port from configuration file', 1]
['Bind to the current_socket descriptor and listen to the port in PORT', 1]
['current_char = fgetc(fp);', 1]
['if ( fileNameLenght > 0 )', 1]
['deamon = TRUE;', 1]
["memset(mime, '\\0', 200);", 1]
['sprintf(contentLength, "%i", TotalSize);', 1]
['// If flag -d is used, set deamon to TRUE;', 1]
['startListener();', 1]
['init();', 1]
['int main(int argc, char* argv[])', 1]
['// signal(SIGCHLD, SIG_IGN);', 1]
["output[appended_position+1] = '\\0';", 1]
['int deamon = FALSE;', 1]
['pid_t pid, sid;', 1]
['strcat(message, server_head);', 1]
['sendString(content, socket);', 1]
['if (count < (max-1))', 1]
['// Find next word start', 1]
["memset(httpVersion, '\\0', 20);", 1]
['// IF EXISTS', 1]
['char* fileExt = malloc(10);', 1]
['/* If we got a good PID, then we can exit the parent process. */', 1]
['mime_type = (char*)malloc(200);', 1]
['bindSocket();', 1]
['Start listening for connections and accept no more than MAX_CONNECTIONS in the Quee', 1]
['fprintf(stderr, "Can\'t open configuration file!\\n");', 1]
['#include <sys/stat.h>', 1]
['if (contentLength  < 0 )', 1]
['if (pid < 0) {', 1]
['int getHttpVersion(char *input, char *output)', 1]
['if (fscanf(filePointer, "%s %i", currentLine, &port) != 2)', 1]
['if ( fp == NULL )', 1]
['int in_position = 0;', 1]
['char contentLength[100];', 1]
['struct sockaddr_in address;', 1]
['perror("Bind to port");', 1]
['int type = -1;', 1]
['address.sin_addr.s_addr = INADDR_ANY;', 1]
['/* already a daemon */', 1]
['while (-1 != waitpid (-1, NULL, WNOHANG));', 1]
['printf("File size is zero");', 1]
['printf("Deamon:\\t\\t\\t%i\\n", deamon);', 1]
['/* Fork off the parent process */', 1]
['char *filename = (char*)malloc(200 * sizeof(char));', 1]
['while(current_char != EOF);', 1]
['void init()', 1]
['conf_file = malloc(100);', 1]
['char *date_head = "\\r\\nDate: ";', 1]
["memset (line,'\\0',200);", 1]
['char buffer[BUFFER_SIZE];', 1]
['28 +', 1]
['*/\t\t// while (-1 != waitpid (-1, NULL, WNOHANG));', 1]
["if ( *(input + i) != '\\t' && *(input + i) != ' ' && *(input + i) != '\\n' && *(input + i) != '\\r')", 1]
['void acceptConnection()', 1]
['/* Redirect standard files to /dev/null */', 1]
['sendHeader("200 OK", mime,contentLength, connecting_socket);', 1]
['printf("\\t\\t-l logfile\\tWhich file to store the log to.\\n");', 1]
['fileNameLenght = scan(input, filename, 5, 200);', 1]
['free(currentLine);', 1]
['int current_socket;', 1]
['/* At this point we are executing as the child process */', 1]
['i += 1;', 1]
['port = atoi(argv[parameterCount]);', 1]
['int port;', 1]
['// Ensure that the configuration file is open', 1]
['strlen(content_head) +', 1]
['strcpy(message, head);', 1]
['int request = getRequestType(buffer);', 1]
['umask(0);', 1]
["output[strlen(output)+1] = '\\0';", 1]
['return type;', 1]
['type = 0;', 1]
["memset(path, '\\0', 1000);", 1]
['int filesize = 0;', 1]
