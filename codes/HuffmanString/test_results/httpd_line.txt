['}', 37]
['{', 29]
['send(client, buf, strlen(buf), 0);', 27]
['/**********************************************************************/', 25]
['char buf[1024];', 9]
['numchars = get_line(client, buf, sizeof(buf));', 6]
['send(client, buf, sizeof(buf), 0);', 5]
['return;', 5]
['else', 5]
['sprintf(buf, "\\r\\n");', 4]
['while ((numchars > 0) && strcmp("\\n", buf))  /* read & discard headers */', 3]
['cannot_execute(client);', 3]
['cgi = 1;', 3]
['sprintf(buf, "Content-Type: text/html\\r\\n");', 3]
['*/', 2]
['int numchars = 1;', 2]
['fgets(buf, sizeof(buf), resource);', 2]
['sprintf(buf, "Content-type: text/html\\r\\n");', 2]
["buf[0] = 'A'; buf[1] = '\\0';", 2]
['if (strcasecmp(method, "GET") == 0)', 2]
['i++; j++;', 2]
['not_found(client);', 2]
['close(cgi_input[1]);', 2]
['sprintf(buf, SERVER_STRING);', 2]
['if (strcasecmp(method, "POST") == 0)', 2]
['/* DEBUG printf("%02X\\n", c); */', 2]
['query_string++;', 2]
['sprintf(buf, "</BODY></HTML>\\r\\n");', 2]
["c = '\\n';", 2]
['close(cgi_output[0]);', 2]
['if (!cgi)', 1]
['for (i = 0; i < content_length; i++) {', 1]
['void cannot_execute(int);', 1]
['sprintf(buf, "HTTP/1.0 400 BAD REQUEST\\r\\n");', 1]
['} else {    /* parent */', 1]
['void accept_request(int client)', 1]
['* Parameters: client socket */', 1]
['* return.  Process the request appropriately.', 1]
['sprintf(meth_env, "REQUEST_METHOD=%s", method);', 1]
['int server_sock = -1;', 1]
['name.sin_addr.s_addr = htonl(INADDR_ANY);', 1]
['* Parameters: pointer to variable containing the port to connect on', 1]
['query_string = url;', 1]
['if (*port == 0)  /* if dynamically allocating a port */', 1]
['void execute_cgi(int, const char *, const char *, const char *);', 1]
['(void)filename;  /* could use filename to determine file type */', 1]
['*             path to the CGI script */', 1]
['*  2) Comment out the line that defines the variable newthread.', 1]
['sprintf(buf, "your request because the resource specified\\r\\n");', 1]
['if ( (pid = fork()) < 0 ) {', 1]
['* on a specified port.  If the port is 0, then dynamically allocate a', 1]
['* errors to client if they occur.', 1]
['else {   /* POST */', 1]
['if (content_length == -1) {', 1]
['name.sin_family = AF_INET;', 1]
['close(cgi_output[1]);', 1]
['write(cgi_input[1], &c, 1);', 1]
['if (strcasecmp(buf, "Content-Length:") == 0)', 1]
['#include <sys/types.h>', 1]
['int cgi_output[2];', 1]
['putenv(length_env);', 1]
['(struct sockaddr *)&client_name,', 1]
["method[i] = '\\0';", 1]
['if ((st.st_mode & S_IFMT) == S_IFDIR)', 1]
['void unimplemented(int client)', 1]
['/* Put the entire contents of a file out on a socket.  This function', 1]
['sprintf(buf, "<P>Your browser sent a bad request, ");', 1]
['void cat(int client, FILE *resource)', 1]
['(st.st_mode & S_IXGRP) ||', 1]
['#include <strings.h>', 1]
['* easier just to do something like pipe, fork, and exec("cat").', 1]
['* Parameters: a pointer to a file structure produced from the socket', 1]
['char length_env[255];', 1]
['#include <sys/socket.h>', 1]
['if (client_sock == -1)', 1]
['* null character.', 1]
['void cat(int, FILE *);', 1]
['unimplemented(client);', 1]
['* end of the buffer, the string is terminated with a null.  If any of', 1]
['struct sockaddr_in name;', 1]
['* is named after the UNIX "cat" command, because it might have been', 1]
['fclose(resource);', 1]
['#include <stdlib.h>', 1]
['void not_found(int client)', 1]
['FILE *resource = NULL;', 1]
['/* accept_request(client_sock); */', 1]
['* Returns: the number of bytes stored (excluding null) */', 1]
['method[i] = buf[j];', 1]
['sprintf(buf, "HTTP/1.0 501 Method Not Implemented\\r\\n");', 1]
['int i;', 1]
['else    /* POST */', 1]
['while (!ISspace(buf[j]) && (i < sizeof(method) - 1))', 1]
['putenv(query_env);', 1]
['/* A request has caused a call to accept() on the server port to', 1]
['* Created November 1999 by J. David Blackstone.', 1]
['if ((st.st_mode & S_IXUSR) ||', 1]
['int status;', 1]
['error_die("getsockname");', 1]
['* Parameters: the socket descriptor', 1]
['if (strcasecmp(method, "GET") == 0) {', 1]
['int main(void)', 1]
['* implemented.', 1]
['#include <string.h>', 1]
['int startup(u_short *port)', 1]
['#include <sys/stat.h>', 1]
['if (listen(httpd, 5) < 0)', 1]
['/* Send a regular file to the client.  Use headers, and report', 1]
["if ((n > 0) && (c == '\\n'))", 1]
['void serve_file(int, const char *);', 1]
["while ((i < size - 1) && (c != '\\n'))", 1]
['sprintf(buf, "<P>Error prohibited CGI execution.\\r\\n");', 1]
['if (pipe(cgi_input) < 0) {', 1]
['* carriage return, or a CRLF combination.  Terminates the string read', 1]
['* Parameters: the socket connected to the client */', 1]
['execute_cgi(client, path, method, query_string);', 1]
['#include <sys/wait.h>', 1]
['int client_sock = -1;', 1]
['#define ISspace(x) isspace((int)(x))', 1]
['n = recv(sock, &c, 1, 0);', 1]
['/* Get a line from a socket, whether the line ends in a newline,', 1]
['* port and modify the original port variable to reflect the actual', 1]
['sprintf(buf, "</TITLE></HEAD>\\r\\n");', 1]
['pthread_t newthread;', 1]
['#include <arpa/inet.h>', 1]
['j++;', 1]
['strcat(path, "/index.html");', 1]
['u_short port = 0;', 1]
['char query_env[255];', 1]
['*              file descriptor', 1]
['void execute_cgi(int client, const char *path,', 1]
['sprintf(buf, "is unavailable or nonexistent.\\r\\n");', 1]
['void error_die(const char *);', 1]
['void serve_file(int client, const char *filename)', 1]
['(st.st_mode & S_IXOTH)    )', 1]
['* Parameter: the client socket */', 1]
['pid_t pid;', 1]
['/* This program compiles for Sparc Solaris 2.6.', 1]
['waitpid(pid, &status, 0);', 1]
['sprintf(buf, "<HTML><TITLE>Not Found</TITLE>\\r\\n");', 1]
['while (read(cgi_output[0], &c, 1) > 0)', 1]
['close(cgi_input[0]);', 1]
["if (path[strlen(path) - 1] == '/')", 1]
['if (pipe(cgi_output) < 0) {', 1]
['sprintf(buf, "<BODY><P>HTTP request method not supported.\\r\\n");', 1]
['dup2(cgi_output[1], 1);', 1]
['strcat(path, "index.html");', 1]
["if (c == '\\r')", 1]
['send(client, &c, 1, 0);', 1]
['sprintf(buf, "<BODY><P>The server could not fulfill\\r\\n");', 1]
['#define SERVER_STRING "Server: jdbhttpd/0.1.0\\r\\n"', 1]
['putenv(meth_env);', 1]
['/* This function starts the process of listening for web connections', 1]
['while (ISspace(buf[j]) && (j < sizeof(buf)))', 1]
["char c = '\\0';", 1]
['* on value of errno, which indicates system call errors) and exit the', 1]
["buf[15] = '\\0';", 1]
['*             the name of the file to serve */', 1]
['exit(1);', 1]
['i++;', 1]
['sprintf(buf, "such as a POST without a Content-Length.\\r\\n");', 1]
['int cgi_input[2];', 1]
['* appropriate.', 1]
['* CSE 4344 (Network concepts), Prof. Zeigler', 1]
['void bad_request(int);', 1]
['while (!feof(resource))', 1]
['* To compile for Linux:', 1]
['sprintf(length_env, "CONTENT_LENGTH=%d", content_length);', 1]
['sprintf(path, "htdocs%s", url);', 1]
['int startup(u_short *);', 1]
['error_die("listen");', 1]
['*  4) Uncomment the line that runs accept_request().', 1]
['exit(0);', 1]
['/* Inform the client that the requested web method has not been', 1]
['* Parameter: the client socket descriptor. */', 1]
['char c;', 1]
['recv(client, &c, 1, 0);', 1]
['struct sockaddr_in client_name;', 1]
['void accept_request(int);', 1]
['#include <pthread.h>', 1]
['void bad_request(int client)', 1]
['char path[512];', 1]
['#include <stdio.h>', 1]
['if (pthread_create(&newthread , NULL, accept_request, client_sock) != 0)', 1]
['*  1) Comment out the #include <pthread.h> line.', 1]
['dup2(cgi_input[0], 0);', 1]
['strcpy(buf, SERVER_STRING);', 1]
['*             the size of the buffer', 1]
['if (httpd == -1)', 1]
['const char *method, const char *query_string)', 1]
['/* Return the informational HTTP headers about a file. */', 1]
['if (bind(httpd, (struct sockaddr *)&name, sizeof(name)) < 0)', 1]
['cat(client, resource);', 1]
['* program */', 1]
['int n;', 1]
['error_die("accept");', 1]
['#include <ctype.h>', 1]
['bad_request(client);', 1]
['close(server_sock);', 1]
['* Parameters: the client socket descriptor', 1]
['return(i);', 1]
['* Returns: the socket */', 1]
['execl(path, path, NULL);', 1]
['* the above three line terminators is read, the last character of the', 1]
['void headers(int client, const char *filename)', 1]
['return(0);', 1]
['if (pid == 0)  /* child: CGI script */', 1]
['*port = ntohs(name.sin_port);', 1]
['n = recv(sock, &c, 1, MSG_PEEK);', 1]
['sprintf(query_env, "QUERY_STRING=%s", query_string);', 1]
['/* Inform the client that a request it has made has a problem.', 1]
['server_sock = startup(&port);', 1]
['client_sock = accept(server_sock,', 1]
['* string will be a linefeed and the string will be terminated with a', 1]
['#include <netinet/in.h>', 1]
['printf("httpd running on port %d\\n", port);', 1]
['if (stat(path, &st) == -1) {', 1]
['while (!ISspace(buf[j]) && (i < sizeof(url) - 1) && (j < sizeof(buf)))', 1]
['#include <unistd.h>', 1]
['if (strcasecmp(method, "GET") && strcasecmp(method, "POST"))', 1]
['/* Give a client a 404 not found status message. */', 1]
['* port.', 1]
['buf[i] = c;', 1]
['int client_name_len = sizeof(client_name);', 1]
["/* J. David's webserver */", 1]
['sprintf(buf, "HTTP/1.0 200 OK\\r\\n");', 1]
["while ((*query_string != '?') && (*query_string != '\\0'))", 1]
['* program indicating an error. */', 1]
['int cgi = 0;      /* becomes true if server decides this is a CGI', 1]
['if (getsockname(httpd, (struct sockaddr *)&name, &namelen) == -1)', 1]
["url[i] = '\\0';", 1]
['error_die("bind");', 1]
['name.sin_port = htons(*port);', 1]
['i = 0;', 1]
['*             FILE pointer for the file to cat */', 1]
['char method[255];', 1]
['while (1)', 1]
['serve_file(client, path);', 1]
['void headers(int, const char *);', 1]
['memset(&name, 0, sizeof(name));', 1]
['struct stat st;', 1]
['int get_line(int, char *, int);', 1]
['if (n > 0)', 1]
['sprintf(buf, "HTTP/1.0 404 NOT FOUND\\r\\n");', 1]
['sprintf(buf, "HTTP/1.0 500 Internal Server Error\\r\\n");', 1]
['int namelen = sizeof(name);', 1]
['while ((numchars > 0) && strcmp("\\n", buf))', 1]
['int i = 0;', 1]
['close(client);', 1]
['return(httpd);', 1]
['* Parameters: client socket descriptor', 1]
['int numchars;', 1]
['size_t i, j;', 1]
['int content_length = -1;', 1]
['void error_die(const char *sc)', 1]
['headers(client, filename);', 1]
['error_die("socket");', 1]
['&client_name_len);', 1]
['strcpy(buf, "\\r\\n");', 1]
['*             the name of the file */', 1]
['void unimplemented(int);', 1]
['char meth_env[255];', 1]
['char *query_string = NULL;', 1]
['int httpd = 0;', 1]
['i = 0; j = 0;', 1]
['char url[255];', 1]
['/* Inform the client that a CGI script could not be executed.', 1]
['int get_line(int sock, char *buf, int size)', 1]
["buf[i] = '\\0';", 1]
['content_length = atoi(&(buf[16]));', 1]
['/* Execute a CGI script.  Will need to set environment variables as', 1]
['recv(sock, &c, 1, 0);', 1]
['* with a null character.  If no newline indicator is found before the', 1]
['* University of Texas at Arlington', 1]
['void cannot_execute(int client)', 1]
['perror("pthread_create");', 1]
['*             the buffer to save the data in', 1]
['*  5) Remove -lsocket from the Makefile.', 1]
['httpd = socket(PF_INET, SOCK_STREAM, 0);', 1]
['void not_found(int);', 1]
["if (*query_string == '?')", 1]
["*query_string = '\\0';", 1]
['sprintf(buf, "<HTML><HEAD><TITLE>Method Not Implemented\\r\\n");', 1]
['url[i] = buf[j];', 1]
['/* Print out an error message with perror() (for system errors; based', 1]
['/* Parameters: the socket to print the headers on', 1]
['strcpy(buf, "HTTP/1.0 200 OK\\r\\n");', 1]
['resource = fopen(filename, "r");', 1]
['*  3) Comment out the two lines that run pthread_create().', 1]
['/* This is a simple webserver.', 1]
['if (resource == NULL)', 1]
['perror(sc);', 1]
