def decorating_function user_function def wrapper * args ** kwargs if arguments print time ctime : function \' + user_function __qualname__ + \' arguments args= args kwargs= kwargs result = user_function * args ** kwargs if output print time ctime : function \' + user_function __qualname__ + \' outputs result return result return update_wrapper wrapper user_function 		55 63
memoize_it def get_best c j winning if len c == len j == 0 return if winning == c_winning c_res = c replace ? 0 j_res = j replace ? 9 return c_res j_res elif winning == j_winning c_res = c replace ? 9 j_res = j replace ? 0 return c_res j_res else assert winning == undecided if c 0 != ? and j 0 != ? if c 0 > j 0 c_tmp j_tmp = get_best c 1 j 1 c_winning elif c 0 < j 0 c_tmp j_tmp = get_best c 1 j 1 j_winning else c_tmp j_tmp = get_best c 1 j 1 undecided return c 0 + c_tmp j 0 + j_tmp elif c 0 == j 0 == ? c1 j1 = get_best c 1 j 1 undecided c1 = 0 + c1 j1 = 0 + j1 diff1 = get_diff c1 j1 c2 j2 = get_best c 1 j 1 c_winning c2 = 1 + c2 j2 = 0 + j2 diff2 = get_diff c2 j2 c3 j3 = get_best c 1 j 1 j_winning c3 = 0 + c3 j3 = 1 + j3 diff3 = get_diff c3 j3 best_diff = min diff1 diff2 diff3 l = if diff1 == best_diff l append c1 j1 if diff2 == best_diff l append c2 j2 if diff3 == best_diff l append c3 j3 return min l elif c 0 == ? and j 0 != ? d = int j 0 c1 = j1 = none if d > 0 c1 j1 = get_best c 1 j 1 j_winning c1 = str d - 1 + c1 j1 = str d + j1 diff1 = get_diff c1 j1 else diff1 = 2 ** 100 c2 j2 = get_best c 1 j 1 undecided c2 = str d + c2 j2 = str d + j2 diff2 = get_diff c2 j2 c3 = j3 = none if d < 9 c3 j3 = get_best c 1 j 1 c_winning c3 = str d + 1 + c3 j3 = str d + j3 diff3 = get_diff c3 j3 else diff3 = 2 ** 100 best_diff = min diff1 diff2 diff3 l = if diff1 == best_diff l append c1 j1 if diff2 == best_diff l append c2 j2 if diff3 == best_diff l append c3 j3 return min l else assert c 0 != ? and j 0 == ? d = int c 0 c1 = j1 = none if d > 0 c1 j1 = get_best c 1 j 1 c_winning c1 = str d + c1 j1 = str d - 1 + j1 diff1 = get_diff c1 j1 else diff1 = 2 ** 100 c2 j2 = get_best c 1 j 1 undecided c2 = str d + c2 j2 = str d + j2 diff2 = get_diff c2 j2 c3 = j3 = none if d < 9 c3 j3 = get_best c 1 j 1 j_winning c3 = str d + c3 j3 = str d + 1 + j3 diff3 = get_diff c3 j3 else diff3 = 2 ** 100 best_diff = min diff1 diff2 diff3 l = if diff1 == best_diff l append c1 j1 if diff2 == best_diff l append c2 j2 if diff3 == best_diff l append c3 j3 return min l 		231 353
def get_diff c j return abs int c - int j 		356 357
def time_it inner_func wraps inner_func def wrapper * args ** kwargs print --> start function \' + inner_func __qualname__ + \' : time ctime start_time = time time res = inner_func * args ** kwargs end_time = time time print --> end  function \' + inner_func __qualname__ + \' : time ctime print --> elapsed time \' + inner_func __qualname__ + \' : end_time - start_time print return res return wrapper 		39 50
time_it def main_run print directory : os getcwd file_names = x for x in os listdir l1 = os stat x st_mtime x for x in file_names if x endswith .in if not l1 raise valueerror no input file found chosen_prefix = sorted l1 - 1 1 - 3 input_filename = chosen_prefix + .in print chosen input : input_filename parsed_filename = chosen_prefix + .parsed.txt l2 = x split . 0 for x in file_names if x endswith .out and x startswith chosen_prefix l2 = int x split -run - 1 for x in l2 output_file_index = 000 + str max 0 + l2 + 1 - 3 output_filename = chosen_prefix + -run + output_file_index + .out print chosen output : output_filename print io_wrapper = gcjiowrapper input_filename parsed_filename output_filename with io_wrapper solve_all_cases io_wrapper print print conclusion : print directory : os getcwd print chosen input : input_filename print chosen output : output_filename 		161 197
def readline self l = self __input_file readline self __parsed_file write l return l 		140 144
def get_test_case self return self __index_test_case 		155 157
def __init__ self input_filename parsed_filename output_filename self __input_filename = input_filename self __parsed_filename = parsed_filename self __output_filename = output_filename self __index_test_case = 0 self __input_file = none self __parsed_file = none self __output_file = none 		119 126
time_it def solve_all_cases io_wrapper t = int io_wrapper readline for test_case in range 1 t + 1 io_wrapper new_test_case assert io_wrapper get_test_case == test_case solve_one_case io_wrapper 		201 207
def __exit__ self type_e value tb self __input_file close self __parsed_file close self __output_file close 		134 138
def __enter__ self self __input_file = open self __input_filename r self __parsed_file = open self __parsed_filename w self __output_file = open self __output_filename w 		128 132
def log_it arguments = true output = true def decorating_function user_function def wrapper * args ** kwargs if arguments print time ctime : function \' + user_function __qualname__ + \' arguments args= args kwargs= kwargs result = user_function * args ** kwargs if output print time ctime : function \' + user_function __qualname__ + \' outputs result return result return update_wrapper wrapper user_function return decorating_function 		54 64
def write self s self __output_file write s 		151 153
def wrapper * args ** kwargs if arguments print time ctime : function \' + user_function __qualname__ + \' arguments args= args kwargs= kwargs result = user_function * args ** kwargs if output print time ctime : function \' + user_function __qualname__ + \' outputs result return result 		56 62
def memoize_it inner_func global __memoization_registry cache = __memoization_registry append cache wraps inner_func def wrapper * args ** kwargs if args not in cache cache args = inner_func * args ** kwargs return cache args return wrapper 		15 25
def reset_memoization global __memoization_registry try for cache_d in __memoization_registry cache_d clear 		29 33
wraps inner_func def wrapper * args ** kwargs print --> start function \' + inner_func __qualname__ + \' : time ctime start_time = time time res = inner_func * args ** kwargs end_time = time time print --> end  function \' + inner_func __qualname__ + \' : time ctime print --> elapsed time \' + inner_func __qualname__ + \' : end_time - start_time print return res 		40 49
def new_test_case self self __index_test_case += 1 self __parsed_file write \n## _bigonion test case: + str self __index_test_case + ##\n 		146 149
wraps inner_func def wrapper * args ** kwargs if args not in cache cache args = inner_func * args ** kwargs return cache args 		20 24
def count_it inner_func global _call_func_counters assert type _call_func_counters == dict assert inner_func __qualname__ not in _call_func_counters _call_func_counters inner_func __qualname__ = 0 wraps inner_func def wrapper * args ** kwargs global _call_func_counters _call_func_counters inner_func __qualname__ += 1 return inner_func * args ** kwargs return wrapper 		68 79
def solve_one_case io_wrapper c j = io_wrapper readline split assert len c == len j c_res j_res = get_best c j undecided io_wrapper write case # + str io_wrapper get_test_case + : + c_res +  + j_res + \n 		218 226
wraps inner_func def wrapper * args ** kwargs global _call_func_counters _call_func_counters inner_func __qualname__ += 1 return inner_func * args ** kwargs 		74 78
time_it wraps inner_func def wrapper * args ** kwargs filename = pre-process_ + inner_func __qualname__ + .pickle if filename not in os listdir print --> pre process started for function \' + inner_func __qualname__ + \' .... pre_process_data = inner_func print --> pre process ended for function \' + inner_func __qualname__ + \' print --> pickling started for function \' + inner_func __qualname__ + \' .... with open filename wb as f_pp pickle dump pre_process_data f_pp pickle highest_protocol print --> pickling ended for function \' + inner_func __qualname__ + \' print --> unpickling pre-processed data of function \' + inner_func __qualname__ + \' ... with open filename rb as f_pp data = pickle load f_pp print --> unpickling ended print return data 		90 107
def pre_process_it inner_func import inspect import pickle a = inspect getargspec inner_func if a args or a keywords or a varargs or a defaults raise valueerror a pre process function must not have arguments time_it wraps inner_func def wrapper * args ** kwargs filename = pre-process_ + inner_func __qualname__ + .pickle if filename not in os listdir print --> pre process started for function \' + inner_func __qualname__ + \' .... pre_process_data = inner_func print --> pre process ended for function \' + inner_func __qualname__ + \' print --> pickling started for function \' + inner_func __qualname__ + \' .... with open filename wb as f_pp pickle dump pre_process_data f_pp pickle highest_protocol print --> pickling ended for function \' + inner_func __qualname__ + \' print --> unpickling pre-processed data of function \' + inner_func __qualname__ + \' ... with open filename rb as f_pp data = pickle load f_pp print --> unpickling ended print return data return wrapper 		83 109
