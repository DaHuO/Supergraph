def main n = input for i in range n c j = raw_input split print case #%d: %s % i + 1  join map str solve c j 		3 7
def nexts c if c == 9 return 8 9 0 elif c == 0 return 9 0 1 elif c == 1 return 0 1 2 9 elif c == 8 return 0 7 8 9 else tmp = ord c return 0 + tuple map chr tmp - 1 tmp tmp + 1 + 9 		10 21
def rec c j cand_c cand_j current = none if debug print rec%s % c j cand_c cand_j current if ? not in c and ? not in j result = better c j current if debug print -> result return result for i cs in enumerate cand_c if cs and c i == ? for k c in enumerate cs if debug print <cs %s[%d] for %s: % cs k c j result = rec c i + c + c i + 1 j cand_c i + + cand_c i + 1 cand_j current current = better result current if debug print current > for i js in enumerate cand_j if js and j i == ? for k j in enumerate js if debug print <js %s[%d] for %s: % js k c j result = rec c j i + j + j i + 1 cand_c cand_j i + + cand_j i + 1 current current = better result current if debug print current > if debug print -> current return current 		59 89
def better new current if current is none return new else c j = new if abs int c - int j < abs int current 0 - int current 1 return new elif abs int c - int j == abs int current 0 - int current 1 and int c + int j < sum map int current return new else return current 		44 57
def solve c j cand_c = cand_j = for c j in zip c j if c == ? if j == ? cand_c append 9 0 1 cand_j append 9 0 1 else cand_c append nexts j cand_j append else if j == ? cand_c append cand_j append nexts c else cand_c append cand_j append return rec c j cand_c cand_j 		23 42
