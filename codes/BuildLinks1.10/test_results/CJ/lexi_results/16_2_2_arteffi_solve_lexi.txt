def fill x y div higher fx = for i dx dy in enumerate zip x y if dx != ? fx append dx elif i < div fx append dy if dy != ? else 0 elif i == div if higher if dy != ? and dy != 9 fx append str int dy + 1 else fx append 1 else if dy != ? and dy != 0 fx append str int dy - 1 else fx append 0 else if higher fx append 0 else fx append 9 return join fx 		66 89
def output_solutions solutions with open output w as f for i solution in enumerate solutions 1 f write case #{i}: {a} {b}\n format i = i a = solution 0 b = solution 1 		26 29
def solve a b n = len a possibilities = for div in range n + 1 if div == n fa = fill a b div none fb = fill b a div none score_a score_b = int fa int fb score = abs score_a - score_b possibilities append score score_a score_b fa fb break da db = a div b div differ = da != ? and db != ? and da != db fa = fill a b div true fb = fill b a div false score_a score_b = int fa int fb score = abs score_a - score_b possibilities append score score_a score_b fa fb fa = fill a b div false fb = fill b a div true score_a score_b = int fa int fb score = abs score_a - score_b possibilities append score score_a score_b fa fb if differ break best = min possibilities return best 3 best 4 		32 63
def main test_cases = parse_input input_path solutions = for i test_case in enumerate test_cases print - * 10 print test case i a b = test_case solution = solve a b print test_case -> solution solutions append solution output_solutions solutions 		3 14
def parse_input path with open path as f n = int f readline lines = f read split \n test_cases = line split for line in lines n assert n == len test_cases return test_cases 		17 23
