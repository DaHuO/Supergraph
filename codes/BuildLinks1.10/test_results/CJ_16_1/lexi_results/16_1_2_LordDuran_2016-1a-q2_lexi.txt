def do_case ncase n = parse_line lists_copy = lists = for i in xrange 2 * n - 1 lists append parse_line lists_copy append lists - 1 mat = 0 * n for i in xrange n print lists assert recurse lists mat 0 0 false l = rows_and_cols = for i in xrange n l = mat i j for j in xrange n rows_and_cols append l for j in xrange n l = mat i j for i in xrange n rows_and_cols append l print mat for l in mat print l print print rnc rows_and_cols print lc lists_copy for l in lists_copy rows_and_cols remove l assert len rows_and_cols == 1 missing_l = rows_and_cols 0 print missing missing_l print >> outputfile out_s % ncase str  join str c for c in missing_l 		94 132
def recurse lists mat i j used = false if len lists == 0 return true n = len lists 0 if i == n or j == n rows_and_cols = for i in xrange n l = mat i j for j in xrange n rows_and_cols append l for j in xrange n l = mat i j for i in xrange n rows_and_cols append l for l in lists if l not in rows_and_cols return false return true possible_rows = possible_cols = for l in lists can_row = can_col = true if i < n for j in xrange j if l j != mat i j can_row = false if i > 0 for j in xrange j n if l j <= mat i - 1 j can_row = false if j < n for i in xrange i if l i != mat i j can_col = false if j > 0 for i in xrange i n if l i <= mat i j - 1 can_col = false if can_col possible_cols append l if can_row possible_rows append l if len possible_cols == 0 and j < n used = true if len possible_rows == 0 and i < n used = true possible_cols sort possible_rows sort for pc in possible_cols for i in xrange n mat i j = pc i lists remove pc if recurse lists mat i j + 1 return true lists append pc for pr in possible_rows for j in xrange n mat i j = pr j lists remove pr if recurse lists mat i + 1 j return true lists append pr return false 		10 92
