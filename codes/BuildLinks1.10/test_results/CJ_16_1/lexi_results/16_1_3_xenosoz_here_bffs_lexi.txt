def make_group n current = n min_node = n for cycle_length in range 1 n + 1 current = f current min_node = min min_node current if n == current return cycle min_node cycle_length return cycle min_node 0 		29 38
def solve n = int input f = int x - 1 for x in input split assert n == len f def make_group n current = n min_node = n for cycle_length in range 1 n + 1 current = f current min_node = min min_node current if n == current return cycle min_node cycle_length return cycle min_node 0 groups = list map make_group range n case_1_max = max map attrgetter rank groups paths = none * n def follow_path n if paths n is not none return paths n if groups n rank == 2 new_p = path true n 0 paths n = new_p return new_p if groups n rank != 0 new_p = path false - 1 - 1 paths n = new_p return new_p p = follow_path f n if not p valid new_p = path false - 1 - 1 paths n = new_p return new_p new_p = path true p leader p rank + 1 paths n = new_p return new_p for c in range n follow_path c longest_path = 0 * n for c in range n longest_path paths c leader = max longest_path paths c leader paths c rank case_2_max = 0 for c in range n g = groups c if g rank != 2 continue left = c right = f c score = longest_path left + g rank + longest_path right case_2_max += score assert case_2_max % 2 == 0 case_2_max //= 2 return max case_1_max case_2_max 		24 91
def follow_path n if paths n is not none return paths n if groups n rank == 2 new_p = path true n 0 paths n = new_p return new_p if groups n rank != 0 new_p = path false - 1 - 1 paths n = new_p return new_p p = follow_path f n if not p valid new_p = path false - 1 - 1 paths n = new_p return new_p new_p = path true p leader p rank + 1 paths n = new_p return new_p 		47 69
def __init__ self leader rank self leader = leader self rank = rank 		14 16
def __init__ self valid leader rank self valid = valid self leader = leader self rank = rank 		19 22
