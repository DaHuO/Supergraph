def all_perms elements if len elements <= 1 yield elements else for perm in all_perms elements 1 for i in range len elements yield perm i + elements 0 1 + perm i 		132 138
def __init__ self tid threading thread __init__ self self tid = tid pass 		76 79
def all_perms elements if len elements <= 1 yield elements else for perm in all_perms elements 1 for i in range len elements yield perm i + elements 0 1 + perm i 		187 193
def run self global t lock queue while true lock acquire if queue empty lock release break t fs = queue get lock release n = len fs maxl = 0 for i in xrange 2 ** n - 1 - 1 - 1 b = {0:b} format i b = 0 * n - len b + b ns = pos for pos in xrange len b if b pos == 1 if len ns > maxl print (case %d/%d, thread %d) testing with: %d % t + 1 t self tid len ns ns_set = set ns valid1 = true for n in ns if not fs n in ns_set valid1 = false break valid2 = false if valid1 f0 = fs ns 0 ns = ns 0 + f0 + ns 1 ns index f0 + ns ns index f0 + 1 tail = ns 2 for perm_x in all_perms ns 2 perm = ns 2 + perm_x valid2 = true for j in xrange len perm if not fs perm j in perm j - 1 perm j + 1 % len perm valid2 = false break if valid2 break if valid2 maxl = len ns lock acquire cases t = maxl lock release 		81 128
